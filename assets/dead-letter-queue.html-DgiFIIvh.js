import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,d as t}from"./app-Y2o9GSn_.js";const e={},p=t(`<div class="hint-container tip"><p class="hint-container-title">✨✨✨✨✨</p><p>死信队列（Dead-Letter Queue，DLQ）是一个特殊的消息队列，用于存储无法被消费者正确处理的“死信”消息。当消息被发送到队列时，如果这条消息无法被消费者成功处理或超过了 TTL 时间限制，那么就会被发送到死信队列中。</p><p>使用死信队列的主要目的是防止消息丢失或者被忽略，同时也方便进行消息重试、错误分析和监控等操作。</p></div><p>在 RabbitMQ 中，可以通过以下步骤来创建和配置死信队列：</p><ol><li><p>创建一个普通的消息队列，并将该队列与一个交换机绑定。</p></li><li><p>为该队列设置 DLX 属性，指定该队列的死信消息应该发送到哪个交换机中。</p></li><li><p>创建一个专门用于存储死信消息的队列，并将该队列与上一步所指定的交换机绑定。</p></li><li><p>配置队列的 TTL 和其他属性，以便在特定条件下将消息发送到死信队列中。</p></li></ol><p>以下是一个示例代码，展示了如何使用 .NET 6 创建一个带有死信队列的 RabbitMQ 消息队列：</p><div class="language-csharp line-numbers-mode" data-ext="cs" data-title="cs"><pre class="language-csharp"><code><span class="token comment">// 创建连接和通道对象</span>
<span class="token class-name"><span class="token keyword">var</span></span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">ConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> HostName <span class="token operator">=</span> <span class="token string">&quot;localhost&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> connection <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">CreateConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> channel <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">CreateModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 创建一个普通的消息队列</span>
    <span class="token class-name"><span class="token keyword">var</span></span> queueName <span class="token operator">=</span> <span class="token string">&quot;test_queue&quot;</span><span class="token punctuation">;</span>
    channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">queue</span><span class="token punctuation">:</span> queueName<span class="token punctuation">,</span> <span class="token named-parameter punctuation">durable</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">exclusive</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">autoDelete</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">arguments</span><span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置队列的 TTL 和 DLX 属性</span>
    <span class="token class-name"><span class="token keyword">var</span></span> arguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Dictionary<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span> <span class="token keyword">object</span><span class="token punctuation">&gt;</span></span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">{</span> <span class="token string">&quot;x-message-ttl&quot;</span><span class="token punctuation">,</span> <span class="token number">30000</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 设置队列中消息的 TTL 为 30 秒</span>
        <span class="token punctuation">{</span> <span class="token string">&quot;x-dead-letter-exchange&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dlx_exchange&quot;</span> <span class="token punctuation">}</span> <span class="token comment">// 设置该队列的死信交换机为 dlx_exchange</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 将队列与交换机绑定，并设置队列属性</span>
    channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">queue</span><span class="token punctuation">:</span> queueName<span class="token punctuation">,</span> <span class="token named-parameter punctuation">exchange</span><span class="token punctuation">:</span> <span class="token string">&quot;test_exchange&quot;</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">routingKey</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建一个专门用于存储死信消息的队列</span>
    <span class="token class-name"><span class="token keyword">var</span></span> dlxQueueName <span class="token operator">=</span> <span class="token string">&quot;test_dlx_queue&quot;</span><span class="token punctuation">;</span>
    channel<span class="token punctuation">.</span><span class="token function">QueueDeclare</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">queue</span><span class="token punctuation">:</span> dlxQueueName<span class="token punctuation">,</span> <span class="token named-parameter punctuation">durable</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">exclusive</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">autoDelete</span><span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">arguments</span><span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 将死信队列与指定的交换机绑定</span>
    channel<span class="token punctuation">.</span><span class="token function">ExchangeDeclare</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">exchange</span><span class="token punctuation">:</span> <span class="token string">&quot;dlx_exchange&quot;</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">type</span><span class="token punctuation">:</span> ExchangeType<span class="token punctuation">.</span>Fanout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    channel<span class="token punctuation">.</span><span class="token function">QueueBind</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">queue</span><span class="token punctuation">:</span> dlxQueueName<span class="token punctuation">,</span> <span class="token named-parameter punctuation">exchange</span><span class="token punctuation">:</span> <span class="token string">&quot;dlx_exchange&quot;</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">routingKey</span><span class="token punctuation">:</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 启动消费者，接收消息并输出</span>
    <span class="token class-name"><span class="token keyword">var</span></span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">EventingBasicConsumer</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    consumer<span class="token punctuation">.</span>Received <span class="token operator">+=</span> <span class="token punctuation">(</span>model<span class="token punctuation">,</span> ea<span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token class-name"><span class="token keyword">var</span></span> message <span class="token operator">=</span> Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span><span class="token function">GetString</span><span class="token punctuation">(</span>ea<span class="token punctuation">.</span>Body<span class="token punctuation">.</span><span class="token function">ToArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token interpolation-string"><span class="token string">$&quot;Received message: </span><span class="token interpolation"><span class="token punctuation">{</span><span class="token expression language-csharp">message</span><span class="token punctuation">}</span></span><span class="token string">&quot;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    channel<span class="token punctuation">.</span><span class="token function">BasicConsume</span><span class="token punctuation">(</span><span class="token named-parameter punctuation">queue</span><span class="token punctuation">:</span> queueName<span class="token punctuation">,</span> <span class="token named-parameter punctuation">autoAck</span><span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token named-parameter punctuation">consumer</span><span class="token punctuation">:</span> consumer<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">&quot;Press [enter] to exit.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在上述示例中，我们首先创建了一个普通的消息队列，并将该队列与交换机进行了绑定。然后，我们通过 QueueDeclare 方法为该队列设置了 TTL 和 DLX 属性，以及其他相关属性。</p><p>接下来，我们创建了一个专门用于存储死信消息的队列，将该队列与指定的 DLX 交换机进行了绑定，并使用 ExchangeDeclare 方法声明了该交换机的类型为 Fanout。</p><p>最后，我们启动了一个消费者，循环接收并输出队列中的消息。在运行时，如果某条消息无法被正确处理或者超过了 TTL 时间限制，那么它就会被自动发送到死信队列中，从而保证消息不会丢失或者被忽略。</p>`,8),o=[p];function c(u,l){return a(),s("div",null,o)}const k=n(e,[["render",c],["__file","dead-letter-queue.html.vue"]]),d=JSON.parse('{"path":"/articles/distributed-middleware/rabbitmq/dead-letter-queue.html","title":"死信队列","lang":"zh-CN","frontmatter":{"title":"死信队列","date":"2023-03-04T00:00:00.000Z","category":["分布式中间件"],"tag":["RabbitMQ"],"timeline":true,"order":7,"description":"✨✨✨✨✨ 死信队列（Dead-Letter Queue，DLQ）是一个特殊的消息队列，用于存储无法被消费者正确处理的“死信”消息。当消息被发送到队列时，如果这条消息无法被消费者成功处理或超过了 TTL 时间限制，那么就会被发送到死信队列中。 使用死信队列的主要目的是防止消息丢失或者被忽略，同时也方便进行消息重试、错误分析和监控等操作。","head":[["meta",{"property":"og:url","content":"http://blog.goodsxx.cn/articles/distributed-middleware/rabbitmq/dead-letter-queue.html"}],["meta",{"property":"og:site_name","content":"Growing Notes"}],["meta",{"property":"og:title","content":"死信队列"}],["meta",{"property":"og:description","content":"✨✨✨✨✨ 死信队列（Dead-Letter Queue，DLQ）是一个特殊的消息队列，用于存储无法被消费者正确处理的“死信”消息。当消息被发送到队列时，如果这条消息无法被消费者成功处理或超过了 TTL 时间限制，那么就会被发送到死信队列中。 使用死信队列的主要目的是防止消息丢失或者被忽略，同时也方便进行消息重试、错误分析和监控等操作。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-13T18:24:18.000Z"}],["meta",{"property":"article:author","content":"SongXinXin"}],["meta",{"property":"article:tag","content":"RabbitMQ"}],["meta",{"property":"article:published_time","content":"2023-03-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-13T18:24:18.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"死信队列\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-04T00:00:00.000Z\\",\\"dateModified\\":\\"2023-03-13T18:24:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"SongXinXin\\"}]}"]]},"headers":[],"git":{"createdTime":1678731858000,"updatedTime":1678731858000,"contributors":[{"name":"SongXinXin","email":"1368084801@qq.com","commits":1}]},"readingTime":{"minutes":2.55,"words":765},"filePathRelative":"articles/distributed-middleware/rabbitmq/dead-letter-queue.md","localizedDate":"2023年3月4日","excerpt":"<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">✨✨✨✨✨</p>\\n<p>死信队列（Dead-Letter Queue，DLQ）是一个特殊的消息队列，用于存储无法被消费者正确处理的“死信”消息。当消息被发送到队列时，如果这条消息无法被消费者成功处理或超过了 TTL 时间限制，那么就会被发送到死信队列中。</p>\\n<p>使用死信队列的主要目的是防止消息丢失或者被忽略，同时也方便进行消息重试、错误分析和监控等操作。</p>\\n</div>\\n","autoDesc":true}');export{k as comp,d as data};
