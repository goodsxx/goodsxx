const g=(o,a)=>{const i=o.toLowerCase(),e=a.toLowerCase(),s=[];let n=0,l=0;const c=(t,p=!1)=>{let r="";l===0?r=t.length>20?`… ${t.slice(-20)}`:t:p?r=t.length+l>100?`${t.slice(0,100-l)}… `:t:r=t.length>20?`${t.slice(0,20)} … ${t.slice(-20)}`:t,r&&s.push(r),l+=r.length,p||(s.push(["strong",a]),l+=a.length,l>=100&&s.push(" …"))};let h=i.indexOf(e,n);if(h===-1)return null;for(;h>=0;){const t=h+e.length;if(c(o.slice(n,h)),n=t,l>100)break;h=i.indexOf(e,n)}return l<100&&c(o.slice(n),!0),s},d=Object.entries,y=Object.keys,f=o=>o.reduce((a,{type:i})=>a+(i==="title"?50:i==="heading"?20:i==="custom"?10:1),0),$=(o,a)=>{var i;const e={};for(const[s,n]of d(a)){const l=((i=a[s.replace(/\/[^\\]*$/,"")])==null?void 0:i.title)||"",c=`${l?`${l} > `:""}${n.title}`,h=g(n.title,o);h&&(e[c]=[...e[c]||[],{type:"title",path:s,display:h}]),n.customFields&&d(n.customFields).forEach(([t,p])=>{p.forEach(r=>{const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"custom",path:s,index:t,display:u}])})});for(const t of n.contents){const p=g(t.header,o);p&&(e[c]=[...e[c]||[],{type:"heading",path:s+(t.slug?`#${t.slug}`:""),display:p}]);for(const r of t.contents){const u=g(r,o);u&&(e[c]=[...e[c]||[],{type:"content",header:t.header,path:s+(t.slug?`#${t.slug}`:""),display:u}])}}}return y(e).sort((s,n)=>f(e[s])-f(e[n])).map(s=>({title:s,contents:e[s]}))},m=JSON.parse("{\"/\":{\"/chatgpt.html\":{\"title\":\"ChatGPT\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"提示\",\"欢迎体验ChatGPT！\\n如果我的博客对您有帮助，请给颗⭐支持一下！\"]}]},\"/intro.html\":{\"title\":\"\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"这是自我介绍页\"]}]},\"/liuyanban.html\":{\"title\":\"留言板\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"提示\",\"欢迎留言！\"]}]},\"/slides.html\":{\"title\":\"幻灯片页\",\"contents\":[]},\"/about-this-website/\":{\"title\":\"本站指南\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"本站原始版本(现已升级)基于 VuePress 的一款第三方主题 vuepress-theme-reco 搭建，我将在本系列为大家介绍如何搭建并完善自己的个人博客。\",\"博客只是内容的载体，精力集中在内容上才更有价值。\"]}]},\"/about-this-website/vuepress-auto-release.html\":{\"title\":\"VuePress自动化部署\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"通过gitee仓库的WebHook回调实现VuePress项目的自动化部署\"]},{\"header\":\"在Linux上部署VuePress\",\"slug\":\"在linux上部署vuepress\",\"contents\":[]},{\"header\":\"新建脚本文件\",\"slug\":\"新建脚本文件\",\"contents\":[\"在VuePress项目根目录中新建shell脚本文件 start.sh\",\"编辑start.sh脚本文件并上传至git仓库\",\" #!/bin/bash # 切入源码目录，以确保能正常执行 cd /home/my/my-vuepress # 拉取最新代码 git pull # 杀死目前已启动进程 ID=`ps -ef|grep node | grep vuepress|awk '{print $2}'` echo --- the process is $ID --- kill -9 $ID echo \\\"Killed $ID\\\" # 更新包 npm i # 后台启动 nohup npm run pro& \",\"在Linux上拉取更新\",\"cd /home/my/my-vuepress git pull \",\"为脚本文件授予权限\",\"chmod 775 /home/my/my-vuepress/start.sh \"]},{\"header\":\"编写接口用于在接口调用时执行脚本\",\"slug\":\"编写接口用于在接口调用时执行脚本\",\"contents\":[\"此处以Asp.Net Core Web Api为例\",\"打开VS2022，选择 ASP.Net Core Web Api 项目\",\"创建项目\",\"为项目命名，勾选'将解决方案和项目放在同一目录'\",\"为项目命名\",\"框架选择.NET6.0\",\"选择框架\",\"在Controllers文件夹下新建WebHookController.cs\",\"namespace ScriptExecutor.Controllers { [ApiController] [Route(\\\"[controller]/[action]\\\")] public class WebHookController : ControllerBase { [HttpPost(\\\"ExecoutScript\\\")] public string Post([FromBody] object inDto) { try { Process.Start(\\\"./start.sh\\\"); return \\\"执行成功！\\\"; } catch (Exception ex) { return $\\\"执行失败：{ex.Message}\\\"; } } } } \",\"在Program.cs类中，配置项目的启动端口\",\"builder.WebHost.UseUrls(new[] { \\\"http://*:8080\\\" }); \"]},{\"header\":\"发布项目\",\"slug\":\"发布项目\",\"contents\":[\"右键项目，选择'发布'\",\"发布\",\"选择'文件夹'，直接点击'下一步'——>'完成'\",\"文件夹发布\",\"完成\",\"点击'发布'\",\"发布\"]},{\"header\":\"部署回调接口\",\"slug\":\"部署回调接口\",\"contents\":[\"将bin\\\\Release\\\\net6.0\\\\publish\\\\publish文件夹的下的所有项目上传至linux服务器中的/home/my/script-executor文件夹下\",\"在Linux上安装.Net6环境\",\"进入home/my/my-vuepress路径下\",\"cd /home/my/my-vuepress \",\"运行ScriptExecutor项目\",\"dotnet /home/my/script-executor/ScriptExecutor.dll \",\"配置git仓库的WebHook，使其在推送代码时自动触发接口(此处以gitee为例)\",\" 6. 配置webhook的回调地址\",\"配置回调地址\",\"测试效果\",\"效果\",\"返回执行成功，说明脚本已成功执行，之后提交代码时，便会通过webhook回调接口去触发脚本的执行，从而实现vuepress的自动发布\"]},{\"header\":\"设置项目开机启动\",\"slug\":\"设置项目开机启动\",\"contents\":[\"在linux服务器root目录下新建start.sh脚本\",\"#!/bin/bash # 切入源码目录，以确保能正常执行 cd /home/my/my-blog # 启动webhook接口 nohup dotnet /home/my/script-executor/ScriptExecutor.dll # 拉取最新代码1 git pull # 杀死目前已启动进程 ID=`ps -ef|grep node | grep vuepress|awk '{print $2}'` echo --- the process is $ID --- kill -9 $ID echo \\\"Killed $ID\\\" # 更新包 yarn # 启动 nohup yarn pro& \",\"在Linux上设置shell脚本开机启动\"]}]},\"/about-this-website/vuepress-comment-tutorial.html\":{\"title\":\"VuePress加入评论功能\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"通过引入第三方插件 vuepress-plugin-comment 和 valine，让你的博客支持评论功能。\"]},{\"header\":\"注册LeanCloud\",\"slug\":\"注册leancloud\",\"contents\":[\"注册账号LeanCloud\",\"创建应用\",\"img\",\"在 应用设置 中的 应用凭证 中可以查看 AppID 和 AppKey\",\"img\"]},{\"header\":\"安装插件\",\"slug\":\"安装插件\",\"contents\":[\"npm install --save vuepress-plugin-comment npm install --save valine \"]},{\"header\":\"添加配置\",\"slug\":\"添加配置\",\"contents\":[\"在config.js中添加相关配置\",\"module.exports = { themeConfig: { valineConfig: { appId: '',// your appId appKey: '', // your appKey } } } \"]}]},\"/about-this-website/vuepress-release.html\":{\"title\":\"在Linux上部署VuePress\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"在Linux上部署我们的VuePress个人博客网站\",\"将VuePress项目上传至GitHub或Gitee仓库，不会的自行百度\",\"在Linux上安装Node/Npm\",\"在Linux上安装Git\",\"复制你的仓库地址(此处以gitee为例)\",\"img\",\"在Linux上的home/my文件夹下拉取Git仓库中的VuePress项目\",\"git clone https://你的仓库地址/my-vuepress.git \",\"进入刚下载的VuePress项目文件夹下\",\"cd /home/my/my-vuepress \",\"初始化项目\",\"npm i \",\"运行项目\",\"npm run dev \",\"此时用你的服务器IP+VuePress启动的端口号即可访问\"]}]},\"/about-this-website/vuepress-tutorial.html\":{\"title\":\"使用VuePress搭建个人博客\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"手把手教你使用VuePress搭建自己的个人博客。\"]},{\"header\":\"VuePress介绍\",\"slug\":\"vuepress介绍\",\"contents\":[\"VuePress 是一个以 Markdown 为中心的静态网站生成器。你可以使用 Markdown 来书写内容（如文档、博客等），然后 VuePress 会帮助你生成一个静态网站来展示它们。\",\"一个 VuePress 站点本质上是一个由 Vue 和 Vue Router 驱动的单页面应用 (SPA)。\",\"路由会根据你的 Markdown 文件的相对路径来自动生成。每个 Markdown 文件都通过 markdown-it 编译为 HTML ，然后将其作为 Vue 组件的模板。因此，你可以在 Markdown 文件中直接使用 Vue 语法，便于你嵌入一些动态内容。\",\"在开发过程中，VuePress会启动一个常规的开发服务器 (dev-server) ，并将 VuePress 站点作为一个常规的 SPA。如果你以前使用过 Vue 的话，你在使用时会感受到非常熟悉的开发体验。\"]},{\"header\":\"VuePress-Theme-Reco介绍\",\"slug\":\"vuepress-theme-reco介绍\",\"contents\":[\"vuepress-theme-reco 是针对VuePress开发的一款第三方主题，该主题几乎继承 VuePress 默认主题的一切功能，并支持通过脚手架快速搭建，虽然该主题现已推出2.x的alpha版本，但鉴于正式版还未推出，本教程将基于该主题的1.x版本进行讲解。\"]},{\"header\":\"快速开始\",\"slug\":\"快速开始\",\"contents\":[\"安装theme-cli脚手架\",\"在控制台输入以下命令\",\"npm install @vuepress-reco/theme-cli@1.0.7 -g \",\"代码效果\",\"初始化项目\",\"输入以下命令进行项目初始化\",\"theme-cli init \",\"是否创建文件夹\",\"提示是否创建文件夹？若创建文件夹，此处可选择'n'，我没有创建故这里选择'y'\",\"操作步骤\",\"提示输入文件夹名称，同上，已创建文件夹的可以直接按回车跳过此步\",\"之后的操作分别是 标题(首页显示)、描述(首页显示)、作者(首页显示)、选择模板，模板这里我们要选择'blog'，中间的步骤都可以直接按回车跳过\",\"等待\",\"等待从git上下载文件\",\"创建成功\",\"如图，项目已成功创建\",\"启动项目\",\"控制台输入 npm i下载依赖文件\",\"npm i \",\"等待\",\"等待安装成功\",\"输入 npm run dev启动项目\",\"npm run dev \",\"效果\",\"至此博客已搭建完成\"]},{\"header\":\"个性化配置\",\"slug\":\"个性化配置\",\"contents\":[\"关于配置方面 VuePress 和 vuepress-theme-reco 的官方文档已经介绍的很详细了，除一部分功能及插件的使用将单独介绍外，其他的配置教程请参照官方文档，本文不再赘述。\"]}]},\"/articles/\":{\"title\":\"文章列表\",\"contents\":[{\"header\":\"系列\",\"slug\":\"系列\",\"contents\":[\"分布式中间件系列\",\"MAUI系列\",\"Linux系列\",\"微服务系列\",\"设计模式\",\"工具\"]},{\"header\":\"零碎内容\",\"slug\":\"零碎内容\",\"contents\":[\"前端\",\"后端\",\"其它\"]}]},\"/articles/design-pattern/\":{\"title\":\"设计模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"本教程将通过 C# 代码示例，一步一步向您讲解设计模式的概念\"]},{\"header\":\"设计模式简介\",\"slug\":\"设计模式简介\",\"contents\":[\"设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。\"]},{\"header\":\"设计模式的类型\",\"slug\":\"设计模式的类型\",\"contents\":[\"设计模式一共有23种，这些模式可以分为三大类：创建型模式、行为型模式、结构型模式。\"]},{\"header\":\"序号\",\"contents\":[]},{\"header\":\"模式&描述\",\"contents\":[]},{\"header\":\"设计模式\",\"contents\":[\"1\"]},{\"header\":\"创建型模式\",\"contents\":[\" 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 \",\"1. 单例模式2. 工厂模式3. 抽象工厂模式4. 建造者模式5. 原型模式\",\"2\"]},{\"header\":\"行为型模式\",\"contents\":[\" 这些设计模式特别关注对象之间的通信。 \",\"6. 迭代器模式7. 命令模式8. 解释器模式9. 责任链模式10. 观察者模式11. 中介者模式12. 备忘录模式13. 状态模式14. 策略模式15. 模板方法模式16. 访问者模式\",\"3\"]},{\"header\":\"结构型模式\",\"contents\":[\" 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 \",\"17. 适配器模式18. 组合模式19. 代理模式20. 桥梁模式21. 装饰模式22. 门面模式23. 享元模式\"]},{\"header\":\"设计模式的六大原则\",\"slug\":\"设计模式的六大原则\",\"contents\":[\"开闭原则\",\"开闭原则的意思是： 对扩展开放，对修改关闭 。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，一般需要使用接口和抽象类。\",\"里氏替换原则\",\"里氏替换原则是面向对象设计的基本原则之一。 里氏替换原则中说，任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏替换原则是对实现抽象化的具体步骤的规范。\",\"依赖倒置原则\",\"这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\",\"接口隔离原则\",\"这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。\",\"迪米特法则(最少知道原则)\",\"最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\",\"合成复用原则\",\"合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。\"]},{\"header\":\"一张图看懂设计模式\",\"slug\":\"一张图看懂设计模式\",\"contents\":[\"虚线箭头指向依赖；\",\"实线箭头指向关联；\",\"虚线三角指向接口；\",\"实线三角指向父类；\",\"空心菱形能分离而独立存在，是聚合；\",\"实心菱形精密关联不可分，是组合；\",\"设计模式\"]}]},\"/articles/design-pattern/abstract-factory-pattern.html\":{\"title\":\"抽象工厂模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"抽象工厂模式是一种创建型设计模式，它提供一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们的具体类。抽象工厂模式可以看作是工厂方法模式的扩展，它在工厂方法模式的基础上，通过增加工厂的抽象层次，来实现对一组产品族的创建，而不是单一产品的创建。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"抽象工厂模式是一种创建型设计模式，它可以提供一个接口用于创建一系列相关或相互依赖的对象，而无需指定具体类。这种模式属于对象创建型模式。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"当一个系统需要一系列相互关联或相互依赖的对象时，可以使用抽象工厂模式，这些对象之间存在固定的依赖关系。\",\"当一个系统需要多个产品族中的产品对象，而且这些产品族中的产品对象之间存在一定的约束或逻辑关系时，可以使用抽象工厂模式。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点\",\"可以保证同一工厂生产的所有产品对象都是相互兼容的。这样可以使得客户端代码无需关心具体产品的类名，只需关心产品所属的接口或抽象类。\",\"可以封装创建产品对象的过程，使得客户端代码和具体产品实现分离，从而使系统更易于扩展和维护。\",\"可以更容易地替换产品系列，只需要更改具体工厂即可。\",\"缺点\",\"抽象工厂模式的最大缺点是扩展新的产品族比较困难，因为需要更改抽象工厂接口及其所有的实现类。\",\"在增加新的产品等级结构时，需要更改所有的具体工厂类，这可能会带来较大的代码量。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个使用抽象工厂模式的示例程序，该程序使用抽象工厂模式来创建不同类型的按钮和文本框：\",\"// 抽象产品类：按钮 public abstract class Button { public abstract void Paint(); } // 具体产品类：Windows 按钮 public class WindowsButton : Button { public override void Paint() { Console.WriteLine(\\\"Painting a Windows button.\\\"); } } // 具体产品类：MacOS 按钮 public class MacOSButton : Button { public override void Paint() { Console.WriteLine(\\\"Painting a MacOS button.\\\"); } } // 抽象产品类：文本框 public abstract class TextBox { public abstract void Paint(); } // 具体产品类：Windows 文本框 public class WindowsTextBox : TextBox { public override void Paint() { Console.WriteLine(\\\"Painting a Windows text box.\\\"); } } // 具体产品类：MacOS 文本框 public class MacOSTextBox : TextBox { public override void Paint() { Console.WriteLine(\\\"Painting a MacOS text box.\\\"); } } // 抽象工厂类 public abstract class GUIFactory { public abstract Button CreateButton(); public abstract TextBox CreateTextBox(); } // 具体工厂类：Windows 工厂 public class WindowsFactory : GUIFactory { public override Button CreateButton() { return new WindowsButton(); } public override TextBox CreateTextBox() { return new WindowsTextBox(); } } // 具体工厂类：MacOS 工厂 public class MacOSFactory : GUIFactory { public override Button CreateButton() { return new MacOSButton(); } public override TextBox CreateTextBox() { return new MacOSTextBox(); } } // 客户端代码 public class Client { private GUIFactory factory; public Client(GUIFactory factory) { this.factory = factory; } public void Paint() { Button button = factory.CreateButton(); button.Paint(); TextBox textBox = factory.CreateTextBox(); textBox.Paint(); } } // 示例程序 public class Program { static void Main(string[] args) { // 使用 Windows 工厂创建控件 GUIFactory windowsFactory = new WindowsFactory(); Client windowsClient = new Client(windowsFactory); windowsClient.Paint(); // 使用 MacOS 工厂创建控件 GUIFactory macosFactory = new MacOSFactory(); Client macosClient = new Client(macosFactory); macosClient.Paint(); } } \",\"在上述示例代码中，抽象工厂模式使用了抽象工厂类 GUIFactory 和其具体实现类 WindowsFactory 和 MacOSFactory。每个具体工厂类都可以创建一组相关的产品对象（按钮和文本框），并实现抽象工厂类中定义的抽象方法。客户端代码使用特定的工厂对象创建按钮和文本框，并使用这些控件执行任务。\"]}]},\"/articles/design-pattern/adapter-pattern.html\":{\"title\":\"适配器模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"适配器模式（Adapter Pattern）将一个类的接口转换成客户端希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"适配器模式（Adapter Pattern）将一个类的接口转换成客户端希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。\"]},{\"header\":\"适用场景\",\"slug\":\"适用场景\",\"contents\":[\"将一个已经存在的类的接口转换成另外一个接口，以满足用户的需求。 在不修改原有代码的情况下，增加一些新功能。\",\"当需要使用的类与客户端的接口不一致时，可以通过适配器模式进行转换，使得它们能够协同工作。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"适配器模式可以让两个没有任何关联的类一起运行，提高了类的复用性。\",\"可以增加类的透明性和灵活性，让客户端代码更加简洁明了。\",\"可以减少代码的耦合度，增加了程序的可扩展性。\"]},{\"header\":\"缺点\",\"slug\":\"缺点\",\"contents\":[\"适配器模式增加了代码的复杂度，增加了代码阅读的难度。 在实现适配器模式时，可能需要引入一个新的类，从而增加系统的开销。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个将 220V 电压转换成 5V 电压的适配器模式示例代码，其中，Adaptee 是原有的类，需要进行适配的类；Target 是目标接口，即客户端需要的接口；Adapter 是适配器类，通过实现目标接口，将 Adaptee 的接口适配成 Target 需要的接口。\",\"// 原有的类 public class Adaptee { public int Get220V() { return 220; } } // 目标接口 public interface ITarget { int Get5V(); } // 适配器类 public class Adapter : ITarget { private readonly Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public int Get5V() { int src = adaptee.Get220V(); int dst = src / 44; // 将220V转换为5V return dst; } } // 客户端代码 public class Client { public void Main() { Adaptee adaptee = new Adaptee(); ITarget target = new Adapter(adaptee); int result = target.Get5V(); } } \",\"在这个示例中，Adaptee 是原有的类，它提供了 Get220V 方法，但是客户端需要的是 Get5V 方法。Adapter 是适配器类，它实现了 ITarget 接口，将 Adaptee 的 Get220V 方法适配成了 Get5V 方法，以满足客户端的需求。在客户端代码中，我们创建了一个 Adaptee 对象和一个 Adapter 对象，并通过 Adapter 对象调用 Get5V 方法来获取 5V 电压。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"在这个示例中，适配器模式的实现比较简单，没有太多的优化空间。但是，在实际开发中，我们可以考虑使用对象适配器模式或类适配器模式来实现适配器模式，以满足不同的需求。\",\"对象适配器模式将适配器类作为一个对象组合到客户端中，以实现适配器模式。在对象适配器模式中，适配器类可以实现多个目标接口，从而提高了适配器类的灵活性。\",\"类适配器模式使用多重继承的方式来实现适配器模式，即适配器类继承了原有的类，并同时实现了目标接口。在类适配器模式中，适配器类可以重写原有类的方法，从而增加了适配器类的功能。\",\"// 目标接口 interface ITarget { void Get5V(); } // 源接口 class Adaptee { public void Get220V() { Console.WriteLine(\\\"获取220V电压\\\"); } } // 适配器类 class Adapter : ITarget { private Adaptee adaptee; // 组合一个Adaptee对象 public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void Get5V() { Console.WriteLine(\\\"适配器开始工作，将220V电压适配成5V电压\\\"); adaptee.Get220V(); // 调用Adaptee对象的Get220V方法获取220V电压 Console.WriteLine(\\\"适配完成，输出5V电压\\\"); } } // 客户端代码 class Client { static void Main(string[] args) { Adaptee adaptee = new Adaptee(); ITarget target = new Adapter(adaptee); target.Get5V(); } } \",\"在上面的代码中，我们定义了一个 ITarget 接口，表示客户端所需要的目标接口。然后定义了一个 Adaptee 类，表示客户端需要适配的源接口。接着，定义了一个 Adapter 类，实现了 ITarget 接口，并通过组合一个 Adaptee 对象来实现适配器模式。最后，在客户端代码中，我们创建了一个 Adaptee 对象和一个 Adapter 对象，并通过 Adapter 对象调用 Get5V 方法来获取 5V 电压。\",\"这种方式相比于原始的类适配器模式，更加灵活，因为一个 Adapter 对象可以实现多个目标接口，而且不需要继承原有的类。同时，也比较易于扩展，因为我们可以通过组合不同的对象来实现不同的适配器功能。\"]}]},\"/articles/design-pattern/bridge-pattern.html\":{\"title\":\"桥梁模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\"]}]},\"/articles/design-pattern/builder-pattern.html\":{\"title\":\"建造者模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"建造者模式是一种创建型设计模式，它允许你将一个复杂对象的构建过程与其表示相分离，使得同样的构建过程可以创建不同的表示。建造者模式通常包含一个指挥者（Director）、抽象建造者（Builder）、具体建造者（ConcreteBuilder）和产品（Product）四个角色。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"建造者模式是一种创建型设计模式，它允许你将一个复杂对象的构建过程与其表示相分离，使得同样的构建过程可以创建不同的表示。建造者模式通常包含一个指挥者（Director）、抽象建造者（Builder）、具体建造者（ConcreteBuilder）和产品（Product）四个角色。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"当一个产品有复杂的内部结构，其创建过程比较复杂且需要多个步骤时，可以考虑使用建造者模式。此外，建造者模式还适用于以下场景：\",\"如果需要对不同的表示进行创建，可以使用建造者模式。例如，需要使用不同的材料或风格创建房屋。 如果需要在不知道产品内部构造的情况下直接创建复杂对象，可以使用建造者模式。例如，从数据库中读取数据并构建对象。 如果需要更好地控制产品创建流程，可以使用建造者模式。例如，需要按照特定的顺序构建对象。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点\",\"可以隔离复杂对象的创建和使用，使得相同的创建过程可以创建不同的产品表示。\",\"可以更加精细地控制产品的创建过程，使得创建过程能够适应不同的需求。\",\"可以更加方便地增加或修改产品的部件，使得系统更加灵活。\",\"缺点\",\"建造者模式需要定义多个类，增加了代码量。\",\"建造者模式的使用范围受限，仅适用于相对复杂的产品创建过程。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"以下是建造者模式的 C# 代码示例。我们将创建一个包含多个部件的电脑，其中部件包括 CPU、主板、内存和硬盘等。具体建造者将实现创建不同种类的电脑。产品是由不同的部件组成的电脑。指挥者负责控制创建电脑的流程，具体建造者负责创建电脑的各个部件。\",\"// 产品类，包含多个部件 public class Computer { private List<string> parts = new List<string>(); public void AddPart(string part) { parts.Add(part); } public string GetParts() { return string.Join(\\\", \\\", parts); } } // 抽象建造者，定义创建各个部件的抽象方法 public abstract class ComputerBuilder { protected Computer computer = new Computer(); public abstract void BuildCpu(); public abstract void BuildMotherboard(); public abstract void BuildMemory(); public abstract void BuildHardDrive(); public Computer GetComputer() { return computer; } } // 具体建造者，实现创建各个部件的方法 public class DesktopBuilder : ComputerBuilder { public override void BuildCpu() { computer.AddPart(\\\"Desktop CPU\\\"); } public override void BuildMotherboard() { computer.AddPart(\\\"Desktop Motherboard\\\"); } public override void BuildMemory() { computer.AddPart(\\\"Desktop Memory\\\"); } public override void BuildHardDrive() { computer.AddPart(\\\"Desktop Hard Drive\\\"); } } public class LaptopBuilder : ComputerBuilder { public override void BuildCpu() { computer.AddPart(\\\"Laptop CPU\\\"); } public override void BuildMotherboard() { computer.AddPart(\\\"Laptop Motherboard\\\"); } public override void BuildMemory() { computer.AddPart(\\\"Laptop Memory\\\"); } public override void BuildHardDrive() { computer.AddPart(\\\"Laptop Hard Drive\\\"); } } // 指挥者，控制创建电脑的流程 public class ComputerDirector { private ComputerBuilder computerBuilder; public ComputerDirector(ComputerBuilder computerBuilder) { this.computerBuilder = computerBuilder; } public void ConstructComputer() { computerBuilder.BuildCpu(); computerBuilder.BuildMotherboard(); computerBuilder.BuildMemory(); computerBuilder.BuildHardDrive(); } } \",\"下面是使用建造者模式创建电脑的代码示例：\",\"// 创建一个具体的建造者，例如 DesktopBuilder 或 LaptopBuilder ComputerBuilder computerBuilder = new DesktopBuilder(); // 创建指挥者并将具体的建造者传递给它 ComputerDirector computerDirector = new ComputerDirector(computerBuilder); // 控制创建电脑的流程 computerDirector.ConstructComputer(); // 从具体的建造者中获取创建的电脑产品 Computer computer = computerBuilder.GetComputer(); // 输出电脑的各个部件 Console.WriteLine(\\\"Computer parts: \\\" + computer.GetParts()); \",\"上述代码输出的结果为：\",\"Computer parts: Desktop CPU, Desktop Motherboard, Desktop Memory, Desktop Hard Drive \",\"可以使用链式调用（Fluent Interface）的方式优化上述代码，让代码更加简洁易读。\",\"具体实现方法是，在每个 Builder 类的方法中返回 this，这样就可以进行链式调用了。下面是使用链式调用优化后的代码示例：\",\"// 产品类 class Computer { public string Cpu { get; set; } public string Motherboard { get; set; } public string Memory { get; set; } public string HardDisk { get; set; } } // 抽象建造者类 abstract class ComputerBuilder { protected Computer computer = new Computer(); public abstract ComputerBuilder BuildCpu(string cpu); public abstract ComputerBuilder BuildMotherboard(string motherboard); public abstract ComputerBuilder BuildMemory(string memory); public abstract ComputerBuilder BuildHardDisk(string hardDisk); public Computer GetComputer() { return computer; } } // 具体建造者类1 class ConcreteBuilder1 : ComputerBuilder { public override ComputerBuilder BuildCpu(string cpu) { computer.Cpu = cpu; return this; } public override ComputerBuilder BuildMotherboard(string motherboard) { computer.Motherboard = motherboard; return this; } public override ComputerBuilder BuildMemory(string memory) { computer.Memory = memory; return this; } public override ComputerBuilder BuildHardDisk(string hardDisk) { computer.HardDisk = hardDisk; return this; } } // 具体建造者类2 class ConcreteBuilder2 : ComputerBuilder { public override ComputerBuilder BuildCpu(string cpu) { computer.Cpu = cpu; return this; } public override ComputerBuilder BuildMotherboard(string motherboard) { computer.Motherboard = motherboard; return this; } public override ComputerBuilder BuildMemory(string memory) { computer.Memory = memory; return this; } public override ComputerBuilder BuildHardDisk(string hardDisk) { computer.HardDisk = hardDisk; return this; } } // 指挥者类 class Director { public void Construct(ComputerBuilder builder, string cpu, string motherboard, string memory, string hardDisk) { builder.BuildCpu(cpu) .BuildMotherboard(motherboard) .BuildMemory(memory) .BuildHardDisk(hardDisk); } } \",\"上述代码中，每个具体建造者的方法都返回 this，这样就可以在使用时进行链式调用，可以看到，代码更加简洁易读，同时也可以避免漏掉某个步骤，提高了代码的健壮性。\"]}]},\"/articles/design-pattern/chain-of-responsibility-pattern.html\":{\"title\":\"责任链模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它将请求的发送者和接收者解耦，并且允许多个对象对请求进行处理，这些对象构成一条链，每个对象都可以选择将请求处理或者传递给下一个对象。这种方式可以避免请求发送者与接收者之间的耦合，从而使多个对象可以处理同一个请求。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它将请求的发送者和接收者解耦，并且允许多个对象对请求进行处理，这些对象构成一条链，每个对象都可以选择将请求处理或者传递给下一个对象。这种方式可以避免请求发送者与接收者之间的耦合，从而使多个对象可以处理同一个请求。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"当需要多个对象处理同一个请求时，可以使用责任链模式，避免请求的发送者和接收者之间的耦合。\",\"当需要动态地指定处理一个请求的对象集合时，可以使用责任链模式。\",\"当需要在不明确接收者的情况下，动态地向多个对象中的一个提交请求时，可以使用责任链模式。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点\",\"将请求的发送者和接收者解耦，可以避免请求发送者和接收者之间的耦合，从而使多个对象可以处理同一个请求。\",\"可以动态地指定处理一个请求的对象集合。\",\"可以在不明确接收者的情况下，动态地向多个对象中的一个提交请求。\",\"缺点\",\"可能会存在请求没有被处理的情况，如果没有正确地组织责任链，请求可能会被漏掉。\",\"由于责任链的构建需要遍历整个链，因此处理请求的速度可能会比较慢。\"]},{\"header\":\"示例代码\",\"slug\":\"示例代码\",\"contents\":[\"下面是一个简单的示例，演示了如何使用责任链模式来处理一系列请求。假设有一个文件处理器，它可以处理多种类型的文件，包括文本文件、音频文件和视频文件。我们可以使用责任链模式，将这些处理器链接在一起，当一个请求到来时，它会被传递给第一个处理器，如果第一个处理器无法处理该请求，那么请求会被传递给下一个处理器，以此类推，直到请求被处理为止。\",\"using System; // 定义请求类 class Request { public string Type { get; set; } public Request(string type) { Type = type; } } // 定义处理器接口 interface Handler { void HandleRequest(Request request); } // 定义具体处理器类 class TextFileHandler : Handler { private Handler nextHandler; public void SetNextHandler(Handler handler) { nextHandler = handler; } public void HandleRequest(Request request) { if (request.Type == \\\"text\\\") { Console.WriteLine(\\\"处理文本文件\\\"); } else if (nextHandler != null) { nextHandler.HandleRequest(request); } else { Console.WriteLine(\\\"无法处理该文件类型\\\"); } } } class AudioFileHandler : Handler { private Handler nextHandler; public void SetNextHandler(Handler handler) { nextHandler = handler; } public void HandleRequest(Request request) { if (request.Type == \\\"audio\\\") { Console.WriteLine(\\\"处理音频文件\\\"); } else if (nextHandler != null) { nextHandler.HandleRequest(request); } else { Console.WriteLine(\\\"无法处理该文件类型\\\"); } } } class VideoFileHandler : Handler { private Handler nextHandler; public void SetNextHandler(Handler handler) { nextHandler = handler; } public void HandleRequest(Request request) { if (request.Type == \\\"video\\\") { Console.WriteLine(\\\"处理视频文件\\\"); } else if (nextHandler != null) { nextHandler.HandleRequest(request); } else { Console.WriteLine(\\\"无法处理该文件类型\\\"); } } } // 定义客户端类 class Client { public static void Main() { // 创建处理器对象 TextFileHandler textHandler = new TextFileHandler(); AudioFileHandler audioHandler = new AudioFileHandler(); VideoFileHandler videoHandler = new VideoFileHandler(); // 设置处理器链 textHandler.SetNextHandler(audioHandler); audioHandler.SetNextHandler(videoHandler); // 处理请求 Request request1 = new Request(\\\"text\\\"); textHandler.HandleRequest(request1); Request request2 = new Request(\\\"audio\\\"); textHandler.HandleRequest(request2); Request request3 = new Request(\\\"video\\\"); textHandler.HandleRequest(request3); Request request4 = new Request(\\\"image\\\"); textHandler.HandleRequest(request4); } } \",\"在上面的示例中，我们定义了一个 Request 类，它表示一个请求，具有一个 Type 属性，表示请求的类型。我们还定义了一个 Handler 接口，它表示处理器，具有一个 HandleRequest 方法，用于处理请求。我们还定义了三个具体的处理器类，分别是 TextFileHandler、 AudioFileHandler 和 VideoFileHandler，它们实现了 Handler 接口，并且具有一个 SetNextHandler 方法，用于设置下一个处理器。在 HandleRequest 方法中，如果当前处理器能够处理请求，那么它会处理请求，否则它会将请求传递给下一个处理器。最后，我们定义了一个 Client 类，用于演示如何使用责任链模式来处理请求。在 Main 方法中，我们首先创建了三个处理器对象，然后设置它们之间的关系，最后创建了四个请求，并将它们依次提交给处理器链来处理。\",\"需要注意的是，上面的代码是一个简单的示例，实际上在使用责任链模式时，需要根据具体的场景来选择合适的处理器对象和处理器链。另外，如果处理器链过长，可能会导致处理请求的速度变慢，因此需要合理地设计处理器链，以提高处理请求的效率。\"]}]},\"/articles/design-pattern/command-pattern.html\":{\"title\":\"命令模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"命令模式(Command Pattern)是一种行为型设计模式，它允许将操作请求封装为一个对象，从而使你可以将请求的各个参数（命令）进行排队、记录日志、撤销等操作。通过将请求封装成对象，可以使用不同的请求来参数化其他对象。同时，可以将请求存储在队列中，实现任务的异步执行、延迟执行、撤销等功能。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"命令模式(Command Pattern)是一种行为型设计模式，它允许将操作请求封装为一个对象，从而使你可以将请求的各个参数（命令）进行排队、记录日志、撤销等操作。通过将请求封装成对象，可以使用不同的请求来参数化其他对象。同时，可以将请求存储在队列中，实现任务的异步执行、延迟执行、撤销等功能。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"需要将操作请求发送给不同的接收器，且不知道接收器具体是谁。\",\"需要实现撤销、恢复等功能。\",\"需要将一组操作组合成一个复合操作，即宏命令。\",\"需要将请求放入队列中，并进行异步处理或延迟处理。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点：\",\"降低系统的耦合度。发送请求的对象与接收请求的对象之间没有直接的联系，使得系统中的相互依赖关系变得松散。\",\"容易扩展新的命令。增加新的具体命令类很容易，无需修改原有代码，符合“开闭原则”。\",\"可以实现宏命令，将一组命令装配成一个组合命令。\",\"缺点：\",\"如果有过多的具体命令类，将导致系统变得复杂。\",\"命令模式的实现可能需要使用大量的代码来支持各种请求类型。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"以下是一个简单的用 C# 实现的命令模式案例。假设我们有一个文本编辑器，用户可以在文本编辑器中执行撤销、重做、剪切、复制、粘贴等操作。我们将每个操作抽象为一个接口 ICommand，并实现具体的命令类 CutCommand、CopyCommand、PasteCommand、UndoCommand、RedoCommand。在这个例子中，我们使用队列来存储命令对象，并按照先进先出的顺序执行它们。我们还可以使用栈来实现撤销、重做等功能。\",\"// 命令接口 public interface ICommand { void Execute(); } // 剪切命令 public class CutCommand : ICommand { private readonly Editor editor; public CutCommand(Editor editor) { this.editor = editor; } public void Execute() { editor.Cut(); } } // 复制命令 public class CopyCommand : ICommand { private readonly Editor editor; public CopyCommand(Editor editor) { this.editor = editor; } public void Execute() { editor.Copy(); } } // 粘贴命令 public class PasteCommand : ICommand { private readonly Editor editor; public PasteCommand(Editor editor) { this.editor = editor; } public void Execute() { editor.Paste(); } } // 撤销命令 public class UndoCommand : ICommand { private readonly Editor editor; public UndoCommand(Editor editor) { this.editor = editor; } public void Execute() { editor.Undo(); } } // 重做命令 public class RedoCommand : ICommand { private readonly Editor editor; public RedoCommand(Editor editor) { this.editor = editor; } public void Execute() { editor.Redo(); } } // 文本编辑器 public class Editor { private readonly Stack<string> undoStack = new Stack<string>(); private readonly Stack<string> redoStack = new Stack<string>(); private string clipboard = string.Empty; private string text = string.Empty; // 剪切 public void Cut() { if (string.IsNullOrEmpty(text)) return; clipboard = text; text = string.Empty; undoStack.Push(clipboard); } // 复制 public void Copy() { if (string.IsNullOrEmpty(text)) return; clipboard = text; } // 粘贴 public void Paste() { text += clipboard; undoStack.Push(clipboard); } // 撤销 public void Undo() { if (undoStack.Count == 0) return; redoStack.Push(text); text = undoStack.Pop(); } // 重做 public void Redo() { if (redoStack.Count == 0) return; undoStack.Push(text); text = redoStack.Pop(); } // 显示文本 public void DisplayText() { Console.WriteLine(\\\"Text: \\\" + text); } } // 命令队列 public class CommandQueue { private readonly Queue<ICommand> queue = new Queue<ICommand>(); // 添加命令 public void AddCommand(ICommand command) { queue.Enqueue(command); } // 执行命令队列 public void ExecuteCommands() { while (queue.Count > 0) { ICommand command = queue.Dequeue(); command.Execute(); } } } // 客户端代码 public class Client { public static void Main() { Editor editor = new Editor(); CommandQueue commandQueue = new CommandQueue(); commandQueue.AddCommand(new CutCommand(editor)); commandQueue.AddCommand(new PasteCommand(editor)); commandQueue.AddCommand(new UndoCommand commandQueue.AddCommand(new RedoCommand(editor)); commandQueue.AddCommand(new CopyCommand(editor)); commandQueue.ExecuteCommands(); editor.DisplayText(); } } \",\"在这个案例中，我们使用了 ICommand 接口来表示每个操作，每个具体的命令类都实现了该接口，并通过构造函数注入了一个 Editor 对象，以便在执行时对文本进行操作。\",\"Editor 类实现了剪切、复制、粘贴、撤销和重做操作，它使用两个栈来实现撤销和重做功能，并将文本和剪贴板的状态存储在类的私有字段中。在执行每个操作时，Editor 将其状态记录到 undoStack 中，以便后续撤销操作时可以还原状态。\",\"CommandQueue 类表示命令队列，它通过一个队列来存储 ICommand 对象，并提供了 AddCommand 和 ExecuteCommands 方法来添加和执行命令。在客户端代码中，我们创建了一个 Editor 和一个 CommandQueue，向命令队列中添加了一些操作，并最终执行命令队列，以便依次执行每个操作。\",\"这个案例中使用了队列来存储命令对象，并按照先进先出的顺序执行它们。如果需要实现撤销、重做等功能，可以使用栈来存储命令对象，并按照后进先出的顺序执行它们。此外，还可以使用备忘录模式来记录文本编辑器的状态，并在撤销、重做等操作中使用。\"]}]},\"/articles/design-pattern/composite-pattern.html\":{\"title\":\"组合模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\"]}]},\"/articles/design-pattern/decorator-pattern.html\":{\"title\":\"装饰模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\"]}]},\"/articles/design-pattern/facade-pattern.html\":{\"title\":\"门面模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\"]}]},\"/articles/design-pattern/factory-pattern.html\":{\"title\":\"工厂模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"工厂模式是一种创建型设计模式，它提供了一种封装对象实例化的方式，让子类来决定实例化哪个类，以及如何创建这个类的实例。工厂模式通过将对象的创建和使用分离，可以减少代码中的重复，提高代码的可扩展性和可维护性。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"工厂模式是一种创建型设计模式，它提供了一种封装对象实例化的方式，让子类来决定实例化哪个类，以及如何创建这个类的实例。工厂模式通过将对象的创建和使用分离，可以减少代码中的重复，提高代码的可扩展性和可维护性。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"在以下情况下可以考虑使用工厂模式：\",\"当需要根据某些条件来决定创建哪个对象时，例如读取配置文件中的数据或者根据用户输入的选项来决定创建哪个对象。\",\"当需要隐藏对象创建的复杂度时，例如创建一个对象需要多个步骤或者需要进行多项检查。\",\"当需要将对象的创建和使用分离时，例如使用依赖注入来创建对象。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"包括\",\"可以隐藏对象创建的复杂度，让客户端代码只需要关心使用对象，而不需要关心如何创建对象。\",\"可以提高代码的可扩展性和可维护性，当需要添加新的对象时，只需要添加相应的工厂类和产品类即可，不需要修改客户端代码。\",\"可以将对象的创建和使用分离，让客户端代码更加松耦合。\",\"缺点 -当工厂类的数量较多时，会增加代码的复杂度，不利于维护和测试。 -当需要创建的对象数量很少时，使用工厂模式可能会导致代码冗余。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"以下是一个简单的工厂模式的代码示例，用于创建不同类型的汽车：\",\"// 抽象产品类 abstract class Car { public abstract void Drive(); } // 具体产品类 class Audi : Car { public override void Drive() { Console.WriteLine(\\\"Driving Audi\\\"); } } // 具体产品类 class BMW : Car { public override void Drive() { Console.WriteLine(\\\"Driving BMW\\\"); } } // 工厂类 class CarFactory { public Car CreateCar(string type) { switch (type) { case \\\"Audi\\\": return new Audi(); case \\\"BMW\\\": return new BMW(); default: throw new ArgumentException($\\\"Unknown car type: {type}\\\"); } } } // 客户端代码 class Program { static void Main(string[] args) { CarFactory factory = new CarFactory(); Car car1 = factory.CreateCar(\\\"Audi\\\"); car1.Drive(); Car car2 = factory.CreateCar(\\\"BMW\\\"); car2.Drive(); } } \",\"在上面的代码示例中，Car 是抽象产品类，Audi 和 BMW 是具体产品类。CarFactory 是工厂类，它根据指定的类型来创建不同类型的汽车。在 Main() 方法中，我们创建了一个 CarFactory 对象，并使用它来创建了两个不同类型的汽车，并调用了它们的Drive() 方法。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"在上面的示例中，每次创建汽车对象时，都需要通过 switch 语句来判断要创建的汽车类型。如果有很多汽车类型，那么这个 switch 语句会变得非常庞大。为了避免这种情况，我们可以使用反射来创建对象，这样就可以避免使用 switch 语句。以下是一个使用反射的代码示例：\",\"// 工厂类 class CarFactory { public Car CreateCar(string type) { Type carType = Type.GetType($\\\"FactoryPattern.{type}\\\"); if (carType == null) { throw new ArgumentException($\\\"Unknown car type: {type}\\\"); } return (Car)Activator.CreateInstance(carType); } } \",\"在上面的示例中，我们使用了 Type.GetType() 方法来获取类型，并使用 Activator.CreateInstance() 方法来创建对象。这样就可以避免使用 switch 语句，并且可以动态地创建对象。但是，这种方法也有缺点，即创建对象的性能可能会比较低。因此，在实际应用中需要权衡利弊，选择最合适的方法。\"]}]},\"/articles/design-pattern/flyweight-pattern.html\":{\"title\":\"享元模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\"]}]},\"/articles/design-pattern/interpreter-pattern.html\":{\"title\":\"解释器模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"解释器模式是一种行为型设计模式，它定义了一种语言文法的表示，并定义一个解释器，用来解释该语言中的句子。通俗点说，就是将某种特定的语言翻译成机器能够理解的形式。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"解释器模式是一种行为型设计模式，它定义了一种语言文法的表示，并定义一个解释器，用来解释该语言中的句子。通俗点说，就是将某种特定的语言翻译成机器能够理解的形式。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"解释器模式适用于以下场景：\",\"当你有一种语言需要解释执行时，可以使用解释器模式。\",\"当你需要定义一种语言，并需要解释执行该语言时，可以使用解释器模式。\",\"当你需要在运行时动态地扩展语言时，可以使用解释器模式。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点：\",\"可扩展性强，易于添加新的语法规则和操作符。\",\"可以将语法规则表示为类的继承关系，更加易于理解和维护。\",\"可以将复杂的语法规则分解成简单的模块，易于实现。\",\"缺点：\",\"对于简单的语法规则，使用解释器模式可能会显得过于繁琐。\",\"在语法规则非常复杂的情况下，解释器模式的性能可能会受到影响。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个使用解释器模式实现的简单案例，我们将解释一个包含加减乘除的表达式，例如 \\\"1 + 2 - 3 * 4 / 2\\\"。我们将通过解释器模式来计算该表达式的值。\",\"首先，我们定义一个抽象表达式类 Expression，该类包含一个抽象方法 Interpret，用于计算表达式的值。\",\"// 抽象表达式类 abstract class Expression { public abstract int Interpret(); } \",\"然后，我们定义数字表达式类 NumberExpression，该类表示一个数字表达式。\",\"// 数字表达式类 class NumberExpression : Expression { private int value; public NumberExpression(int value) { this.value = value; } public override int Interpret() { return value; } } \",\"接下来，我们定义运算符表达式类 OperatorExpression，该类表示一个运算符表达式。该类包含左操作数和右操作数两个表达式对象。\",\"// 运算符表达式类 class OperatorExpression : Expression { private char op; private Expression left; private Expression right; public OperatorExpression(char op, Expression left, Expression right) { this.op = op; this.left = left; this.right = right; } public override int Interpret() { int leftValue = left.Interpret(); int rightValue = right.Interpret(); switch (op) { case '+': return leftValue + rightValue; case '-': return leftValue - rightValue; case '*': return leftValue * rightValue; case '/': return leftValue / rightValue; default: throw new NotSupportedException(); } } } \",\"最后，我们定义一个解释器类 Interpreter，该类包含一个 Parse 方法，用于解析一个字符串形式的表达式，并返回表达式的计算结果。\",\"// 解释器类 class Interpreter { public Expression Parse(string input) { // 将输入字符串转换为一个字符数组 char[] tokens = input.ToCharArray(); // 定义栈和队列，用于解析表达式 Stack<Expression> expressions = new Stack<Expression>(); Queue<char> operators = new Queue<char>(); // 遍历字符数组，解析表达式 foreach (char token in tokens) { if (Char.IsDigit(token)) { // 如果当前字符是数字，则将其转换为数字表达式，并压入栈中 int value = Int32.Parse(token.ToString()); expressions.Push(new NumberExpression(value)); } else if (token == '+' || token == '-' || token == '*' || token == '/') { // 如果当前字符是运算符，则将其压入运算符队列中 operators.Enqueue(token); } else if (token == '(') { // 如果当前字符是左括号，则将其压入栈中 expressions.Push(new NumberExpression(0)); operators.Enqueue(token); } else if (token == ')') { // 如果当前字符是右括号，则弹出栈中的表达式，直到遇到左括号，然后将左括号从运算符队列中弹出 while (operators.Peek() != '(') { char op = operators.Dequeue(); Expression right = expressions.Pop(); Expression left = expressions.Pop(); expressions.Push(new OperatorExpression(op, left, right)); } operators.Dequeue(); } } // 处理剩余的运算符 while (operators.Count > 0) { char op = operators.Dequeue(); Expression right = expressions.Pop(); Expression left = expressions.Pop(); expressions.Push(new OperatorExpression(op, left, right)); } // 返回栈中唯一的表达式对象 return expressions.Pop(); } } \",\"现在，我们可以使用上面的解释器来计算一个表达式的值。例如，我们可以计算 \\\"1 + 2 - 3 * 4 / 2\\\" 的值：\",\"Interpreter interpreter = new Interpreter(); Expression expression = interpreter.Parse(\\\"1 + 2 - 3 * 4 / 2\\\"); int result = expression.Interpret(); Console.WriteLine(result); \",\"该代码将输出\\\"-3\\\"，即表达式 \\\"1 + 2 - 3 * 4 / 2\\\" 的计算结果。\",\"对于上面的代码，可能存在以下的优化空间：\",\"可以引入一些常见的优化技巧，例如缓存、惰性求值等，来提高解释器的性能；\",\"可以使用更加高效的数据结构，例如链表、哈希表等，来加速解释器的解析过程。\",\"但是，这些优化的具体实现方式需要根据实际的场景和要求来确定，不能一概而论。在实际开发中，我们需要根据具体情况来进行优化，以提高解释器的性能和可维护性。\"]}]},\"/articles/design-pattern/iterator-pattern.html\":{\"title\":\"迭代器模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"迭代器模式（Iterator Pattern）是一种行为型设计模式，它允许你顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"迭代器模式（Iterator Pattern）是一种行为型设计模式，它允许你顺序访问一个聚合对象中的各个元素，而不暴露该对象的内部表示。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"迭代器模式通常用于以下情况：\",\"需要遍历一个聚合对象，但是又不想暴露该对象的内部结构。\",\"需要在遍历时提供多种不同的方式，比如前向遍历、后向遍历等。\",\"需要提供一个统一的接口来遍历不同类型的聚合对象。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点：\",\"提供了一种访问聚合对象的方法，且不暴露内部结构。\",\"支持多种遍历方式。\",\"迭代器可以独立于聚合对象进行变化。\",\"缺点：\",\"对于简单的聚合对象，使用迭代器模式可能会增加代码的复杂度。\",\"如果使用不当，可能会导致性能下降。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个简单的C#代码示例，它演示了如何使用迭代器模式来遍历一个聚合对象中的元素。\",\"using System; using System.Collections; // 列表类 // 我们首先定义了一个列表类 MyList，它包含一个数组 items 和一个计数器 count。 public class MyList<T> : IEnumerable { private T[] items; private int count; public MyList(int capacity) { items = new T[capacity]; } public void Add(T item) { items[count++] = item; } // 我们实现了 IEnumerable 接口中的 GetEnumerator 方法，该方法返回一个 MyListEnumerator 对象。MyListEnumerator 类表示列表的迭代器，它实现了 IEnumerator 接口。 public IEnumerator GetEnumerator() { return new MyListEnumerator<T>(items, count); } } // 列表迭代器类 // MyListEnumerator 类包含一个指向数组中当前元素的指针 position，以及一个数组 items 和一个计数器 count。 public class MyListEnumerator<T> : IEnumerator { private T[] items; private int count; private int position = -1; public MyListEnumerator(T[] items, int count) { this.items = items; this.count = count; } // MyListEnumerator 类实现了 IEnumerator 接口中的 MoveNext 方法、Reset 方法和 Current 属性。在 MoveNext 方法中，我们将指针 position 向前移动，并返回 true，直到遍历完所有元素。在 Current 属性中，我们返回指针位置对应的元素。 public bool MoveNext() { position++; return (position < count); } public void Reset() { position = -1; } public object Current { get { if (position == -1 || position == count) throw new InvalidOperationException(); return items[position]; } } } // 测试 // 最后，在 Main 方法中，我们创建了一个 MyList 对象，向其中添加了几个元素，然后使用 foreach 循环遍历了该列表。 class Program { static void Main(string[] args) { MyList<int> list = new MyList<int>(3); list.Add(1); list.Add(2); list.Add(3); // 使用 foreach 遍历 // 在 foreach 循环中，编译器会自动调用 MyList 对象的 GetEnumerator 方法，然后使用 MyListEnumerator 对象来遍历该列表。每次循环迭代，编译器会调用 MyListEnumerator 对象的 MoveNext 方法和 Current 属性，然后输出当前元素的值。 foreach (int item in list) { Console.WriteLine(item); } } } \"]}]},\"/articles/design-pattern/mediator-pattern.html\":{\"title\":\"中介者模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"中介者模式是一种行为型设计模式，它允许你减少对象之间混乱无序的依赖关系。该模式会引入一个中介者对象，它会协调多个对象之间的通信，从而让它们间接地相互作用，而非直接交互。这样可以减少对象间的耦合性，使代码更易于维护。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"中介者模式是一种行为型设计模式，它允许你减少对象之间混乱无序的依赖关系。该模式会引入一个中介者对象，它会协调多个对象之间的通信，从而让它们间接地相互作用，而非直接交互。这样可以减少对象间的耦合性，使代码更易于维护。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"中介者模式适用于当多个对象之间存在相互关联和相互依赖的情况，并且这些关系会导致代码难以维护或扩展的情况。常见的应用场景包括：\",\"对象间存在复杂的关联关系，导致它们之间的交互变得混乱无序。\",\"对象之间的依赖关系太过紧密，导致它们难以单独地进行测试或修改。\",\"当一个对象需要通知多个其他对象时，采用中介者模式可以简化代码逻辑，使通信更加清晰明了。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"中介者模式的优点包括：\",\"减少对象之间的依赖关系，使得代码更加灵活、易于扩展。\",\"通过引入中介者对象，可以减少对象之间的交互次数，提高代码的性能。\",\"可以将对象之间的通信逻辑抽象出来，使得代码更加清晰易懂。\",\"中介者模式的缺点包括：\",\"引入中介者对象会增加代码的复杂度。\",\"中介者对象会成为系统的瓶颈，如果中介者对象处理不当，会影响整个系统的性能。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"假设有一个对话框(Dialog)，其中包含了多个控件，如文本框(TextBox)、按钮(Button)等。这些控件之间存在复杂的依赖关系，例如当按钮被点击时，需要更新文本框的内容。这时候可以使用中介者模式来协调它们之间的交互。\",\"首先我们定义一个中介者接口(IMediator)：\",\"public interface IMediator { void Notify(object sender, string ev); } \",\"该接口定义了一个通知方法 Notify，用于接收各个控件发来的消息。\",\"接下来定义一个抽象控件类(Control)，并实现中介者接口,用于处理控件之间的消息通知：\",\"public abstract class Control : IMediator { protected Dialog _dialog; public Control(Dialog dialog) { _dialog = dialog; } public virtual void Notify(object sender, string ev) { Console.WriteLine($\\\"[Control] {sender.GetType().Name} triggered {ev}\\\"); } } \",\"我们在控件类中实现中介者接口，定义了一个 Notify 方法，用于输出控件触发的事件。\",\"接下来定义具体的控件类，如文本框(TextBox)、按钮(Button)：\",\"public class TextBox : Control { public string Text { get; set; } public TextBox(Dialog dialog) : base(dialog) { } public void UpdateText(string text) { Text = text; _dialog.Notify(this, \\\"TextUpdated\\\"); } public override void Notify(object sender, string ev) { if (ev == \\\"ButtonClick\\\") { Console.WriteLine($\\\"[TextBox] {GetType().Name} received {ev} from {sender.GetType().Name}\\\"); UpdateText(\\\"Text updated by button click\\\"); } } } public class Button : Control { public Button(Dialog dialog) : base(dialog) { } public void Click() { Console.WriteLine($\\\"[Button] {GetType().Name} clicked\\\"); _dialog.Notify(this, \\\"ButtonClick\\\"); } } \",\"我们在具体的控件类中实现了它们的特有方法，如文本框的 UpdateText 和按钮的 Click，用于模拟控件之间的交互。\",\"最后定义一个对话框(Dialog)，用于扮演中介者的角色：\",\"public class Dialog : IMediator { private TextBox _textBox; private Button _button; public Dialog() { _textBox = new TextBox(this); _button = new Button(this); } public void SimulateUserInteraction() { _button.Click(); } public void Notify(object sender, string ev) { if (ev == \\\"TextUpdated\\\") { Console.WriteLine($\\\"[Dialog] Text updated: {_textBox.Text}\\\"); } } } \",\"在对话框中，我们创建了一个文本框和一个按钮，并在 SimulateUserInteraction 方法中模拟按钮被点击的操作。\",\"最后，在 Main 函数中运行我们的示例程序：\",\"static void Main(string[] args) { var dialog = new Dialog(); dialog.SimulateUserInteraction(); } \",\"输出结果如下：\",\"[Button] Button clicked [Control] TextBox triggered ButtonClick [TextBox] TextBox received ButtonClick from Button [Control] Dialog triggered TextUpdated [Dialog] Text updated: Text updated by button click \",\"需要注意的是，这只是一个简单的示例，实际应用中可能会更加复杂，需要根据具体的业务场景进行设计。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"代码中还存在优化空间，例如可以将通知方法中的控件类型转换代码进行抽象，从而让代码更加灵活。修改后的代码如下：\",\"public abstract class Control { protected IMediator _dialog; public Control(IMediator dialog) { _dialog = dialog; } public abstract void Notify(string ev); } public class TextBox : Control { public string Text { get; set; } public TextBox(IMediator dialog) : base(dialog) { } public void UpdateText(string text) { Text = text; Notify(\\\"TextUpdated\\\"); } public override void Notify(string ev) { Console.WriteLine($\\\"[TextBox] {GetType().Name} received {ev}\\\"); if (ev == \\\"ButtonClick\\\") { UpdateText(\\\"Text updated by button click\\\"); } } } public class Button : Control { public Button(IMediator dialog) : base(dialog) { } public void Click() { Console.WriteLine($\\\"[Button] {GetType().Name} clicked\\\"); Notify(\\\"ButtonClick\\\"); } public override void Notify(string ev) { Console.WriteLine($\\\"[Button] {GetType().Name} received {ev}\\\"); } } public interface IMediator { void Notify(object sender, string ev); } public class Dialog : IMediator { private TextBox _textBox; private Button _button; public Dialog() { _textBox = new TextBox(this); _button = new Button(this); } public void SimulateUserInteraction() { _button.Click(); } public void Notify(object sender, string ev) { if (ev == \\\"TextUpdated\\\") { Console.WriteLine($\\\"[Dialog] Text updated: {_textBox.Text}\\\"); } } } \",\"在 Control 抽象类中，我们将 IMediator 类型的 _dialog 字段声明为 protected，同时将 Notify 方法中的 sender 参数删除，因为这里我们已经不需要知道触发通知的控件类型了。在具体的控件类中，我们将 Notify 方法中的 sender 参数删除，改为输出控件自身的信息。这样，我们就可以将 Notify 方法的具体实现从控件类型中抽象出来，从而使得代码更加灵活。\",\"在 Button 控件中，我们删除了 Notify 方法的具体实现，因为按钮并不需要做出响应，只需要通知中介者即可。\",\"最后，在 Main 函数中运行我们的示例程序：\",\"static void Main(string[] args) { var dialog = new Dialog(); dialog.SimulateUserInteraction(); } \",\"输出结果与之前相同：\",\"[Button] Button clicked [TextBox] TextBox received ButtonClick [Dialog] Text updated: Text updated by button click \",\"通过以上示例，我们可以看出，中介者模式可以在多个对象之间解耦，并将它们之间的交互进行集中管理，从而提高了代码的可维护性和可扩展性。当应用场景中存在多个相互耦合的对象时，可以考虑使用中介者模式来减少对象之间的耦合，使得系统更加灵活和易于扩展。\"]}]},\"/articles/design-pattern/memento-pattern.html\":{\"title\":\"备忘录模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"备忘录模式是一种行为型设计模式，它允许在不破坏封装性的前提下捕获对象的内部状态并在对象之外保存这个状态。这样，以后就可以将该对象恢复到先前的状态。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"备忘录模式是一种行为型设计模式，它允许在不破坏封装性的前提下捕获对象的内部状态并在对象之外保存这个状态。这样，以后就可以将该对象恢复到先前的状态。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"备忘录模式通常在以下情况下使用：\",\"当需要保存和恢复对象状态的历史记录时。\",\"当直接访问对象的成员变量、获取器或设置器会暴露对象的实现细节时。\",\"当需要通过某些机制来禁止客户端直接访问对象状态，以保持封装性时。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"备忘录模式的优点包括：\",\"可以在不破坏对象封装的前提下保存和恢复对象状态。\",\"可以实现撤销和重做操作，使用户可以在操作中进行任意次数的撤销和重做。\",\"备忘录模式的缺点包括：\",\"可能会占用大量内存，特别是在需要保存大量历史状态时。\",\"可能会影响对象的性能，特别是在需要频繁保存和恢复状态时。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个使用备忘录模式的示例，假设我们有一个文本编辑器，我们想要保存文本编辑器的状态以便以后可以恢复它。在这个示例中，我们创建了一个 Memento 类来保存文本编辑器的状态，以及一个 Caretaker 类来保存 Memento 对象的历史记录。\",\"using System; // Memento类保存文本编辑器的状态 class Memento { public string Text { get; private set; } public Memento(string text) { Text = text; } } // Originator类表示文本编辑器 class Editor { private string text = \\\"\\\"; public void Type(string text) { this.text += text; } public Memento Save() { return new Memento(text); } public void Restore(Memento memento) { text = memento.Text; } public override string ToString() { return text; } } // Caretaker类保存Memento对象的历史记录 class History { private readonly Editor editor; private readonly Stack<Memento> mementos = new Stack<Memento>(); public History(Editor editor) { this.editor = editor; } public void Backup() { mementos.Push(editor.Save()); } public void Undo() { if (mementos.Count == 0) return; var memento = mementos.Pop(); editor.Restore(memento); } } // 示例 var editor = new Editor(); var history = new History(editor); editor.Type(\\\"Hello\\\"); history.Backup(); editor.Type(\\\" World\\\"); history.Backup(); Console.WriteLine(editor); // 输出 \\\"Hello World\\\" history.Undo(); Console.WriteLine(editor); // 输出 \",\"在上面的代码示例中，我们创建了三个类：Memento 类、Editor 类和 History 类。Editor 类表示文本编辑器，它有一个成员变量 text，表示文本编辑器中当前的文本内容，以及 Type() 方法用于在文本编辑器中输入文本。Editor 类还有两个方法：Save() 和 Restore()。Save() 方法创建一个新的 Memento 对象并将当前文本内容保存在其中。Restore() 方法接受一个 Memento 对象，并将文本编辑器的状态恢复为该 Memento 对象中保存的状态。\",\"Memento 类有一个成员变量 Text，表示保存的文本内容。构造函数接受一个字符串参数，该参数是文本编辑器的当前文本内容。\",\"History 类用于保存 Memento 对象的历史记录。它有一个成员变量 editor，表示被保存的文本编辑器对象。History 类还有两个方法：Backup() 和 Undo()。Backup() 方法创建一个新的 Memento 对象并将其保存在历史记录中。Undo() 方法从历史记录中弹出最近保存的 Memento 对象，并将其传递给文本编辑器的 Restore() 方法来恢复编辑器的状态。\",\"在示例中，我们创建了一个文本编辑器和一个历史记录对象。我们使用 editor.Type() 方法输入了两个文本字符串，并使用 history.Backup() 方法将它们的状态保存在历史记录中。最后，我们调用 editor.ToString() 方法以获取文本编辑器的当前状态，并输出它。在此之后，我们调用 history.Undo() 方法撤销最后一次输入，再次调用 editor.ToString() 方法以获取当前状态，并输出它。\",\"这个示例演示了备忘录模式的基本概念。在实际应用中，备忘录模式可以用于保存对象状态的历史记录，实现撤销和重做操作，以及防止客户端直接访问对象状态，保持封装性。\"]}]},\"/articles/design-pattern/observer-pattern.html\":{\"title\":\"观察者模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"观察者模式（Observer Pattern），也称作发布-订阅模式（Publish-Subscribe Pattern），它是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象状态发生改变时，所有依赖于它的对象都能够自动收到通知并进行更新。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，使得当一个对象状态发生改变时，所有依赖于它的对象都能够自动收到通知并进行更新。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"观察者模式通常在以下情况下使用：\",\"当一个对象的改变需要同时改变其他对象的状态时。\",\"当您不知道有多少对象需要改变状态时。\",\"这种模式非常适合GUI编程中的事件处理，当一个控件状态改变时，需要自动通知所有相关的控件进行更新。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"观察者模式的优点：\",\"可以实现松耦合，被观察者和观察者之间没有直接的依赖关系，增加了系统的灵活性和可扩展性。\",\"支持广播通信，被观察者一次性通知多个观察者，提高了系统的效率和性能。\",\"观察者模式的缺点：\",\"观察者过多时会导致性能问题。\",\"如果被观察者和观察者之间的通信是双向的，则容易引起循环依赖问题。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个使用观察者模式的简单示例，假设有一个新闻发布者，它可以将最新新闻发布给订阅者。\",\"using System; using System.Collections.Generic; // 定义观察者接口 interface IObserver { void Update(string news); } // 定义被观察者接口 interface IObservable { void AddObserver(IObserver observer); void RemoveObserver(IObserver observer); void NotifyObservers(string news); } // 实现被观察者接口 class NewsPublisher : IObservable { private List<IObserver> observers = new List<IObserver>(); public void AddObserver(IObserver observer) { observers.Add(observer); } public void RemoveObserver(IObserver observer) { observers.Remove(observer); } public void NotifyObservers(string news) { foreach (var observer in observers) { observer.Update(news); } } public void PublishNews(string news) { Console.WriteLine($\\\"发布新闻：{news}\\\"); NotifyObservers(news); } } // 实现观察者接口 class Subscriber : IObserver { private string name; public Subscriber(string name) { this.name = name; } public void Update(string news) { Console.WriteLine($\\\"订阅者 {name} 接收到新闻：{news}\\\"); } } class Program { static void Main(string[] args) { NewsPublisher publisher = new NewsPublisher(); Subscriber subscriber1 = new Subscriber(\\\"张三\\\"); Subscriber subscriber2 = new Subscriber(\\\"李四\\\"); publisher.AddObserver(subscriber1); publisher.AddObserver(subscriber2); publisher.PublishNews(\\\"中国获得世界杯冠军！\\\"); publisher.RemoveObserver(subscriber2); publisher.PublishNews(\\\"苹果发布新款iPhone！\\\"); Console.ReadKey(); } } \",\"在上面的代码中，我们定义了两个接口 IObserver 和 IObservable，它们分别代表观察者和被观察者。我们实现了被观察者接口 NewsPublisher，其中包含一个观察者列表，并实现了添加观察者、删除观察者和通知观察者的方法。我们还实现了观察者接口 Subscriber，其中包含一个名字属性和更新方法。\",\"在 Main 方法中，我们创建了一个新的 NewsPublisher 对象，并添加了两个观察者 subscriber1 和 subscriber2。然后我们调用 PublishNews 方法发布了两个新闻，并在控制台中输出了订阅者收到新闻的消息。最后，我们从观察者列表中删除了 subscriber2，并再次发布了一条新闻，这次只有 subscriber1 收到了新闻。\",\"这是一个简单的示例，实际使用中可能会更加复杂。但是通过这个例子，您应该能够了解观察者模式的基本原理和使用方法。\",\"注：上面的代码示例有一些潜在的优化空间，例如可以将 observers 字段改为使用 HashSet<IObserver> 来避免重复添加观察者，可以使用 C#8.0 中的 using 块简化代码等。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"using System; using System.Collections.Generic; namespace ObserverPattern { // 定义观察者接口 public interface IObserver<in T> { // 定义更新方法 void Update(T subject); } // 定义被观察者接口 public interface IObservable<out T> { // 添加观察者 IDisposable Subscribe(IObserver<T> observer); // 发布消息 void Publish(T subject); } // 实现被观察者接口 public class NewsPublisher : IObservable<string> { // 使用 HashSet 来保存观察者列表 private readonly HashSet<IObserver<string>> observers = new HashSet<IObserver<string>>(); // 添加观察者 public IDisposable Subscribe(IObserver<string> observer) { observers.Add(observer); return new Unsubscriber(observers, observer); } // 发布消息 public void Publish(string subject) { // 通知所有观察者 foreach (var observer in observers) { observer.Update(subject); } } // 内部类，用于实现 IDisposable 接口 private class Unsubscriber : IDisposable { private readonly HashSet<IObserver<string>> _observers; private readonly IObserver<string> _observer; public Unsubscriber(HashSet<IObserver<string>> observers, IObserver<string> observer) { _observers = observers; _observer = observer; } public void Dispose() { _observers.Remove(_observer); } } } // 实现观察者接口 public class Subscriber : IObserver<string> { private readonly string _name; public Subscriber(string name) { _name = name; } // 更新方法 public void Update(string subject) { Console.WriteLine($\\\"{_name} 收到新闻：{subject}\\\"); } } class Program { static void Main(string[] args) { // 创建新闻发布者 var publisher = new NewsPublisher(); // 添加观察者 var subscriber1 = new Subscriber(\\\"小明\\\"); publisher.Subscribe(subscriber1); var subscriber2 = new Subscriber(\\\"小红\\\"); publisher.Subscribe(subscriber2); // 发布消息 publisher.Publish(\\\"中国获得世界杯冠军！\\\"); // 取消订阅观察者 2 var unsubscriber = publisher.Subscribe(subscriber2); unsubscriber.Dispose(); // 发布消息 publisher.Publish(\\\"苹果发布新款 iPhone！\\\"); Console.ReadKey(); } } } \",\"在这个优化版本的代码中，我们使用了 HashSet 来存储观察者列表，这样就避免了重复添加观察者的问题。同时，我们还实现了 IDisposable 接口，这样就可以通过 using 块来自动释放资源。\",\"除此之外，我们还改变了一些命名和参数的名称，对代码进行了重构，这样代码就更加简洁、易读和易于维护了。\"]}]},\"/articles/design-pattern/prototype-pattern.html\":{\"title\":\"原型模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"原型模式是一种创建型设计模式，它允许通过克隆现有对象来创建新对象，而无需向客户端公开对象创建的细节。该模式可以有效地减少对象创建的成本，因为它允许在运行时动态地添加或删除产品。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"原型模式是一种创建型设计模式，它允许通过克隆现有对象来创建新对象，而无需向客户端公开对象创建的细节。该模式可以有效地减少对象创建的成本，因为它允许在运行时动态地添加或删除产品。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"原型模式适用于以下情况：\",\"当需要创建对象的过程很昂贵或复杂时，可以使用现有对象的克隆来避免这种成本。\",\"当创建对象的过程要求应用程序具有独立于其类型的能力时，可以使用原型模式。也就是说，对象可以按原样复制，而不会知道它们的类。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"使用原型模式的优点包括：\",\"可以避免重复性的代码，节约了创建对象的成本和时间。\",\"可以更灵活地创建对象，而不需要创建新的子类或更改现有类的实现。\",\"可以动态添加或删除产品，更容易实现一个复杂的产品系列。\",\"使用原型模式也有一些缺点：\",\"必须正确地实现克隆方法。如果没有正确地实现，它可能会导致不良后果，例如对象状态的不正确复制。\",\"如果对象具有循环引用或对象图太复杂，则可能需要较长时间才能完成克隆。\",\"如果对象状态需要特殊处理，则可能需要额外的实现来正确地克隆该状态。\",\"下面是一个使用C#实现原型模式的示例代码，我们将创建一个原型电子产品类，该类可以被克隆成不同类型的电子产品。\",\"// 定义原型类 abstract class ElectronicProductPrototype { public string Model { get; set; } public abstract ElectronicProductPrototype Clone(); } // 具体原型类1：手机 class PhonePrototype : ElectronicProductPrototype { public PhonePrototype(string model) { this.Model = model; } public override ElectronicProductPrototype Clone() { Console.WriteLine($\\\"Cloning phone model {this.Model}...\\\"); return (ElectronicProductPrototype)this.MemberwiseClone(); } } // 具体原型类2：平板电脑 class TabletPrototype : ElectronicProductPrototype { public TabletPrototype(string model) { this.Model = model; } public override ElectronicProductPrototype Clone() { Console.WriteLine($\\\"Cloning tablet model {this.Model}...\\\"); return (ElectronicProductPrototype)this.MemberwiseClone(); } } // 客户端 class Client { static void Main(string[] args) { // 创建手机原型 var phonePrototype = new PhonePrototype(\\\"iPhone X\\\"); // 克隆手机原型 var clonedPhone1 = phonePrototype.Clone(); Console.WriteLine($\\\"Cloned phone model: {clonedPhone1.Model}\\\"); var clonedPhone2 = phonePrototype.Clone(); Console.WriteLine($\\\"Cloned phone model: {clonedPhone2.Model}\\\"); // 创建平板电脑原型 var tabletPrototype = new TabletPrototype(\\\"iPad Pro\\\"); // 克隆平板电脑原型 var clonedTablet1 = tabletPrototype.Clone(); Console.WriteLine($\\\"Cloned tablet model: {clonedTablet1.Model}\\\"); var clonedTablet2 = tabletPrototype.Clone(); Console.WriteLine($\\\"Cloned tablet model: {clonedTablet2.Model}\\\"); } } \",\"在上面的代码中，我们首先定义了一个 ElectronicProductPrototype 抽象类，它包含一个 Model 属性和一个 Clone() 方法。Clone() 方法返回一个克隆出来的对象，因为在原型模式中我们可以使用现有的对象作为原型，根据需要创建新的对象。\",\"接着，我们定义了两个具体的原型类 PhonePrototype 和 TabletPrototype，它们继承自 ElectronicProductPrototype，并实现了 Clone() 方法。在 Clone() 方法中，我们使用了 MemberwiseClone() 方法来复制对象。这个方法会复制对象中的所有值类型成员，并对于引用类型成员只复制引用而不复制对象本身。\",\"最后，我们在客户端代码中创建了原型对象，并通过调用 Clone() 方法来克隆它们。我们可以通过克隆后的对象的 Model 属性来检查它们是否被成功克隆。\"]}]},\"/articles/design-pattern/proxy-pattern.html\":{\"title\":\"代理模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\"]}]},\"/articles/design-pattern/singleton-pattern.html\":{\"title\":\"单例模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 它的目的是确保某个类只有一个实例，并提供一个全局的访问点。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"单例模式是一种创建型设计模式，它保证一个类只有一个实例，并提供了一个全局访问点来访问这个实例。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"在以下情况下可以考虑使用单例模式：\",\"当一个对象只需要存在一个实例，例如线程池、缓存、日志、配置、数据库连接等。\",\"当对象的创建和销毁开销较大，需要复用时，例如游戏中的角色管理器。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点\",\"保证了一个类只有一个实例，避免了重复创建实例的开销，节省了内存。\",\"提供了一个全局访问点，方便了对象的访问和管理。\",\"缺点\",\"单例模式的逻辑通常都集中在一个类中，会增加这个类的复杂度，不利于维护和测试。\",\"单例模式容易被滥用，过度使用会导致代码不易扩展和测试。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个基本的单例模式的C#实现示例：\",\"public sealed class Singleton { private static readonly Singleton instance = new Singleton(); private Singleton() { } public static Singleton Instance { get { return instance; } } public void SomeMethod() { Console.WriteLine(\\\"Some method in singleton instance\\\"); } } \",\"这里定义了一个名为 Singleton 的类，它的构造函数被声明为私有的，以确保不能从外部实例化该类的对象。类的实例被存储在名为 instance 的静态变量中，并通过公共静态属性 Instance 进行访问。\",\"下面是一个使用 Singleton 类的示例：\",\"class Program { static void Main(string[] args) { Singleton instance1 = Singleton.Instance; Singleton instance2 = Singleton.Instance; if (instance1 == instance2) { Console.WriteLine(\\\"Singleton works!\\\"); } instance1.SomeMethod(); } } \",\"在这个示例中，我们从 Singleton.Instance 属性中获取 Singleton 类的实例，并将它赋值给两个不同的变量 instance1 和 instance2。然后我们比较这两个变量是否相等，如果相等，说明只有一个实例被创建，单例模式有效。最后，我们调用 instance1 的 SomeMethod() 方法，输出 \\\"Some method in singleton instance\\\"。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"这个示例是一个基本的单例模式实现，但它可能存在线程安全性问题。如果多个线程同时调用 Singleton.Instance 属性，可能会创建多个 Singleton 类的实例。要解决这个问题，我们可以通过双重检查锁定（Double-Checked Locking）来确保只有一个实例被创建：\",\"public sealed class Singleton { private static volatile Singleton instance; private static object syncRoot = new object(); private Singleton() { } public static Singleton Instance { get { if (instance == null) { lock (syncRoot) { if (instance == null) { instance = new Singleton(); } } } return instance; } } public void SomeMethod() { Console.WriteLine(\\\"Some method in singleton instance\\\"); } } \",\"在这个示例中，我们添加了一个名为 syncRoot 的对象作为锁定对象。在访问 Singleton.Instance 属性时，首先检查实例是否已经存在，如果不存在，就使用 lock 关键字锁定 syncRoot 对象，并再次检查实例是否已经被创建。如果没有，就创建一个新的实例并将其赋值给 instance。这种双重检查锁定的方式可以确保只有一个实例被创建，并且能够避免性能上的开销。\"]}]},\"/articles/design-pattern/state-pattern.html\":{\"title\":\"状态模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在内部状态改变时改变它的行为，使得对象看起来似乎修改了它的类。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在内部状态改变时改变它的行为，使得对象看起来似乎修改了它的类。\"]},{\"header\":\"适用场景\",\"slug\":\"适用场景\",\"contents\":[\"适用于有多个状态且状态转换比较复杂的对象，如游戏角色状态、工作流状态等。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"状态模式将每个状态封装为一个类，避免了复杂的条件判断。\",\"状态模式将状态转换显式化，方便了状态的管理和扩展。\",\"状态模式符合开闭原则，增加新的状态不需要修改原有代码，只需要增加新的状态类。\"]},{\"header\":\"缺点\",\"slug\":\"缺点\",\"contents\":[\"状态模式会增加系统中类的数量，导致系统复杂度增加。\",\"状态模式需要对状态进行分析和设计，不适用于简单状态的处理。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"// 状态接口 public interface IState { void Handle(StateContext context); } // 具体状态类A public class ConcreteStateA : IState { public void Handle(StateContext context) { Console.WriteLine(\\\"当前状态为A，执行A状态的业务逻辑\\\"); // 切换状态 context.State = new ConcreteStateB(); } } // 具体状态类B public class ConcreteStateB : IState { public void Handle(StateContext context) { Console.WriteLine(\\\"当前状态为B，执行B状态的业务逻辑\\\"); // 切换状态 context.State = new ConcreteStateC(); } } // 具体状态类C public class ConcreteStateC : IState { public void Handle(StateContext context) { Console.WriteLine(\\\"当前状态为C，执行C状态的业务逻辑\\\"); // 切换状态 context.State = new ConcreteStateA(); } } // 状态上下文类 public class StateContext { private IState state; public StateContext(IState state) { this.state = state; } public IState State { get { return state; } set { state = value; } } // 处理请求 public void Request() { state.Handle(this); } } // 使用示例 class Program { static void Main(string[] args) { StateContext context = new StateContext(new ConcreteStateA()); for (int i = 0; i < 5; i++) { context.Request(); } } } \"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"在状态模式的实现中，我们使用了多个具体状态类来表示不同的状态，如果状态比较多，类的数量会增加很多，可以考虑使用状态模式和工厂方法模式结合，通过工厂方法创建具体状态类的实例，减少类的数量。\",\"以下是结合工厂方法模式对状态模式的优化代码示例：\",\"// 状态接口 public interface IState { void Handle(StateContext context); } // 具体状态类A public class ConcreteStateA : IState { public void Handle(StateContext context) { Console.WriteLine(\\\"当前状态为A，执行A状态的业务逻辑\\\"); // 切换状态 context.State = StateFactory.CreateState(\\\"B\\\"); } } // 具体状态类B public class ConcreteStateB : IState { public void Handle(StateContext context) { Console.WriteLine(\\\"当前状态为B，执行B状态的业务逻辑\\\"); // 切换状态 context.State = StateFactory.CreateState(\\\"C\\\"); } } // 具体状态类C public class ConcreteStateC : IState { public void Handle(StateContext context) { Console.WriteLine(\\\"当前状态为C，执行C状态的业务逻辑\\\"); // 切换状态 context.State = StateFactory.CreateState(\\\"A\\\"); } } // 状态工厂类 public static class StateFactory { // 创建具体状态类的实例 public static IState CreateState(string stateName) { switch (stateName) { case \\\"A\\\": return new ConcreteStateA(); case \\\"B\\\": return new ConcreteStateB(); case \\\"C\\\": return new ConcreteStateC(); default: throw new ArgumentException(\\\"无效的状态名称\\\"); } } } // 状态上下文类 public class StateContext { private IState state; public StateContext(IState state) { this.state = state; } public IState State { get { return state; } set { state = value; } } // 处理请求 public void Request() { state.Handle(this); } } // 使用示例 class Program { static void Main(string[] args) { StateContext context = new StateContext(StateFactory.CreateState(\\\"A\\\")); for (int i = 0; i < 5; i++) { context.Request(); } } } \",\"在这个优化后的代码示例中，我们使用工厂方法模式来创建具体状态类的实例，减少了类的数量，提高了代码的可维护性。同时，我们仍然保留了状态模式的核心思想，即将状态封装为一个独立的类，通过状态的转换改变对象的行为。\"]}]},\"/articles/design-pattern/strategy-pattern.html\":{\"title\":\"策略模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为。该模式定义了一系列算法，将它们封装成可相互替换的策略，并使它们能够互相替换。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为。该模式定义了一系列算法，将它们封装成可相互替换的策略，并使它们能够互相替换。\"]},{\"header\":\"适用场景\",\"slug\":\"适用场景\",\"contents\":[\"策略模式适用于需要在运行时动态选择算法的情况。例如，对于不同的排序需求，可以定义不同的排序策略，并在运行时选择合适的策略进行排序。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"策略模式可以在运行时动态地选择算法，提高了代码的灵活性和可扩展性。\",\"策略模式将不同的算法封装成独立的类，使得代码更加清晰易懂，易于维护和测试。\",\"策略模式可以避免大量的条件语句，提高代码的可读性和可维护性。\"]},{\"header\":\"缺点\",\"slug\":\"缺点\",\"contents\":[\"策略模式会增加系统中类的数量，可能会导致代码复杂度的增加。\",\"策略模式需要客户端了解所有的策略，并且自行选择合适的策略，可能会增加客户端的复杂度。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个策略模式的C#代码示例，用于实现不同的支付策略：\",\"// 支付策略接口 public interface IPaymentStrategy { void Pay(double amount); } // 支付宝支付策略 public class AliPayStrategy : IPaymentStrategy { public void Pay(double amount) { // 调用支付宝支付接口 } } // 微信支付策略 public class WeChatPayStrategy : IPaymentStrategy { public void Pay(double amount) { // 调用微信支付接口 } } // 支付上下文 public class PaymentContext { private readonly IPaymentStrategy paymentStrategy; public PaymentContext(IPaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void Pay(double amount) { paymentStrategy.Pay(amount); } } \",\"在这个示例中，我们定义了一个支付策略接口 IPaymentStrategy ，并实现了不同的支付策略类 AliPayStrategy 和 WeChatPayStrategy。同时，我们还定义了一个支付上下文类 PaymentContext，它包含了一个支付策略对象，并提供了 Pay 方法用于支付操作。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"在上面的示例中，我们使用了接口来定义支付策略，这是一种比较灵活的方式。不过，如果我们只需要定义少量的固定策略，可以考虑使用枚举来实现：\",\"// 支付策略枚举 public enum PaymentStrategy { AliPay, WeChatPay } // 支付上下文 public class PaymentContext { private readonly PaymentStrategy paymentStrategy; public PaymentContext(PaymentStrategy paymentStrategy) { this.paymentStrategy = paymentStrategy; } public void Pay(double amount) { switch (paymentStrategy) { case PaymentStrategy.AliPay: // 调用支付宝支付接口 break; case PaymentStrategy.WeChatPay: // 调用微信支付接口 break; default: throw new ArgumentException(\\\"Invalid payment strategy\\\"); } } } \",\"在这个示例中，我们使用枚举 PaymentStrategy 来定义支付策略，支付上下文类PaymentContext 也相应地修改为使用枚举作为参数。这种方式虽然不够灵活，但对于少量的固定策略来说更加简洁明了。\"]}]},\"/articles/design-pattern/template-method-pattern.html\":{\"title\":\"模板方法模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现，以使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现，以使得子类可以在不改变算法结构的情况下重新定义算法中的某些步骤。\"]},{\"header\":\"适用场景\",\"slug\":\"适用场景\",\"contents\":[\"当多个算法有一些共同的流程或者步骤，但具体实现方式各不相同时，可以使用模板方法模式。例如，多个子类都需要实现一个操作的不同步骤，但是这些步骤的执行顺序或逻辑相同，可以将这些共同的流程或步骤抽象出来作为模板方法，子类只需要实现自己不同的步骤即可。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"提高代码复用性：模板方法将多个子类共同的流程或步骤抽象出来，避免了重复代码的出现，提高了代码复用性。\",\"提高代码可维护性：将算法的结构固定下来，便于维护和修改，因为只需要修改模板方法即可，不用修改每个子类的实现。\",\"可扩展性好：由于具体实现是在子类中完成的，因此增加新的子类非常方便。\"]},{\"header\":\"缺点\",\"slug\":\"缺点\",\"contents\":[\"代码复杂度较高：模板方法模式的实现较为复杂，需要把算法拆分成多个步骤，并定义抽象类、具体子类等多个类。\",\"限制了子类的扩展性：模板方法模式的缺点是固定了算法的结构，这使得子类无法自由地扩展或修改算法的结构。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是使用模板方法模式实现的一个制作饮料的示例，其中抽象类 Beverage 定义了饮料的制作流程，具体子类 Coffee 和 Tea 实现了不同的步骤：\",\"// 抽象类：饮料 public abstract class Beverage { // 模板方法：制作饮料 public void MakeBeverage() { BoilWater(); Brew(); PourInCup(); if (NeedCondiments()) { AddCondiments(); } } // 抽象方法：加入调料 public abstract void AddCondiments(); // 具体方法：烧水 public void BoilWater() { Console.WriteLine(\\\"Boiling water...\\\"); } // 具体方法：倒入杯子 public void PourInCup() { Console.WriteLine(\\\"Pouring into cup...\\\"); } // 抽象方法：冲泡饮料 public abstract void Brew(); // 钩子方法：是否需要加入调料，默认需要 public virtual bool NeedCondiments() { return true; } } // 具体子类：咖啡 public class Coffee : Beverage { public override void AddCondiments() { Console.WriteLine(\\\"Adding sugar and milk...\\\"); } public override void Brew() { Console.WriteLine(\\\"Brewing coffee...\\\"); } } // 具体子类：茶 public class Tea : Beverage { public override void AddCondiments() { Console.WriteLine(\\\"Adding lemon...\\\"); } public override void Brew() { Console.WriteLine(\\\"Steeping the tea...\\\"); } public override bool NeedCondiments() { return false; } } // 客户端代码 class Client { static void Main(string[] args) { // 制作咖啡 Console.WriteLine(\\\"Making coffee...\\\"); Beverage coffee = new Coffee(); coffee.MakeBeverage(); Console.WriteLine(); // 制作茶 Console.WriteLine(\\\"Making tea...\\\"); Beverage tea = new Tea(); tea.MakeBeverage(); } } \",\"上述代码中， Beverage 是抽象类，定义了制作饮料的模板方法 MakeBeverage() 和一些具体方法和钩子方法，以及抽象方法 AddCondiments() 和 Brew() ，这两个方法分别由 Coffee 和 Tea 实现不同的功能。\",\"Coffee 和 Tea 是具体的子类，实现了自己不同的加调料和冲泡方法，并可以通过重写 NeedCondiments() 方法来决定是否需要加入调料。\",\"客户端代码中，先创建 Coffee 和 Tea 的实例，并分别调用它们的 MakeBeverage() 方法，完成了制作饮料的过程。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"在模板方法模式中，可以通过钩子方法来让子类决定是否执行一些步骤或者添加一些额外的操作。如果我们在需要添加额外操作时，直接在子类中添加对应的方法，会导致代码冗余，可维护性不佳。因此，我们可以使用模板方法模式的扩展模式——钩子方法模式，将额外的操作放到钩子方法中，从而避免代码冗余，提高代码的可维护性。\",\"以下是使用钩子方法模式对上述代码进行优化的示例：\",\"// 抽象类：饮料 public abstract class Beverage { // 制作饮料的模板方法 public void MakeBeverage() { BoilWater(); Brew(); PourInCup(); if (NeedCondiments()) { AddCondiments(); } Hook(); } public void BoilWater() { Console.WriteLine(\\\"Boiling water...\\\"); } public void PourInCup() { Console.WriteLine(\\\"Pouring into cup...\\\"); } // 钩子方法：额外的操作 public virtual void Hook() { } // 抽象方法：添加调料 public abstract void AddCondiments(); // 抽象方法：冲泡饮料 public abstract void Brew(); // 钩子方法：是否需要添加调料，默认需要 public virtual bool NeedCondiments() { return true; } } // 具体子类：咖啡 public class Coffee : Beverage { public override void AddCondiments() { Console.WriteLine(\\\"Adding sugar and milk...\\\"); } public override void Brew() { Console.WriteLine(\\\"Brewing coffee...\\\"); } // 钩子方法：额外的操作 public override void Hook() { Console.WriteLine(\\\"Cleaning coffee pot...\\\"); } } // 具体子类：茶 public class Tea : Beverage { public override void AddCondiments() { Console.WriteLine(\\\"Adding lemon...\\\"); } public override void Brew() { Console.WriteLine(\\\"Steeping the tea...\\\"); } // 钩子方法：是否需要添加调料，默认不需要 public override bool NeedCondiments() { return false; } // 钩子方法：额外的操作 public override void Hook() { Console.WriteLine(\\\"Cleaning tea pot...\\\"); } } // 客户端代码 class Client { static void Main(string[] args) { // 制作咖啡 Console.WriteLine(\\\"Making coffee...\\\"); Beverage coffee = new Coffee(); coffee.MakeBeverage(); Console.WriteLine(); // 制作茶 Console.WriteLine(\\\"Making tea...\\\"); Beverage tea = new Tea(); tea.MakeBeverage(); } } \",\"在优化后的代码中，我们将额外的操作放到了钩子方法Hook()中，子类可以选择是否重写Hook()来添加额外的操作。通过这种方式，我们将额外操作的实现从子类中分离出来，降低了代码的耦合度，提高了代码的可维护性和可扩展性。\"]}]},\"/articles/design-pattern/visitor-pattern.html\":{\"title\":\"访问者模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"访问者模式（Visitor Pattern）是一种行为型设计模式，它允许你将算法从对象结构中分离出来，使这些算法可以在不改变这些对象的前提下被添加到该对象结构中。通过这种方式，可以在不修改对象结构的情况下，对其进行复杂的操作和处理。\"]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"访问者模式（Visitor Pattern）是一种行为型设计模式，它允许你将算法从对象结构中分离出来，使这些算法可以在不改变这些对象的前提下被添加到该对象结构中。通过这种方式，可以在不修改对象结构的情况下，对其进行复杂的操作和处理。\"]},{\"header\":\"适用场景\",\"slug\":\"适用场景\",\"contents\":[\"访问者模式通常在以下情况下使用：\",\"对象结构包含许多具有不同接口的对象，并且您希望对这些对象进行复杂的操作，而不想污染这些对象的类。\",\"需要对对象结构进行许多不相关的操作，而不希望将这些操作封装到对象中。\",\"对象结构中的类经常更改，但您希望对其进行许多不同的操作而不需要修改这些类。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"访问者模式使得添加新的操作变得容易，而不会影响到对象结构的类。\",\"可以将相关操作封装在一个访问者中，从而使代码更加结构化。\",\"可以将对象结构和操作分离，使得代码更加清晰。\"]},{\"header\":\"缺点\",\"slug\":\"缺点\",\"contents\":[\"由于访问者模式需要将操作和对象结构分离，因此其代码可能比较复杂。\",\"在对象结构中添加新的元素可能需要修改访问者的接口。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"下面是一个使用访问者模式的示例代码。假设我们有一个包含了多个元素的对象结构，每个元素都有一个Accept方法，接受一个访问者作为参数，并调用该访问者的Visit方法来进行操作。\",\"// 抽象元素类 public abstract class Element { public abstract void Accept(IVisitor visitor); } // 具体元素类A public class ConcreteElementA : Element { public override void Accept(IVisitor visitor) { visitor.VisitConcreteElementA(this); } public void OperationA() { // 元素A的特定操作 } } // 具体元素类B public class ConcreteElementB : Element { public override void Accept(IVisitor visitor) { visitor.VisitConcreteElementB(this); } public void OperationB() { // 元素B的特定操作 } } // 抽象访问者类 public interface IVisitor { void VisitConcreteElementA(ConcreteElementA elementA); void VisitConcreteElementB(ConcreteElementB elementB); } // 具体访问者类 public class ConcreteVisitor : IVisitor { public void VisitConcreteElementA(ConcreteElementA elementA) { elementA.OperationA(); } public void VisitConcreteElementB(ConcreteElementB elementB) { elementB.OperationB(); } } // 对象结构 public class ObjectStructure { private List<Element> elements = new List<Element>(); public void Attach(Element element) { elements.Add(element); } public void Detach(Element element) { elements.Remove(element); } public void Accept(IVisitor visitor) { foreach (Element element in elements) { element.Accept(visitor); } } } //客户端代码 public class Client { public void Main() { ObjectStructure objectStructure = new ObjectStructure(); objectStructure.Attach(new ConcreteElementA()); objectStructure.Attach(new ConcreteElementB()); ConcreteVisitor visitor = new ConcreteVisitor(); objectStructure.Accept(visitor); } } \",\"在上面的示例代码中，我们定义了三个抽象元素类、两个具体元素类，一个抽象访问者类和一个具体访问者类。我们还定义了一个对象结构类来管理元素，并在客户端代码中将元素添加到对象结构中，然后创建一个访问者并将其传递给对象结构的 Accept 方法。这样，访问者就可以访问元素并进行操作，而不需要在元素类中添加任何新的方法。\"]},{\"header\":\"优化\",\"slug\":\"优化\",\"contents\":[\"上面的代码示例已经比较简单和优化了，但是在实际的项目中，如果对象结构中的元素类比较多，访问者类可能会变得非常庞大，这时候可以考虑使用抽象访问者类和具体访问者类之间的继承关系来简化访问者类的实现。另外，如果对象结构中的元素类发生了变化，我们还可以使用反射技术来自动注册元素类和访问者类，从而简化代码。\",\"// 抽象元素类 public abstract class Element { public abstract void Accept(IVisitor visitor); } // 具体元素类A public class ConcreteElementA : Element { public override void Accept(IVisitor visitor) { visitor.VisitConcreteElementA(this); } public void OperationA() { // 业务逻辑 } } // 具体元素类B public class ConcreteElementB : Element { public override void Accept(IVisitor visitor) { visitor.VisitConcreteElementB(this); } public void OperationB() { // 业务逻辑 } } // 抽象访问者类 public interface IVisitor { void VisitConcreteElementA(ConcreteElementA element); void VisitConcreteElementB(ConcreteElementB element); } // 具体访问者类 public class ConcreteVisitor : IVisitor { public void VisitConcreteElementA(ConcreteElementA element) { element.OperationA(); } public void VisitConcreteElementB(ConcreteElementB element) { element.OperationB(); } } // 对象结构类 public class ObjectStructure { private List<Element> elements = new List<Element>(); public void Attach(Element element) { elements.Add(element); } public void Detach(Element element) { elements.Remove(element); } public void Accept(IVisitor visitor) { foreach (Element element in elements) { element.Accept(visitor); } } } // 客户端代码 public class Client { public void Main() { ObjectStructure objectStructure = new ObjectStructure(); objectStructure.Attach(new ConcreteElementA()); objectStructure.Attach(new ConcreteElementB()); ConcreteVisitor visitor = new ConcreteVisitor(); objectStructure.Accept(visitor); } } \",\"在优化后的代码中，我们去掉了抽象访问者类，并将其转换为接口，从而使访问者类的实现更加灵活。此外，我们还将具体元素类和具体访问者类的方法名更改为 VisitXXX 的形式，并将业务逻辑封装在这些方法中，以便访问者可以对不同类型的元素执行不同的操作。另外，我们还将对象结构类的 Attach 和 Detach 方法的参数类型改为 Element 类型，并在客户端代码中直接创建具体元素对象并将其添加到对象结构中，从而使代码更加简洁。\"]}]},\"/articles/distributed-middleware/\":{\"title\":\"分布式中间件系列\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"分布式中间件是构建分布式系统的关键技术之一，它能够协调跨多个计算机节点的通信和数据交换，提供了负载均衡、故障转移、数据复制、分布式事务等功能，帮助应用程序实现高可用性、可扩展性和性能优化等目标。本系列文章将介绍常见的分布式中间件技术，探讨其原理、设计思路、使用场景以及实现方法等方面的内容。\"]}]},\"/articles/houduan/\":{\"title\":\"后端相关\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"这里主要记录一些后端相关的技术内容，学习为主。\"]}]},\"/articles/houduan/cascade-data-management.html\":{\"title\":\"级联数据管理\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"工作中经常会遇到级联数据的管理，例如行政区划，在拉取级联树的时候不方便，在这里记录一种操作级联数据的方法，生成一个代码链，用与管理级联数据之间的关系\"]},{\"header\":\"说明\",\"slug\":\"说明\",\"contents\":[\"以行政区划为例，为每一级行政机构分配一个四位数的代码，例如：浙江省-0001，杭州市-00010001，宁波市-00010002，西湖区-000100010001，以此类推，暂且将这种代码的组合称为 代码链。\",\"初始化，若在设计表的时候没有引入 代码链字段，后期增加该字段的时候需要对数据进行批量赋值\",\"修改时，若修改父子层级关系，需要将被修改的行政区划及其所有子级的行政区划的代码链进行修改\",\"新增时，为新增的行政区划分配一个新的代码链，通常为同级代码链+1\"]},{\"header\":\"1. 初始化\",\"slug\":\"_1-初始化\",\"contents\":[\"/// <summary> /// 行政区划代码链初始化 /// </summary> /// <param name=\\\"biaoZhunDM\\\"></param> /// <returns></returns> public async Task<string> XingZhengQHDMLInit(string biaoZhunDM) { //将所有数据放入缓存，方便递归 var allList = await _xingZhengQHBMRepository .AsNoTracking() .Select(x => new GY_ZD_XingZhengQHBMModel { Id = x.Id, BiaoZhunDM = x.BiaoZhunDM, FuJiDM = x.FuJiDM, DaiMaLian = x.DaiMaLian }).ToListAsync(); //查询当前标准代码对应的数据 var entity = allList.FirstOrDefault(x => x.BiaoZhunDM == biaoZhunDM); //递归更新子集代码链 //批量更新错误信息 var errMsgList = new List<string>(); await UpdateDaiMaLianByRecursion(allList,new List<GY_ZD_XingZhengQHBMModel> { entity }, errMsgList); return string.Join('|', errMsgList); } /// <summary> /// 递归更新代码链 /// </summary> /// <param name=\\\"allList\\\">所有行政区划列表</param> /// <param name=\\\"fuJiEntityList\\\">父级行政区划列表</param> /// <returns></returns> public async Task UpdateDaiMaLianByRecursion(List<GY_ZD_XingZhengQHBMModel> allList, List<GY_ZD_XingZhengQHBMModel> fuJiEntityList, List<string> errMsgList) { //根据传入的父级行政区划查找所有子级行政区划 var childList = allList .GroupJoin(fuJiEntityList, all => all.FuJiDM, fuJi => fuJi.BiaoZhunDM, (all, fuJi) => new { all, fuJi }) .SelectMany(x => x.fuJi.DefaultIfEmpty(), (all, fuJi) => new { all.all, fuJi }) .Where(x => x.fuJi != null) .Select(x => x.all) .ToList(); if (!childList.Any()) return ; //按照父级代码分组 var groupList = childList.GroupBy(x => x.FuJiDM).Select(x=>x.Key).ToList(); //批量更新子集代码链 foreach (var item in groupList) { var fuJiEntity = fuJiEntityList.FirstOrDefault(x => x.BiaoZhunDM == item); var list = childList.Where(x => x.FuJiDM == item).ToList(); for (int i = 0; i < list.Count; i++) { var child = list[i]; child.DaiMaLian = fuJiEntity.DaiMaLian + (i + 1).ToString().PadLeft(4, '0'); } } try { await _xingZhengQHBMRepository.BatchUpdateAsync(childList, x => new { x.DaiMaLian }, y => y.Id); } catch (Exception ex) { errMsgList.Add(\\\"部分批量更新失败，失败层级父级ID：[\\\" + string.Join(',', fuJiEntityList.Select(x => x.Id).ToList()) + \\\"]\\\" + \\\",失败原因：\\\" + ex.Message); } //从数据集中排除已更新的 allList = allList .GroupJoin(childList, all => all.Id, child => child.Id, (all, child) => new { all, child }) .SelectMany(x => x.child.DefaultIfEmpty(), (all, child) => new { all.all, child }) .Where(x => x.child == null) .Select(x => x.all) .ToList(); await UpdateDaiMaLianByRecursion(allList, childList, errMsgList); } \"]},{\"header\":\"2. 新增\",\"slug\":\"_2-新增\",\"contents\":[\"/// <summary> /// 新增行政区划 /// </summary> /// <param name=\\\"createDto\\\"></param> /// <returns></returns> public async Task<string> AddXingZengQH(GY_ZD_XingZhengQHBMCreateDto createDto) { var count = await _xingZhengQHBMRepository.CountAsync(entity => entity.DaiMaLB == createDto.DaiMaLB && entity.BiaoZhunDM == createDto.BiaoZhunDM); if (count > 0) { throw new TongYongYWException($\\\"行政区划已存在！\\\"); } var entity = createDto.MapTo<GY_ZD_XingZhengQHBMCreateDto, GY_ZD_XingZhengQHBMModel>(); #region 代码链赋值 //两种情况 //1.新增的行政区划是父级下面的第一个子级，这时代码链需要在父级基础上增加四位 //2.新增的行政区划不是父级下面的第一个子级，这时代码链需要取子级最大的代码链 //当出现第一种情况时，获取的代码链是父级代码链后追加四个0，这是为了下面生成最新的代码链，并且不会影响取最大值 var daiMaLian = await _xingZhengQHBMRepository .AsNoTracking() .Where( x => x.FuJiDM == createDto.FuJiDM || x.BiaoZhunDM == createDto.FuJiDM) .Select(x => new { DaiMaLian = x.FuJiDM == createDto.FuJiDM ? x.DaiMaLian : x.DaiMaLian + \\\"0000\\\" }) .Select(x=>x.DaiMaLian) .MaxAsync(); entity.DaiMaLian = daiMaLian.Substring(0, daiMaLian.Length - 4) + (Convert.ToInt32(daiMaLian.Substring(daiMaLian.Length - 4, 4)) + 1).ToString().PadLeft(4,'0'); #endregion entity.DaiMaID = $\\\"{entity.DaiMaLB}{entity.BiaoZhunDM}\\\"; var result = await _xingZhengQHBMRepository.InsertAsync(entity); await _unitOfWork.SaveChangesAsync(); return result.Id; } \"]},{\"header\":\"3. 修改\",\"slug\":\"_3-修改\",\"contents\":[\"/// <summary> /// 修改行政区划 /// </summary> /// <param name=\\\"id\\\"></param> /// <param name=\\\"updateDto\\\"></param> /// <returns></returns> public async Task<string> UpdateXingZengQH(string id, GY_ZD_XingZhengQHBMUpdateDto updateDto) { await _unitOfWork.BeginTransactionAsync(); try { var entity = await _xingZhengQHBMRepository.GetAsync(id); if (entity == null) { throw new WeiZhaoDSException($\\\"行政区划不存在！\\\"); } var count = await _xingZhengQHBMRepository.CountAsync(entity => entity.Id != id && entity.DaiMaLB == updateDto.DaiMaLB && entity.BiaoZhunDM == updateDto.BiaoZhunDM); if (count > 0) { throw new TongYongYWException($\\\"行政区划已存在！\\\"); } #region 代码链更新 //层级是否修改 if (entity.FuJiDM != updateDto.FuJiDM) { //查询原代码链 var oldDaiMaLian = await _xingZhengQHBMRepository.AsNoTracking().Where(x => x.Id == id).Select(x => x.DaiMaLian).FirstOrDefaultAsync(); //查询新层级下的最大代码链 此处逻辑参考新增 var newDaiMaLian = await _xingZhengQHBMRepository .AsNoTracking() .Where(x => x.FuJiDM == updateDto.FuJiDM || x.BiaoZhunDM == updateDto.FuJiDM) .Select(x => new { DaiMaLian = x.FuJiDM == updateDto.FuJiDM ? x.DaiMaLian : x.DaiMaLian + \\\"0000\\\" }) .Select(x => x.DaiMaLian) .MaxAsync(); //更新代码链 entity.DaiMaLian = newDaiMaLian.Substring(0, newDaiMaLian.Length - 4) + (Convert.ToInt32(newDaiMaLian.Substring(newDaiMaLian.Length - 4, 4)) + 1).ToString().PadLeft(4,'0'); //查询所有需要更新代码链的子级 var childList = await _xingZhengQHBMRepository .AsNoTracking() .Where(x => x.DaiMaLian.StartsWith(oldDaiMaLian)) .Where(x => x.DaiMaLian != oldDaiMaLian) .Select(x => new GY_ZD_XingZhengQHBMModel { Id = x.Id, DaiMaLian = entity.DaiMaLian + x.DaiMaLian.Substring(oldDaiMaLian.Length, x.DaiMaLian.Length - oldDaiMaLian.Length)//更新后的代码链 }).ToListAsync(); //批量更新子集代码链 await _xingZhengQHBMRepository.BatchUpdateAsync(childList, x => new { x.DaiMaLian }, y => y.Id); } #endregion entity.Merge(updateDto); entity.DaiMaID = $\\\"{entity.DaiMaLB}{entity.BiaoZhunDM}\\\"; await _xingZhengQHBMRepository.UpdateAsync(entity); await _unitOfWork.SaveChangesAsync(); await _unitOfWork.CommitTransactionAsync(); return id; } catch (Exception ex) { await _unitOfWork.RollbackTransactionAsync(); throw new TongYongYWException(ex.Message); } } \"]}]},\"/articles/houduan/fanshediaoyongfangfa.html\":{\"title\":\"通过反射调用类中的方法\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"在C#中利用反射调用类中的方法\"]},{\"header\":\"创建测试类\",\"slug\":\"创建测试类\",\"contents\":[]},{\"header\":\"利用反射调用类中的方法\",\"slug\":\"利用反射调用类中的方法\",\"contents\":[\"using System.Reflection; namespace TestDemo; public class TestService { private Type _type; private MethodInfo? testA; private MethodInfo? testB; public async Task Test<T>(T t) { _type = t.GetType(); MethodInfo[] methods = _type.GetMethods(); testA = methods.FirstOrDefault(x => x.Name.Equals(\\\"TestA\\\", StringComparison.Ordinal)); testB = methods.FirstOrDefault(x => x.Name.Equals(\\\"TestB\\\", StringComparison.Ordinal)); Task taskA = testA?.Invoke(t, null) as Task; await taskA; object a = taskA.GetType().GetProperty(\\\"Result\\\").GetValue(taskA, null); Console.WriteLine(a.ToString()); Task taskB = testB?.Invoke(t, new object[] { \\\"111\\\", \\\"222\\\" }) as Task; await taskB; object b = taskB.GetType().GetProperty(\\\"Result\\\").GetValue(taskB, null); Console.WriteLine(b.ToString()); } } \"]},{\"header\":\"实例化实现类并调用方法\",\"slug\":\"实例化实现类并调用方法\",\"contents\":[]},{\"header\":\"打印结果\",\"slug\":\"打印结果\",\"contents\":[\"using TestDemo; TestA testA = new(); await testA.Test(); TestB testB = new(); await testB.Test(); Console.ReadLine(); \",\"这是A实现类的方法A 这是A实现类的方法B+参数a:111,参数b:222 这是B实现类的方法A 这是B实现类的方法B+参数a:111,参数b:222 \"]}]},\"/articles/linux/\":{\"title\":\"Linux系列\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"本系列主要记录Linux相关的技术，学习为主。\",\"本系列所有文档记录的操作都基于CentOS7系统。\"]}]},\"/articles/linux/boot-up-script.html\":{\"title\":\"在Linux设置shell脚本开机启动\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"在Linux上如何设置shell脚本开机启动\",\"赋予 /etc/rc.d/rc.local 可执行权\",\"chmod +x /etc/rc.d/rc.local \",\"赋予脚本可执行权限\",\"# 脚本路径根据实际位置修改 chmod +x /root/start.sh \",\"打开/etc/rc.d/rc.local文件，在最后面添加要执行脚本\",\"vi /etc/rc.d/rc.local \",\"#!/bin/bash # THIS FILE IS ADDED FOR COMPATIBILITY PURPOSES # # It is highly advisable to create own systemd services or udev rules # to run scripts during boot instead of using this file. # # In contrast to previous versions due to parallel execution during boot # this script will NOT be run after all other services. # # Please note that you must run 'chmod +x /etc/rc.d/rc.local' to ensure # that this script will be executed during boot. touch /var/lock/subsys/local # 执行脚本 /root/jiaoben.sh \",\"保存退出即可\",\"运行脚本报错：-bash: /root/start.sh: /bin/bash^M: 坏的解释器: 没有那个文件或目录\",\"出现这个问题的原因是因为 脚本文件是在Windows环境下编辑的，windows环境下，每一行的结尾是\\\\n\\\\r,而Linux环境下，每一行结尾是\\\\n。\",\"执行以下命令\",\"sed -i 's/\\\\r//' /root/start.sh \"]}]},\"/articles/linux/installation-dotnet.html\":{\"title\":\"在Linux上安装.Net6环境\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"如何在Linux系统中安装.Net6 Sdk\",\"将 Microsoft 包签名密钥添加到受信任密钥列表，并添加 Microsoft 包存储库\",\"sudo rpm -Uvh https://packages.microsoft.com/config/centos/7/packages-microsoft-prod.rpm \",\"安装运行时\",\"sudo yum install dotnet-runtime-6.0 \",\"安装SDK\",\"sudo yum install dotnet-sdk-6.0 \",\"检查安装结果\",\"dotnet --info \",\"输出示例：\",\"Host (useful for support): Version: 5.0.12 Commit: 7211aa01b3 .NET SDKs installed: No SDKs were found. .NET runtimes installed: Microsoft.AspNetCore.App 5.0.12 [/usr/share/dotnet/shared/Microsoft.AspNetCore.App] Microsoft.NETCore.App 5.0.12 [/usr/share/dotnet/shared/Microsoft.NETCore.App] To install additional .NET runtimes or SDKs: https://aka.ms/dotnet-download \"]}]},\"/articles/linux/installation-git.html\":{\"title\":\"在Linux上安装Git\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"如何在Linux上安装Git\",\"安装\",\"yum install -y git \",\"查看版本\",\"git --version \",\"设置用户信息\",\"git config --global user.name \\\"Your Name\\\" git config --global user.email \\\"email@example.com\\\" \"]}]},\"/articles/linux/installation-nginx.html\":{\"title\":\"在Linux上安装Nginx并设置开机启动\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"如何在Linux上安装Nginx并设置开机启动\"]},{\"header\":\"在CentOS7中添加Nginx源\",\"slug\":\"在centos7中添加nginx源\",\"contents\":[\"sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm \"]},{\"header\":\"安装Nginx\",\"slug\":\"安装nginx\",\"contents\":[\"sudo yum install -y nginx \"]},{\"header\":\"设置开机启动\",\"slug\":\"设置开机启动\",\"contents\":[\"在 /lib/systemd/system 目录添加 nginx.service 文件\",\"#进入自启文件目录 cd /lib/systemd/system #自定义nginx自启文件 touch nginx.service \",\"编辑nginx.service，并添加一下内容\",\"#编辑自启文件 vi nginx.service \",\"[Unit] Description=The nginx HTTP and reverse proxy server After=network-online.target remote-fs.target nss-lookup.target Wants=network-online.target [Service] Type=forking PIDFile=/run/nginx.pid # Nginx will fail to start if /run/nginx.pid already exists but has the wrong # SELinux context. This might happen when running `nginx -t` from the cmdline. # https://bugzilla.redhat.com/show_bug.cgi?id=1268621 ExecStartPre=/usr/bin/rm -f /run/nginx.pid ExecStartPre=/usr/sbin/nginx -t ExecStart=/usr/sbin/nginx ExecReload=/usr/sbin/nginx -s reload KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true Restart=always [Install] WantedBy=multi-user.target \",\"设置开机启动\",\"systemctl enable nginx \",\"重启服务器，查看nginx是否自启动\"]}]},\"/articles/linux/installation-node.html\":{\"title\":\"在Linux上安装Node/Npm\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"如何在Linux上安装Node/Npm\",\"一键下载并解压\",\"wget https://nodejs.org/dist/v14.16.0/node-v14.16.0-linux-x64.tar.xz && xz -d node-v14.16.0-linux-x64.tar.xz && tar -xvf node-v14.16.0-linux-x64.tar \",\"编辑环境变量\",\"vim /etc/profile \",\"在 /etc/profile文件末尾添加以下设置\",\"export NODE_HOME=/root/node-v14.16.0-linux-x64 export PATH=$PATH:$PATH:$NODE_HOME/bin export NODE_PATH=$NODE_HOME/lib/node_modules \",\"检查是否安装成功\",\"node -v \"]}]},\"/articles/linux/installation-yarn.html\":{\"title\":\"在Linux上安装Yarn\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"如何在Linux上安装Yarn\",\"设置Yarn仓库\",\"curl --silent --location https://dl.yarnpkg.com/rpm/yarn.repo | sudo tee /etc/yum.repos.d/yarn.repo \",\"开始安装\",\"sudo yum install yarn # 或者 sudo dnf install yarn \",\"测试Yarn是否安装成功\",\"yarn -v \"]}]},\"/articles/maui/\":{\"title\":\"MAUI系列\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"本系列主要记录 .NET MAUI 相关技术\"]}]},\"/articles/maui/changyongkongjian.html\":{\"title\":\"常用控件介绍\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"常用控件介绍\"]},{\"header\":\"Shell\",\"slug\":\"shell\",\"contents\":[]},{\"header\":\"概述\",\"slug\":\"概述\",\"contents\":[\".NET MAUI 中 Shell 提供大多数应用所需的基本功能：\",\"用于描述应用的视觉层次结构的单个位置。\",\"常见的导航用户体验。\",\"基于 URI 的导航方案，允许导航到应用中的任何页面。\",\"集成的搜索处理程序。\",\"Shell 表示应用的视觉层次结构，可以理解为应用的壳子，Shell类可以包含以下层次结构对象：\",\"FlyoutItem 一个 FlyoutItem 表示浮出控件中的一个或多个项，并且应在应用导航模式需要浮出控件时使用。\",\"TabBar 一个 TabBar 表示底部选项卡栏，并且应在应用导航模式以底部选项卡开头且不需要浮出控件时使用。\",\"Tab 表示分组内容，可通过底部选项卡导航。每个 Tab 对象都是 FlyoutItem 对象或 TabBar 对象的子对象。\",\"ShellContent 表示每个选项卡的 ContentPage 对象。\"]},{\"header\":\"底部导航栏\",\"slug\":\"底部导航栏\",\"contents\":[\"一个 TabBar 对象可以包含一个或多个 Tab 对象，每个 Tab 对象表示底部选项卡栏上的一个选项卡。 每个 Tab 对象可以包含一个或多个 ShellContent 对象，每个 ShellContent 对象将显示单个 ContentPage。 当对象中Tab存在多个ShellContent对象时，ContentPage这些对象可通过顶部选项卡导航。 在选项卡中，可以导航到称为详细信息页的其他 ContentPage 对象。\"]},{\"header\":\"基本实现\",\"slug\":\"基本实现\",\"contents\":[\"代码：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?> <Shell x:Class=\\\"Mediinfo_MAUI_Demo.AppShell\\\" xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:local=\\\"clr-namespace:Mediinfo_MAUI_Demo\\\" xmlns:view=\\\"clr-namespace:Mediinfo_MAUI_Demo.Views\\\" Shell.FlyoutBehavior=\\\"Disabled\\\"> <TabBar> <ShellContent Icon=\\\"huanzheliebiao.png\\\" Title=\\\"DemoPage1\\\" ContentTemplate=\\\"{DataTemplate view:DemoPage1}\\\" Route=\\\"DemoPage1\\\" /> <ShellContent Icon=\\\"bingqushouye.svg\\\" Title=\\\"Home\\\" ContentTemplate=\\\"{DataTemplate local:MainPage}\\\" Route=\\\"MainPage\\\" /> <ShellContent Icon=\\\"renwu.png\\\" Title=\\\"DemoPage2\\\" ContentTemplate=\\\"{DataTemplate view:DemoPage2}\\\" Route=\\\"DemoPage2\\\" /> </TabBar> </Shell> \",\"效果：\",\"DemoPage1\",\"首页\",\"DemoPage2\",\"相关信息\",\"ShellContent.Icon 导航栏按钮图标\",\"ShellContent.Title 导航栏按钮标题\",\"ShellContent.ContentTemplate 导航栏按钮对应的页面\",\"ShellContent.Route 生成的路由名称\"]},{\"header\":\"标题栏\",\"slug\":\"标题栏\",\"contents\":[\".NET MAUI 的Shell组件会为 ShellContent 生成一个默认的标题栏，但很多时候我们需要在顶部标题栏提供额外的功能和信息，这往往是默认标题栏无法实现的，这时候我们就需要自定义标题栏来实现效果。 MAUI 的 Shell.TitleView 属性可以用来自定义顶部标题栏，下面是简单的使用方法：\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" xmlns:model=\\\"clr-namespace:Mediinfo_MAUI_Demo.Models\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" x:DataType=\\\"viewmodel:MainPageViewModel\\\"> <Shell.TitleView> <Border StrokeThickness=\\\"0\\\" BackgroundColor =\\\"#e6f6ff\\\"> <Label HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" FontAttributes=\\\"Bold\\\" Text=\\\"病区首页\\\"/> </Border> </Shell.TitleView> <!--其他代码--> </ContentPage> \",\"但或许效果并不是你预期的那样：\",\"自定义标题栏\",\"如果你发现顶部标题栏的左侧并没显示为正确的颜色，这是 .NET MAUI 的一个Bug，我们可以使用另一个属性来暂时解决这个问题：\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" xmlns:model=\\\"clr-namespace:Mediinfo_MAUI_Demo.Models\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" x:DataType=\\\"viewmodel:MainPageViewModel\\\"> <Shell.BackgroundColor> <Color>#e6f6ff</Color> </Shell.BackgroundColor> <Shell.TitleView> <Border StrokeThickness=\\\"0\\\" BackgroundColor =\\\"Transparent\\\"> <Label HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" FontAttributes=\\\"Bold\\\" Text=\\\"自定义导航栏\\\"/> </Border> </Shell.TitleView> <!--其他代码--> </ContentPage> \",\"我们通过 Shell.BackgroundColor 属性将 Shell 的背景色改为目标颜色，再将 Shell.TitleView 下的根节点设为透明，如此我们便能实现预期的效果：\",\"自定义标题栏(修复bug)\"]},{\"header\":\"页面控件\",\"slug\":\"页面控件\",\"contents\":[]},{\"header\":\"ContentPage\",\"slug\":\"contentpage\",\"contents\":[\"ContentPage\",\"ContentPage 是 .NET MAUI 中最常用的页面类型，通常是页面的根节点。\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" x:Class=\\\"MyMauiApp.MyPage\\\" Title=\\\"MyPage\\\" BackgroundColor=\\\"White\\\"> <StackLayout> <Label Text=\\\"Welcome to .NET MAUI!\\\" VerticalOptions=\\\"Center\\\" HorizontalOptions=\\\"Center\\\" /> <!-- Other views go here --> </StackLayout> </ContentPage> \"]},{\"header\":\"布局控件\",\"slug\":\"布局控件\",\"contents\":[]},{\"header\":\"概述\",\"slug\":\"概述-1\",\"contents\":[\".NET MAUI 布局控件允许你在应用程序中排列和分组 UI 控件。 选择布局类需要了解布局如何定位其子元素，以及布局如何调整其子元素的大小。 此外，可能需要嵌套布局来创建所需的布局。\"]},{\"header\":\"StackLayout\",\"slug\":\"stacklayout\",\"contents\":[\"StackLayout\",\".NET MAUI 中 StackLayout 以水平或垂直方式在一展示内容。 默认情况下 StackLayout 是垂直方向排列。 此外，还可以将一个 StackLayout 用作包含其他子布局的父布局。 StackLayout 类定义了以下属性：\",\"Orientation 表示子视图的定位方向。 默认值为 Vertical。\",\"Spacing 表示每个子视图之间的空间量。 默认值为 0。\"]},{\"header\":\"VerticalStackLayout\",\"slug\":\"verticalstacklayout\",\"contents\":[\"VerticalStackLayout 是更高性能的 StackLayout 垂直布局替代方法。\"]},{\"header\":\"HorizontalStackLayout\",\"slug\":\"horizontalstacklayout\",\"contents\":[\"HorizontalStackLayout 是更高性能的 StackLayout 水平布局替代方法。\"]},{\"header\":\"Grid\",\"slug\":\"grid\",\"contents\":[\"Grid\",\"Grid 布局可将子级组织成行和列，这些行和列可以具有成比例或绝对大小。 默认情况下，Grid 包含一行和一列。 此外，还可以将一个 Grid 控件用作包含其他子布局的父布局。 需要注意的是，Grid 只能用作页面布局，不能当做表格来使用。\"]},{\"header\":\"FlexLayout\",\"slug\":\"flexlayout\",\"contents\":[\"FlexLayout\",\"FlexLayout 布局可以以水平和垂直方式排列其子级，如果子级过多，则还可以包装子级，使其子级适合单行或列。 此外， FlexLayout 还可以控制方向和对齐方式，并适应不同的屏幕大小。\"]},{\"header\":\"BindableLayout\",\"slug\":\"bindablelayout\",\"contents\":[\"BindableLayout 可绑定布局 可以使布局类控件通过绑定到集合来生成其内容，并可以选择使用 DataTemplate 设置每个项的外观。 BindableLayout 可绑定布局 具有下附加属性：\",\"ItemsSource 指定要由布局显示的 IEnumerable 集合。\",\"ItemTemplate 指定集合中的每个项的模板。\",\"ItemTemplateSelector 指定 DataTemplateSelector 用于在运行时为项选择模板。\"]},{\"header\":\"视图控件\",\"slug\":\"视图控件\",\"contents\":[]},{\"header\":\"CollectionView\",\"slug\":\"collectionview\",\"contents\":[\"CollectionView 是一种使用不同布局规范呈现数据列表的视图。\"]}]},\"/articles/maui/jinjie.html\":{\"title\":\"进阶\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"进阶\"]},{\"header\":\"自定义控件外观\",\"slug\":\"自定义控件外观\",\"contents\":[\"当程序页面中需要一些重复的复杂页面结构时，我们可以使用自定义控件外观的方式来避免重复编码。\",\"例：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" Title=\\\"首页\\\"> <VerticalStackLayout Spacing=\\\"10\\\"> <Grid RowDefinitions=\\\"60,20\\\" WidthRequest=\\\"60\\\"> <Image BackgroundColor=\\\"Red\\\" Source=\\\"baiyaohedui.svg\\\"/> <Label Grid.Row=\\\"1\\\" Text=\\\"摆药核对\\\" HorizontalOptions=\\\"Center\\\"/> </Grid> <Grid RowDefinitions=\\\"60,20\\\" WidthRequest=\\\"60\\\"> <Image BackgroundColor=\\\"Red\\\" Source=\\\"baiyaohedui.svg\\\"/> <Label Grid.Row=\\\"1\\\" Text=\\\"摆药核对\\\" HorizontalOptions=\\\"Center\\\"/> </Grid> <Grid RowDefinitions=\\\"60,20\\\" WidthRequest=\\\"60\\\"> <Image BackgroundColor=\\\"Red\\\" Source=\\\"baiyaohedui.svg\\\"/> <Label Grid.Row=\\\"1\\\" Text=\\\"摆药核对\\\" HorizontalOptions=\\\"Center\\\"/> </Grid> </VerticalStackLayout> </ContentPage> \",\"自定义控件外观\",\"上述代码可以通过自定义控件外观来简化：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" Title=\\\"首页\\\"> <ContentPage.Resources> <ControlTemplate x:Key=\\\"MenuTemplate\\\"> <Grid RowDefinitions=\\\"60,20\\\" WidthRequest=\\\"60\\\"> <Image BackgroundColor=\\\"Red\\\" Source=\\\"{TemplateBinding Value}\\\"/> <Label Grid.Row=\\\"1\\\" Text=\\\"{TemplateBinding Content}\\\" HorizontalOptions=\\\"Center\\\"/> </Grid> </ControlTemplate> </ContentPage.Resources> <VerticalStackLayout Spacing=\\\"10\\\"> <RadioButton Content=\\\"摆药1\\\" Value=\\\"baiyaohedui.svg\\\" ControlTemplate=\\\"{StaticResource MenuTemplate}\\\"/> <RadioButton Content=\\\"摆药2\\\" Value=\\\"baiyaohedui.svg\\\" ControlTemplate=\\\"{StaticResource MenuTemplate}\\\"/> <RadioButton Content=\\\"摆药3\\\" Value=\\\"baiyaohedui.svg\\\" ControlTemplate=\\\"{StaticResource MenuTemplate}\\\"/> </VerticalStackLayout> </ContentPage> \",\"自定义控件外观(简化)\",\"相关信息\",\"本段代码中，我们在 ContentPage.Resources 节点中创建了一个控件外观模板，并且在 RadioButton 控件中引用了该模板，这样我们便实现了自定义 RadioButton 的控件外观。 需要注意的是，只用具有 ControlTemplate 属性的控件才支持自定义外观，并且在模板中绑定的属性必须为引用该模板的控件的属性，如本示例中，模板绑定的属性 Value 和 Content 都是 RadioButton 控件中的属性。\"]},{\"header\":\"自定义控件\",\"slug\":\"自定义控件\",\"contents\":[\"当我们需要定义一个复杂的控件外观时，现有控件提供的属性可能不满足我们的需求，此时我们可以通过自定义控件来实现。\"]},{\"header\":\"创建自定义控件\",\"slug\":\"创建自定义控件\",\"contents\":[\"新建名为 MenuButtonControl.xaml 的 ContentView 文件，在隐藏代码文件 MenuButtonControl.xaml 中定义所需的属性：\"]},{\"header\":\"使用自定义控件\",\"slug\":\"使用自定义控件\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" Title=\\\"首页\\\"> <HorizontalStackLayout Spacing=\\\"10\\\" VerticalOptions=\\\"Start\\\" HorizontalOptions=\\\"Center\\\"> <controls:MenuButtonControl ImageSource=\\\"baiyaohedui.svg\\\" StartPointColor=\\\"#f7c563\\\" EndPointColor=\\\"#ee9f4a\\\" Text=\\\"摆药核对\\\"> </controls:MenuButtonControl> <controls:MenuButtonControl ImageSource=\\\"jiayaohedui.svg\\\" StartPointColor=\\\"#399afa\\\" EndPointColor=\\\"#66c7ff\\\" Text=\\\"加药核对\\\"> </controls:MenuButtonControl> <controls:MenuButtonControl ImageSource=\\\"pishichuli.svg\\\" StartPointColor=\\\"#61b8c0\\\" EndPointColor=\\\"#8dd9af\\\" Text=\\\"皮试处理\\\"> </controls:MenuButtonControl> </HorizontalStackLayout> </ContentPage> \",\"相关信息\",\"在页面根节点中引入自定义控件的命名空间并设置别名 controls ，然后再需要展示的位置通过 命名空间:控件名称 使用自定义控件 如 controls:MenuButtonControl，在自定义控件中为对应的属性赋值即可。\",\"效果：\",\"自定义控件示例\"]},{\"header\":\"自定义选取器\",\"slug\":\"自定义选取器\",\"contents\":[\"在很多场景中，我们都需要使用选取器来完成预期的功能和操作，但 MAUI 框架本身并没有提供一个支持高度自定义的选取器控件，这时我们可以使用社区工具包提供的 Popup 弹出组件来开发自定义选取器。\",\"注意\",\"Popup 只能在 Page 或继承于 Page 的类中使用。\"]},{\"header\":\"安装社区工具包\",\"slug\":\"安装社区工具包\",\"contents\":[\"参照官方教程安装\"]},{\"header\":\"自定义选取器弹出控件\",\"slug\":\"自定义选取器弹出控件\",\"contents\":[\"选取器弹出控件是点击某个选取器后弹出的内容，该控件是对弹出层的单独定义。\",\"选取器作为一个公共控件，弹出层的基本的外观及内容应该支持自定义，所以我们在封装选取器控件时应当开放出部分参数由外部传入。\"]},{\"header\":\"自定义选取器触发控件\",\"slug\":\"自定义选取器触发控件\",\"contents\":[\"上一步我们定义了 选取器弹出控件，所以接下来我们需要定义一个选取器弹出层的载体，也就是触发弹出框的组件。\"]},{\"header\":\"使用自定义选取器\",\"slug\":\"使用自定义选取器\",\"contents\":[\"效果：\",\"点击前\",\"点击后\",\"选择某一项\"]}]},\"/articles/maui/kuozhan.html\":{\"title\":\"扩展\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"MAUI相关知识扩展\"]},{\"header\":\"Messenger\",\"slug\":\"messenger\",\"contents\":[\"相关信息\",\"接口 IMessenger 是可用于在不同对象之间交换消息的类型协定。\",\"当两个对象之间需要建立松耦合关系时，特别适合使用消息机制。如ViewModel需要控制View进行某些操作时，如弹出对话框、播放动画，由于ViewModel对View是无感的，我们不能在ViewModel中去操作View，否则会造成ViewModel对View的依赖。另外，ViewModel层之间、以及View页面之间，也可能需要通过消息传递来完成一些交互。CommunityToolkit.Mvvm提供了比较完善的消息机制，以下内容主要介绍它的使用。\",\"使用前，需安装nuget包：CommunityToolkit.Mvvm。\"]},{\"header\":\"基本过程\",\"slug\":\"基本过程\",\"contents\":[\"基本过程\",\"如图所示，一个消息的收发，或者叫订阅与发布，主要有三个过程：\",\"创建信使和消息类型： 信使的作用：一是起到消息发布者与订阅者的桥梁作用；二是携带消息。在代码层面，信使是派生自 ValueChangedMessage<T> 或 RequestMessage<T> 的普通类，其中泛型 T 为消息的类型。\",\"订阅消息(Register)： 消息订阅者通过 WeakReferenceMessenger.Default.Register<T>(this,(r,m)=>{}); 订阅消息，其中泛型T为信使类，只要这个信使类被发布，它就能收到通知和消息。(r,m)=>{} 为订阅者收到通知后的执行逻辑，是一个 Lambda 函数，也有叫事件处理者 Handler 。其中参数 r 指消息订阅所在的这个对象，通过 this 传入，通过 r 可以在 Lambda 函数中引用其它成员；参数 m 就是信使携带的消息对象。\",\"发布消息(Send)： 消息发布者通过 WeakReferenceMessenger.Default.Send(new一个信息类对象) 发布消息。\"]},{\"header\":\"创建信使\",\"slug\":\"创建信使\",\"contents\":[\"//信使类为HiMessenger，消息类型为string public class HiMessenger: ValueChangedMessage<string> { public HiMessenger(string value):base(value) //创建信使对象时，通过构造函数初始化消息 { } } \"]},{\"header\":\"订阅消息\",\"slug\":\"订阅消息\",\"contents\":[\"WeakReferenceMessenger.Default.Register<HiMessenger>(this, async (r, m) => { //在这里处理消息，r 是接收方，m 是输入消息。使用作为输入传递的接收者使得 lambda 表达式不会捕获\\\"this\\\",从而提高了性能。 }); \"]},{\"header\":\"发布消息\",\"slug\":\"发布消息\",\"contents\":[\"WeakReferenceMessenger.Default.Send(new HiMessenger(\\\"Hi,I'm functionMC.I come from China.\\\")); \"]}]},\"/articles/maui/maui-blazorwebview-hunhekaifa.html\":{\"title\":\"基于BlazorWebView的混合开发\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"混合开发的概念是相对与原生开发来说的：App 不直接运行原生程序，而是在原生程序中运行一个 Web 程序，原生程序中包含 Web 运行时，用于承载 Web 页面。暂且将原生应用称之为 Web 容器，Web 容器应该能让 JavaScript 代码与原生平台的代码交互，互相调用，同时为上层提供交互逻辑，例如导航，事件，Cookie，刷新等内容。\",\"本章我们将讲解如何利用 MAUI 中的 BlazorWebView 控件实现 MAUI + VUE 混合开发。\"]},{\"header\":\"创建项目\",\"slug\":\"创建项目\",\"contents\":[]},{\"header\":\"创建 .NET MAUI 应用\",\"slug\":\"创建-net-maui-应用\",\"contents\":[\"创建 .NET MAUI 应用\",\"为项目命名\",\"选择框架\"]},{\"header\":\"修改项目文件\",\"slug\":\"修改项目文件\",\"contents\":[\"右键项目-编辑项目文件\",\"编辑项目文件\",\"Microsoft.NET.Sdk 改为 Microsoft.NET.Sdk.Razor\",\"Microsoft.NET.Sdk\",\"Microsoft.NET.Sdk.Razor\",\"保存修改后会自动引入所需的包\",\"自动引入相关包\"]},{\"header\":\"项目改造\",\"slug\":\"项目改造\",\"contents\":[]},{\"header\":\"新建 wwwroot 文件夹\",\"slug\":\"新建-wwwroot-文件夹\",\"contents\":[\"这个文件夹将是混合开发 Web 部分的根目录，这个名称不能随便定义。\",\"创建 wwwroot 文件夹\"]},{\"header\":\"新建 _Imports.razor 文件\",\"slug\":\"新建-imports-razor-文件\",\"contents\":[\"创建 _Imports.razor 文件并引用相关命名空间\",\"创建 _Imports.razor 文件\",\"@using System.Net.Http @using Microsoft.AspNetCore.Components.Forms @using Microsoft.AspNetCore.Components.Routing @using Microsoft.AspNetCore.Components.Web @using Microsoft.AspNetCore.Components.Web.Virtualization @using Microsoft.JSInterop @using MauiVueDemo \"]},{\"header\":\"新建 Main.razor 文件\",\"slug\":\"新建-main-razor-文件\",\"contents\":[\"新建 Main.razor 文件并创建一个 Test 方法用于测试。\",\"创建 Main.razor 文件\",\"@inject IJSRuntime JSRuntime @code { [JSInvokable] public static Task<string> Test() { return Task.FromResult(\\\"测试通过啦！\\\"); } } \"]},{\"header\":\"MauiProgram 修改\",\"slug\":\"mauiprogram-修改\",\"contents\":[\"添加 MauiBlazorWebView 服务及调试工具\",\"using Microsoft.Extensions.Logging; namespace MauiVueDemo; public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp<App>() .ConfigureFonts(fonts => { fonts.AddFont(\\\"OpenSans-Regular.ttf\\\", \\\"OpenSansRegular\\\"); fonts.AddFont(\\\"OpenSans-Semibold.ttf\\\", \\\"OpenSansSemibold\\\"); }); builder.Services.AddMauiBlazorWebView(); #if DEBUG builder.Logging.AddDebug(); builder.Services.AddBlazorWebViewDeveloperTools(); #endif return builder.Build(); } } \"]},{\"header\":\"MainPage 修改\",\"slug\":\"mainpage-修改\",\"contents\":[]},{\"header\":\"创建 Vue 项目\",\"slug\":\"创建-vue-项目\",\"contents\":[\"使用 vue init webpack maui-vue 命令创建名为 maui-vue 的项目\",\"创建 Vue 项目\"]},{\"header\":\"Vue 项目改造\",\"slug\":\"vue-项目改造\",\"contents\":[]},{\"header\":\"index.html 修改\",\"slug\":\"index-html-修改\",\"contents\":[\"新增如下代码\",\"<!DOCTYPE html> <html> <head> <meta charset=\\\"utf-8\\\"> <meta name=\\\"viewport\\\" content=\\\"width=device-width,initial-scale=1.0\\\"> <title>maui-vue</title> </head> <body> <div id=\\\"app\\\"></div> <div id=\\\"blazorApp\\\" style=\\\"display: none;\\\">初始化服务用的</div> <script src=\\\"_framework/blazor.webview.js\\\" autostart=\\\"false\\\"></script> </body> </html> \",\"<div id=\\\"blazorApp\\\" style=\\\"display: none;\\\">初始化服务用的</div> 对应 MAUI 项目中 MainPage.xaml 页面中的 BlazorWebView.RootComponent.Selector 属性\",\"<script src=\\\"_framework/blazor.webview.js\\\" autostart=\\\"false\\\"></script> 是BlazorWebView用来注册C#交互的，不可以缺少。\"]},{\"header\":\"HelloWorld.vue 修改\",\"slug\":\"helloworld-vue-修改\",\"contents\":[\"本项目中 HelloWorld.vue 为 Vue 项目的默认页面，不同版本创建的 Vue 项目默认页面可能不同。\",\"DotNet 对象是 MAUI Blazor 中注入的交互操作对象，此处我们定义了一个Test方法调用C#中的方法并将返回值展示在页面中\",\"HelloWorld.vue 改造\",\"<template> <div class=\\\"hello\\\"> <h1>{{ msg }}</h1> <div> <button @click=\\\"Test\\\">测试调用C#代码</button> </div> </div> </template> <script> export default { name: 'HelloWorld', data () { return { msg: 'Welcome to Your Vue.js App' } }, methods:{ async Test(){ await DotNet.invokeMethodAsync(\\\"MauiVueDemo\\\",\\\"Test\\\") .then(res=>{ this.msg = res }) } } } </script> <!-- Add \\\"scoped\\\" attribute to limit CSS to this component only --> <style scoped> h1, h2 { font-weight: normal; } ul { list-style-type: none; padding: 0; } li { display: inline-block; margin: 0 10px; } a { color: #42b983; } </style> \"]},{\"header\":\"打包 Vue 项目\",\"slug\":\"打包-vue-项目\",\"contents\":[\"通过 yarn build 命令打包项目\",\"打包项目\"]},{\"header\":\"迁移 Vue 项目打包文件\",\"slug\":\"迁移-vue-项目打包文件\",\"contents\":[\"Vue 项目默认打包路径为 ./dist，拷贝 dist 文件夹下的所有文件至 MAUI 项目的 wwwroot 文件夹下。\"]},{\"header\":\"启动 MAUI 项目\",\"slug\":\"启动-maui-项目\",\"contents\":[\"启动 MAUI 项目\",\"点击 [测试调用C#代码] 按钮\"]}]},\"/articles/maui/maui-web-hunhekaifa-fanganfenxi.html\":{\"title\":\"MAUI-WEB混合开发方案分析\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"此文章将向大家分析 MAUI-VUE 混合开发的三种方案：\",\"MAUI原生方案、Web嵌套方案、MAUI原生+Web嵌套方案\",\"三种方案各自的优点及缺点和潜在问题。\"]},{\"header\":\"MAUI原生方案\",\"slug\":\"maui原生方案\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点\",\"contents\":[\"MAUI 中使用的控件均为平台原生 UI，性能和兼容性比较好\",\"MAUI 中提供了丰富的与平台交互的 API，可以直接通过这些 API 来访问平台中的大部分功能\",\"相对于混合开发，原生开发的程序复杂度更低，有利于提高开发效率\",\"有利于保持应用 UI 呈现样式的统一\"]},{\"header\":\"缺点及潜在问题\",\"slug\":\"缺点及潜在问题\",\"contents\":[\"对于部分 UI 控件的界面自定义支持不完善，可能难以实现预期效果\",\"对于页面结构比较复杂的页面，比如多层嵌套页面可能会造成渲染卡顿\",\"每次更新都需要重新打包发布，需要用户重新安装新版应用\",\"存在一定的学习成本，一定程度上会影响开发效率\"]},{\"header\":\"问题举例\",\"slug\":\"问题举例\",\"contents\":[\".NET MAUI 对于涉及平台的一些功能的支持并不完整，进而会给UI设计中的一些效果实现造成困难，部分举例说明如下：\"]},{\"header\":\"统一的状态栏\",\"slug\":\"统一的状态栏\",\"contents\":[\"统一的状态栏\",\"设计要求： 设备状态栏 和 应用程序标题栏 保持背景统一\",\"是否能实现： 否——仅可实现纯色背景的统一\",\"原因： 应用的标题栏样式的控制属于应用内的范畴，我们可以做到高度的定制化，但是平台的状态栏控制是属于平台层面的，MAUI对平台API的封装提供了入口支持对状态栏进行一些简单的设置，但是无法做到和应用内标题栏使用统一连续的背景图片。\"]},{\"header\":\"选取器\",\"slug\":\"选取器\",\"contents\":[\"选取器\",\"日期选取器\",\"时间选取器\",\"设计要求： 在APP中实现如图所示的各种选取器效果\",\"是否能实现： 否——暂时可实现近似效果\",\"原因： MAUI仅提供了默认的下拉框和时间选取器控件，默认控件与UI设计的差异非常大且不支持样式的自定义设置，若想实现设计效果则需要利用MAUI的其它现有组件进行组合开发，但这并不能完全实现UI设计的效果，例如在MAUI中并没有现成的组件支持上下滑动选项来选取内容，所以通过上下拖动的方式来操作的选取器不易实现\"]},{\"header\":\"Web 嵌套方案\",\"slug\":\"web-嵌套方案\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点-1\",\"contents\":[\"基于 H5 和 Vue 开发的 Web 页面能很好的进行样式的自定义开发，从而实现复杂的 UI 效果\",\"程序更新只需要在服务端发布，客户端无需任何更改\",\"相较于原生开发，H5 和 Vue 的学低成本更低，进而提高开发效率\"]},{\"header\":\"缺点及潜在问题\",\"slug\":\"缺点及潜在问题-1\",\"contents\":[\"所有页面加载均需要请求服务器，因此对网络环境要求较高，可能导致页面加载缓慢甚至加载失败\",\"在 Web 中访问平台中的功能时可能存在困难，还需进一步验证\",\"纯 Web 嵌套的方案可能会给未来的程序开发埋下隐患，造成一些不可预知的问题\"]},{\"header\":\"MAUI 原生 + Web 嵌套方案\",\"slug\":\"maui-原生-web-嵌套方案\",\"contents\":[]},{\"header\":\"优点\",\"slug\":\"优点-2\",\"contents\":[\"继承了上述两种方案各自的优点，可以灵活组合来实现需求\",\"可以灵活才用其中的一种方案来规避另一种方案可能会造成的问题\"]},{\"header\":\"缺点及潜在问题\",\"slug\":\"缺点及潜在问题-2\",\"contents\":[\"学习成本及程序复杂度都比较高，一定程度影响开发效率\",\"原生页面和 Web 页面的 UI 风格保持一致可能存在一定困难\",\"兼容性及稳定性可能不如单一技术方案\"]}]},\"/articles/maui/maui-webview-hunhekaifa.html\":{\"title\":\"基于自定义WebView控件的混合开发\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"混合开发的概念是相对与原生开发来说的：App 不直接运行原生程序，而是在原生程序中运行一个 Web 程序，原生程序中包含 Web 运行时，用于承载 Web 页面。暂且将原生应用称之为 Web 容器，Web 容器应该能让 JavaScript 代码与原生平台的代码交互，互相调用，同时为上层提供交互逻辑，例如导航，事件，Cookie，刷新等内容。\",\"本章我们将讲解如何通过自定义 MAUI 中的 WebView 控件实现 MAUI + Web 混合开发。\"]},{\"header\":\"自定义 HybridWebView 控件\",\"slug\":\"自定义-hybridwebview-控件\",\"contents\":[\"基于 WebView 使用处理程序创建自定义 HybridWebView 控件。\",\"本章节代码来自开源项目：MauiCSharpInteropWebView\"]},{\"header\":\"新建 .NET MAUI 类库项目\",\"slug\":\"新建-net-maui-类库项目\",\"contents\":[\"新建 .NET MAUI 类库项目，并命名为 MauiCSharpInteropWebView。\",\"新建名为 MauiCSharpInteropWebView 的 .NET MAUI 类库项目\"]},{\"header\":\"创建 HybridWebView 跨平台控件\",\"slug\":\"创建-hybridwebview-跨平台控件\",\"contents\":[\"HybridWebView 类作为跨平台控件需派生字自 WebView 类。\",\"using System.Text.Json; namespace HybridWebView { public partial class HybridWebView : WebView { public string MainFile { get; set; } /// <summary> /// 包含web应用程序内容的应用程序“原始”资产资源中的路径。例如，如果文件位于“project folder/Resources/Raw/hybrid_root”中，则将该属性设置为“hybrid_root” /// </summary> public string HybridAssetRoot { get; set; } /// <summary> /// JavaScript方法调用的目标对象。当从JavaScript发送“invoke”消息时，被调用的方法将位于该对象上，并且任何指定的参数都将被传入。 /// </summary> public object JSInvokeTarget { get; set; } public event EventHandler<HybridWebViewRawMessageReceivedEventArgs> RawMessageReceived; protected override void OnHandlerChanged() { base.OnHandlerChanged(); InitializeHybridWebView(); } partial void InitializeHybridWebView(); /// <summary> /// 调用名为< paramref name=\\\"methodName\\\"/>的JavaScript方法，并通过对每个参数值进行JSON编码，选择性地传入由< paramref name=\\\"paramValues\\\"/>指定的参数值。 /// </summary> /// <param name=\\\"methodName\\\">要调用的JavaScript方法的名称</param> /// <param name=\\\"paramValues\\\">通过对每个对象进行JSON编码，将对象的可选数组传递给JavaScript方法</param> /// <returns>包含被调用方法的返回值的字符串</returns> public async Task<string> InvokeJsMethodAsync(string methodName, params object[] paramValues) { if (string.IsNullOrEmpty(methodName)) { throw new ArgumentException($\\\"The method name cannot be null or empty.\\\", nameof(methodName)); } return await EvaluateJavaScriptAsync($\\\"{methodName}({(paramValues == null ? string.Empty : string.Join(\\\", \\\", paramValues.Select(v => JsonSerializer.Serialize(v))))})\\\"); } /// <summary> /// 调用名为< paramref name=\\\"methodName\\\"/>的JavaScript方法，并通过对每个参数值进行JSON编码，选择性地传入由< paramref name=\\\"paramValues\\\"/>指定的参数值 /// </summary> /// <typeparam name=\\\"TReturnType\\\">要从JSON反序列化的返回值的类型</typeparam> /// <param name=\\\"methodName\\\">要调用的JavaScript方法的名称</param> /// <param name=\\\"paramValues\\\">通过对每个对象进行JSON编码，将对象的可选数组传递给JavaScript方法</param> /// <returns>包含被调用方法的返回值的< typeparamref name = \\\" TReturnType \\\"/>类型的对象</returns> public async Task<TReturnType> InvokeJsMethodAsync<TReturnType>(string methodName, params object[] paramValues) { var stringResult = await InvokeJsMethodAsync(methodName, paramValues); return JsonSerializer.Deserialize<TReturnType>(stringResult); } public virtual void OnMessageReceived(string message) { var messageData = JsonSerializer.Deserialize<WebMessageData>(message); switch (messageData.MessageType) { case 0: // \\\"raw\\\" message (just a string) RawMessageReceived?.Invoke(this, new HybridWebViewRawMessageReceivedEventArgs(messageData.MessageContent)); break; case 1: // \\\"invoke\\\" message var invokeData = JsonSerializer.Deserialize<JSInvokeMethodData>(messageData.MessageContent); InvokeDotNetMethod(invokeData); break; default: throw new InvalidOperationException($\\\"未知的消息类型: {messageData.MessageType}. 消息内容: {messageData.MessageContent}\\\"); } } private void InvokeDotNetMethod(JSInvokeMethodData invokeData) { if (JSInvokeTarget is null) { throw new NotImplementedException($\\\"{nameof(JSInvokeTarget)}属性必须有一个值，以便从JavaScript调用.NET方法。\\\"); } var invokeMethod = JSInvokeTarget.GetType().GetMethod(invokeData.MethodName, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.InvokeMethod); if (invokeData.ParamValues != null && invokeMethod.GetParameters().Length != invokeData.ParamValues.Length) { throw new InvalidOperationException($\\\"{nameof(JSInvokeTarget)}的方法{invokeData.MethodName} ({invokeMethod.GetParameters().Length})上的参数数量与从JavaScript代码({invokeData.ParamValues.Length})传递的值的数量不匹配。\\\"); } var paramObjectValues = invokeData.ParamValues? .Zip(invokeMethod.GetParameters(), (s, p) => JsonSerializer.Deserialize(s, p.ParameterType)) .ToArray(); var returnValue = invokeMethod.Invoke(JSInvokeTarget, paramObjectValues); } private sealed class JSInvokeMethodData { public string MethodName { get; set; } public string[] ParamValues { get; set; } } private sealed class WebMessageData { public int MessageType { get; set; } public string MessageContent { get; set; } } internal static async Task<string> GetAssetContentAsync(string assetPath) { using var stream = await GetAssetStreamAsync(assetPath); if (stream == null) { return null; } using var reader = new StreamReader(stream); var contents = reader.ReadToEnd(); return contents; } internal static async Task<Stream> GetAssetStreamAsync(string assetPath) { if (!await FileSystem.AppPackageFileExistsAsync(assetPath)) { return null; } return await FileSystem.OpenAppPackageFileAsync(assetPath); } } } \"]},{\"header\":\"创建 HybridWebViewHandler 处理程序\",\"slug\":\"创建-hybridwebviewhandler-处理程序\",\"contents\":[\"HybridWebViewHandler 类作为 HybridWebView 控件的处理程序需派生自 WebViewHandler 处理程序。\",\"using Microsoft.Maui.Handlers; namespace HybridWebView { public partial class HybridWebViewHandler : WebViewHandler { public static IPropertyMapper<IWebView, IWebViewHandler> HybridWebViewMapper = new PropertyMapper<IWebView, IWebViewHandler>(WebViewHandler.Mapper) { #if __ANDROID__ [nameof(Android.Webkit.WebViewClient)] = MapHybridWebViewClient, #endif }; public HybridWebViewHandler() : base(HybridWebViewMapper, CommandMapper) { } public HybridWebViewHandler(IPropertyMapper? mapper = null, CommandMapper? commandMapper = null) : base(mapper ?? HybridWebViewMapper, commandMapper ?? CommandMapper) { } #if ANDROID public static void MapHybridWebViewClient(IWebViewHandler handler, IWebView webView) { if (handler is HybridWebViewHandler platformHandler) { var webViewClient = new AndroidHybridWebViewClient(platformHandler); handler.PlatformView.SetWebViewClient(webViewClient); // TODO: There doesn't seem to be a way to override MapWebViewClient() in maui/src/Core/src/Handlers/WebView/WebViewHandler.Android.cs // in such a way that it knows of the custom MauiWebViewClient that we're creating. So, we use private reflection to set it on the // instance. We might end up duplicating WebView/BlazorWebView anyway, in which case we wouldn't need this workaround. var webViewClientField = typeof(WebViewHandler).GetField(\\\"_webViewClient\\\", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.FlattenHierarchy); webViewClientField.SetValue(handler, webViewClient); } } #endif } } \"]},{\"header\":\"创建 HybridWebViewRawMessageReceivedEventArgs 类\",\"slug\":\"创建-hybridwebviewrawmessagereceivedeventargs-类\",\"contents\":[\"namespace HybridWebView { public class HybridWebViewRawMessageReceivedEventArgs : EventArgs { public HybridWebViewRawMessageReceivedEventArgs(string message) { Message = message; } public string Message { get; } } } \"]},{\"header\":\"创建 HybridWebViewServiceCollectionExtensions 类\",\"slug\":\"创建-hybridwebviewservicecollectionextensions-类\",\"contents\":[\"using HybridWebView; namespace Microsoft.Extensions.DependencyInjection { public static class HybridWebViewServiceCollectionExtensions { public static void AddHybridWebView(this IServiceCollection services) { services.ConfigureMauiHandlers(static handlers => handlers.AddHandler<HybridWebView.HybridWebView, HybridWebViewHandler>()); } } } \"]},{\"header\":\"创建平台控件\",\"slug\":\"创建平台控件\",\"contents\":[\"为处理程序创建映射器后，必须在所有平台上提供处理程序实现。 这可以通过在 Platforms 文件夹的子文件夹中添加分部类处理程序实现来实现。 或者，可以将项目配置为支持基于文件名的多目标或基于文件夹的多目标，或同时支持这两者。\"]},{\"header\":\"Android 平台控件\",\"slug\":\"android-平台控件\",\"contents\":[]},{\"header\":\"创建 AndroidHybridWebViewClient 类\",\"slug\":\"创建-androidhybridwebviewclient-类\",\"contents\":[\"using Android.Webkit; using Microsoft.Maui.Platform; using System.Text; using AWebView = Android.Webkit.WebView; namespace HybridWebView { public class AndroidHybridWebViewClient : MauiWebViewClient { private readonly HybridWebViewHandler _handler; public AndroidHybridWebViewClient(HybridWebViewHandler handler) : base(handler) { _handler = handler; } public override WebResourceResponse ShouldInterceptRequest(AWebView view, IWebResourceRequest request) { if (new Uri(request.Url.ToString()) is Uri uri && HybridWebView.AppOriginUri.IsBaseOf(uri)) { var relativePath = HybridWebView.AppOriginUri.MakeRelativeUri(uri).ToString().Replace('/', '\\\\\\\\'); string contentType; if (string.IsNullOrEmpty(relativePath)) { relativePath = ((HybridWebView)_handler.VirtualView).MainFile; contentType = \\\"text/html\\\"; } else { var requestExtension = Path.GetExtension(relativePath); contentType = requestExtension switch { \\\".htm\\\" or \\\".html\\\" => \\\"text/html\\\", \\\".js\\\" => \\\"application/javascript\\\", \\\".css\\\" => \\\"text/css\\\", _ => \\\"text/plain\\\", }; } var assetPath = Path.Combine(((HybridWebView)_handler.VirtualView).HybridAssetRoot, relativePath); var contentStream = PlatformOpenAppPackageFile(assetPath); if (contentStream is null) { var notFoundContent = \\\"Resource not found (404)\\\"; var notFoundByteArray = Encoding.UTF8.GetBytes(notFoundContent); var notFoundContentStream = new MemoryStream(notFoundByteArray); return new WebResourceResponse(\\\"text/plain\\\", \\\"UTF-8\\\", 404, \\\"Not Found\\\", GetHeaders(\\\"text/plain\\\"), notFoundContentStream); } else { // TODO: We don't know the content length because Android doesn't tell us. Seems to work without it! return new WebResourceResponse(contentType, \\\"UTF-8\\\", 200, \\\"OK\\\", GetHeaders(contentType), contentStream); } } else { return base.ShouldInterceptRequest(view, request); } } Stream PlatformOpenAppPackageFile(string filename) { filename = FileSystemUtils.NormalizePath(filename); try { return _handler.Context.Assets.Open(filename); } catch (Java.IO.FileNotFoundException) { return null; } } static partial class FileSystemUtils { public static string NormalizePath(string filename) => filename .Replace('\\\\\\\\', Path.DirectorySeparatorChar) .Replace('/', Path.DirectorySeparatorChar); } private protected static IDictionary<string, string> GetHeaders(string contentType) => new Dictionary<string, string> { { \\\"Content-Type\\\", contentType }, }; } } \"]},{\"header\":\"创建 HybridWebView.Android 类\",\"slug\":\"创建-hybridwebview-android-类\",\"contents\":[\"using Android.Webkit; using Java.Interop; using AWebView = Android.Webkit.WebView; namespace HybridWebView { partial class HybridWebView { // Using an IP address means that WebView2 doesn't wait for any DNS resolution, // making it substantially faster. Note that this isn't real HTTP traffic, since // we intercept all the requests within this origin. internal static readonly string AppHostAddress = \\\"0.0.0.0\\\"; /// <summary> /// Gets the application's base URI. Defaults to <c>https://0.0.0.0/</c> /// </summary> internal static readonly string AppOrigin = $\\\"https://{AppHostAddress}/\\\"; internal static readonly Uri AppOriginUri = new(AppOrigin); private HybridWebViewJavaScriptInterface _javaScriptInterface; async partial void InitializeHybridWebView() { var awv = (AWebView)Handler.PlatformView; awv.Settings.JavaScriptEnabled = true; _javaScriptInterface = new HybridWebViewJavaScriptInterface(this); awv.AddJavascriptInterface(_javaScriptInterface, \\\"hybridWebViewHost\\\"); awv.LoadUrl(AppOrigin); } private sealed class HybridWebViewJavaScriptInterface : Java.Lang.Object { private readonly HybridWebView _hybridWebView; public HybridWebViewJavaScriptInterface(HybridWebView hybridWebView) { _hybridWebView = hybridWebView; } [JavascriptInterface] [Export(\\\"sendMessage\\\")] public void SendMessage(string message) { _hybridWebView.OnMessageReceived(message); } } } } \",\"相关信息\",\"HybridWebView 项目除了项目引用的方式外也可以打包为 NuGet 包，方便其他项目的引用。\"]},{\"header\":\"自定义 HybridWebView 控件使用\",\"slug\":\"自定义-hybridwebview-控件使用\",\"contents\":[]},{\"header\":\"创建 .NET MAUI 应用\",\"slug\":\"创建-net-maui-应用\",\"contents\":[\"略\"]},{\"header\":\"添加 HybridWebView 项目引用\",\"slug\":\"添加-hybridwebview-项目引用\",\"contents\":[\"添加 HybridWebView 项目引用\"]},{\"header\":\"新建 Web 文件\",\"slug\":\"新建-web-文件\",\"contents\":[\"在 Resources/Raw 路径下新建 hybrid_root 文件夹用于存放 Web 文件。\"]},{\"header\":\"新建 rawmessages.html 文件\",\"slug\":\"新建-rawmessages-html-文件\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\"> <head> <meta charset=\\\"utf-8\\\" /> <title></title> <script> function SendToJs(message) { Log('收到来自DotNet的消息: ' + message); } function SendRawMessage() { var value = CoolJSLibrary(document.getElementById('valueInput').value); HybridWebView.SendRawMessageToDotNet(value); } </script> <script src=\\\"js/HybridWebView.js\\\"></script> <script src=\\\"js/extra_code.js\\\"></script> <link href=\\\"styles/my-styles.css\\\" rel=\\\"stylesheet\\\" /> </head> <body> <h1>基于WebView的混合页面demo: 原始消息</h1> <div class=\\\"navBar\\\"> 原始消息 | <a href=\\\"/methodinvoke.html\\\">方法调用</a> </div> <div> 原始消息作为原始字符串从JavaScript发送到.NET，无需进一步处理。 </div> <div> 消息 <input type=\\\"text\\\" id=\\\"valueInput\\\" value=\\\"JS向.NET发送消息\\\" /> <button type=\\\"button\\\" onclick=\\\"SendRawMessage()\\\">向.NET发送原始消息</button> </div> <h2> JS消息日志: </h2> <div> <textarea id=\\\"messageLog\\\" style=\\\"width: 90%; height: 10em;\\\"></textarea> </div> <script> // Notify .NET code which page we're on HybridWebView.SendRawMessageToDotNet(\\\"page:1\\\"); </script> </body> </html> \"]},{\"header\":\"新建 methodinvoke.html 文件\",\"slug\":\"新建-methodinvoke-html-文件\",\"contents\":[\"<!DOCTYPE html> <html lang=\\\"en\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\"> <head> <meta charset=\\\"utf-8\\\" /> <title></title> <script> function JsAddNumbers(a, b) { var sum = a + b; Log('用参数 (' + a + ', ' + b + ')请求.NET, 并返回: ' + sum); return sum; } function CallDotNetMethod() { Log('使用参数请求.NET'); HybridWebView.SendInvokeMessageToDotNet(\\\"CallMeFromScript\\\", [\\\"消息来自JS\\\", 987]); } </script> <script src=\\\"js/HybridWebView.js\\\"></script> <script src=\\\"js/extra_code.js\\\"></script> <link href=\\\"styles/my-styles.css\\\" rel=\\\"stylesheet\\\" /> </head> <body> <h1>基于WebView的混合页面demo: 方法调用</h1> <div class=\\\"navBar\\\"> <a href=\\\"/rawmessages.html\\\">原始消息</a> | 方法调用 </div> <div> Methods can be invoked in both directions: <ul> <li>JavaScript可以通过调用 <code>HybridWebView.SendInvokeMessageToDotNet(\\\"DotNetMethodName\\\", [\\\"param1\\\", 123]);</code> 调用.NET方法</li> <li>.NET可以通过调用 <code>var sum = await webView.InvokeJsMethodAsync<int>(\\\"JsAddNumbers\\\", 123, 456);</code> 方法调用JS方法</li> </ul> </div> <div> <button type=\\\"button\\\" onclick=\\\"CallDotNetMethod()\\\">使用参数请求.NET</button> </div> <h2> JS消息日志: </h2> <div> <textarea id=\\\"messageLog\\\" style=\\\"width: 90%; height: 10em;\\\"></textarea> </div> <script> // Notify .NET code which page we're on HybridWebView.SendRawMessageToDotNet(\\\"page:2\\\"); </script> </body> </html> \"]},{\"header\":\"新建相关 JS 脚本\",\"slug\":\"新建相关-js-脚本\",\"contents\":[]},{\"header\":\"新建相关CSS样式\",\"slug\":\"新建相关css样式\",\"contents\":[\"在 Resources/Raw/hybrid_root/styles 路径下新建 my-styles.css 文件\",\"body { background-color: beige; font-family: Arial; padding: 1em; } h1 { font-weight: 600; padding-left: .5em; } h2 { font-size: 1.1em; font-weight: 500; padding-left: .5em; } div{ margin-top: .5em; } .navBar { padding: .5em; margin: .5em; border: 1px solid darkgray; } \"]},{\"header\":\"MauiProgram 修改\",\"slug\":\"mauiprogram-修改\",\"contents\":[\"对 MauiProgram 文件修改，添加对应的自定义控件服务\",\"using Microsoft.Extensions.Logging; namespace MauiVueDemo; public static class MauiProgram { public static MauiApp CreateMauiApp() { var builder = MauiApp.CreateBuilder(); builder .UseMauiApp<App>() .ConfigureFonts(fonts => { fonts.AddFont(\\\"OpenSans-Regular.ttf\\\", \\\"OpenSansRegular\\\"); fonts.AddFont(\\\"OpenSans-Semibold.ttf\\\", \\\"OpenSansSemibold\\\"); }); #if DEBUG builder.Logging.AddDebug(); #endif builder.Services.AddHybridWebView(); return builder.Build(); } } \"]},{\"header\":\"MainPage 修改\",\"slug\":\"mainpage-修改\",\"contents\":[\"对 MainPage 页面进行修改，使其呈现 HybridWebView 控件的效果。\"]},{\"header\":\"交互效果\",\"slug\":\"交互效果\",\"contents\":[\"原始消息交互\",\"方法调用交互\"]}]},\"/articles/maui/rumen.html\":{\"title\":\"快速入门\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"快速入门\"]},{\"header\":\"什么是 .NET MAUI？\",\"slug\":\"什么是-net-maui\",\"contents\":[\".NET 多平台应用 UI (.NET MAUI) 是一个跨平台框架，用于使用 C# 和 XAML 创建本机移动和桌面应用\",\"使用 .NET MAUI，可从单个共享代码库开发可在 Android、iOS、macOS 和 Windows 上运行的应用\",\"。。。。。。\",\"简而言之 —— .NET MAUI 就是一个跨平台的前端开发框架\"]},{\"header\":\"安装\",\"slug\":\"安装\",\"contents\":[\"参考 官方文档\"]},{\"header\":\"创建首个应用\",\"slug\":\"创建首个应用\",\"contents\":[\"参考 官方文档\"]},{\"header\":\"项目结构\",\"slug\":\"项目结构\",\"contents\":[\"项目结构\",\"相关信息\",\"Platform： 包含了不同平台的特定内容，针对不同平台的一些特殊逻辑要写在这里\",\"Resources： 静态资源，应用所需的静态资源一般存放在该文件夹下，可以在代码中直接引用\",\"App.xaml： 该文件中存放了适用于应用全局的资源字典。资源字典是 .NET MAUI 应用使用的资源的存储库。参见微软官方文档对资源字典的介绍。\",\"App.xaml.cs： 该文件中设置了 APP 启动后会第一个加载的页面，通常是一个 Shell。通过设置 MainPage 属性来设置应用第一个打开的页面。\",\"AppShell.xaml： 用于定义Shell(壳子)。可支持定义多个Shell，并对其进行设置。\",\"MainPage.xaml： 是一个ContentPage内容页。ContentPage 是 MAUI 中一个基本的 Page，用于构建 UI 界面。\",\"MauiProgram.cs： 项目入口，用于构建 MAUI APP。开发者注册字体，进行依赖注入都要在这个文件中完成\"]}]},\"/articles/maui/shizhan.html\":{\"title\":\"编码实战\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"编码实战\"]},{\"header\":\"目标效果\",\"slug\":\"目标效果\",\"contents\":[\"首页\",\"内容页\",\"图标素材库：https://www.iconfont.cn/\"]},{\"header\":\"结构划分\",\"slug\":\"结构划分\",\"contents\":[\"首页划分\",\"内容页划分\"]},{\"header\":\"内容页\",\"slug\":\"内容页\",\"contents\":[\"内容页主要有三个板块构成，每个板块内部有属于该板块的菜单项，单纯从显示效果上看有很多控件可以实现类似的效果，比如 Grid、HorizontalStackLayout、VerticalStackLayout、FlexLayout等。但是通常像这样的菜单结构并不是一成不变的，我们的板块或者板块内的菜单随时都可能有增减，或者根据权限有选择性的展示，这就意味着该页面的结构和内容是动态的，这时候我们就需要从后端获取当前要展示的菜单数据，并且选择那些支持动态渲染的控件来呈现在页面上。\"]},{\"header\":\"创建Model\",\"slug\":\"创建model\",\"contents\":[\"namespace Mediinfo_MAUI_Demo.Models; public class MenuGroupModel { public string Name { get; set; } public List<Menu> Menus { get; set; } } public class Menu { public string Name { get; set; } public string Path { get; set; } public Color StartPointColor { get; set; } public Color EndPointColor { get; set; } public ImageSource ImageSource { get; set; } } \"]},{\"header\":\"填充数据\",\"slug\":\"填充数据\",\"contents\":[\"using CommunityToolkit.Mvvm.ComponentModel; using Mediinfo_MAUI_Demo.Models; namespace Mediinfo_MAUI_Demo.ViewModels; public partial class MainPageViewModel : ObservableObject { public List<MenuGroupModel> MenuGroups { get; set; } = new(); public MainPageViewModel() { MenuGroups = new() { new MenuGroupModel { Name= \\\"医嘱闭环\\\", Menus=new() { new Menu { Name=\\\"摆药核对\\\", Path=\\\"BaiYaoHDView\\\", ImageSource=\\\"baiyaohedui.svg\\\", StartPointColor=Color.FromArgb(\\\"#f7c563\\\"), EndPointColor=Color.FromArgb(\\\"#ee9f4a\\\") }, new Menu { Name = \\\"加药核对\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"jiayaohedui.svg\\\", StartPointColor = Color.FromArgb(\\\"#399afa\\\"), EndPointColor = Color.FromArgb(\\\"#66c7ff\\\") }, new Menu { Name = \\\"皮试处理\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"pishichuli.svg\\\", StartPointColor = Color.FromArgb(\\\"#61b8c0\\\"), EndPointColor = Color.FromArgb(\\\"#8dd9af\\\") }, new Menu { Name = \\\"医嘱查询\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"yizhuchaxun.svg\\\", StartPointColor = Color.FromArgb(\\\"#6c90f2\\\"), EndPointColor = Color.FromArgb(\\\"#88b6fb\\\") }, new Menu { Name = \\\"停用处理\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"baiyaohedui.svg\\\", StartPointColor = Color.FromArgb(\\\"#ef785a\\\"), EndPointColor = Color.FromArgb(\\\"#efa079\\\") } } }, new MenuGroupModel { Name=\\\"护理记录\\\", Menus=new() { new Menu { Name = \\\"批量体征\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"piliangtizheng.svg\\\", StartPointColor = Color.FromArgb(\\\"#61b8c0\\\"), EndPointColor = Color.FromArgb(\\\"#8dd9af\\\") }, new Menu { Name = \\\"批量血糖\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"piliangxuetang.svg\\\", StartPointColor = Color.FromArgb(\\\"#ef785a\\\"), EndPointColor = Color.FromArgb(\\\"#efa079\\\") } } }, new MenuGroupModel { Name=\\\"床旁查询\\\", Menus = new() { new Menu { Name = \\\"转科交接\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"zhuankejiaojie.svg\\\", StartPointColor = Color.FromArgb(\\\"#f7c563\\\"), EndPointColor = Color.FromArgb(\\\"#ee9f4a\\\") }, new Menu { Name = \\\"手术交接\\\", Path=\\\"BaiYaoHDView\\\", ImageSource = \\\"shoushujiaojie.svg\\\", StartPointColor = Color.FromArgb(\\\"#399afa\\\"), EndPointColor = Color.FromArgb(\\\"#66c7ff\\\") } } } }; } } \"]},{\"header\":\"绑定数据源\",\"slug\":\"绑定数据源\",\"contents\":[]},{\"header\":\"页面呈现\",\"slug\":\"页面呈现\",\"contents\":[]},{\"header\":\"菜单分组\",\"slug\":\"菜单分组\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" xmlns:model=\\\"clr-namespace:Mediinfo_MAUI_Demo.Models\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" x:DataType=\\\"viewmodel:MainPageViewModel\\\"> <Border StrokeThickness=\\\"0\\\"> <Border.Background> <LinearGradientBrush> <GradientStop Color=\\\"#e6f6ff\\\" Offset=\\\"0.1\\\" /> <GradientStop Color=\\\"Transparent\\\" Offset=\\\"1.0\\\" /> </LinearGradientBrush> </Border.Background> <VerticalStackLayout BindableLayout.ItemsSource=\\\"{Binding MenuGroups}\\\" Spacing=\\\"8\\\" Padding=\\\"8\\\"> <BindableLayout.ItemTemplate> <DataTemplate x:DataType=\\\"model:MenuGroupModel\\\"> <Border Padding=\\\"8\\\" StrokeThickness=\\\"0\\\"> <Border.StrokeShape> <RoundRectangle CornerRadius=\\\"10,10,10,10\\\"/> </Border.StrokeShape> <VerticalStackLayout> <Label HorizontalOptions=\\\"Start\\\" Text=\\\"{Binding Name}\\\" FontSize=\\\"16\\\" HeightRequest=\\\"22\\\" TextColor=\\\"#ff222222\\\" Margin=\\\"4,0,0,0\\\"/> <Label Text=\\\"这里是菜单按钮\\\"/> </VerticalStackLayout> </Border> </DataTemplate> </BindableLayout.ItemTemplate> </VerticalStackLayout> </Border> </ContentPage> \",\"相关信息\",\"Border.Background.LinearGradientBrush 为边框填充一个渐变背景色\",\"Border.VerticalStackLayout.BindableLayout.ItemsSource 将前边准备的数据设置为垂直布局的数据源\",\"Border.VerticalStackLayout.BindableLayout.ItemTemplate 定义子数据外观模板\",\"效果：\",\"菜单分组呈现效果\"]},{\"header\":\"菜单项\",\"slug\":\"菜单项\",\"contents\":[]},{\"header\":\"自定义菜单项控件模板\",\"slug\":\"自定义菜单项控件模板\",\"contents\":[]},{\"header\":\"使用自定义控件呈现分组菜单项\",\"slug\":\"使用自定义控件呈现分组菜单项\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" xmlns:model=\\\"clr-namespace:Mediinfo_MAUI_Demo.Models\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" x:DataType=\\\"viewmodel:MainPageViewModel\\\"> <Border StrokeThickness=\\\"0\\\"> <Border.Background> <LinearGradientBrush> <GradientStop Color=\\\"#e6f6ff\\\" Offset=\\\"0.1\\\" /> <GradientStop Color=\\\"Transparent\\\" Offset=\\\"1.0\\\" /> </LinearGradientBrush> </Border.Background> <VerticalStackLayout BindableLayout.ItemsSource=\\\"{Binding MenuGroups}\\\" Spacing=\\\"8\\\" Padding=\\\"8\\\"> <BindableLayout.ItemTemplate> <DataTemplate x:DataType=\\\"model:MenuGroupModel\\\"> <Border Padding=\\\"8\\\" StrokeThickness=\\\"0\\\"> <Border.StrokeShape> <RoundRectangle CornerRadius=\\\"10,10,10,10\\\"/> </Border.StrokeShape> <VerticalStackLayout> <Label HorizontalOptions=\\\"Start\\\" Text=\\\"{Binding Name}\\\" FontSize=\\\"16\\\" HeightRequest=\\\"22\\\" TextColor=\\\"#ff222222\\\" Margin=\\\"4,0,0,0\\\"/> <CollectionView ItemsSource=\\\"{Binding Menus}\\\" Margin=\\\"0,8,0,0\\\"> <CollectionView.ItemsLayout> <GridItemsLayout Orientation=\\\"Vertical\\\" Span=\\\"4\\\" VerticalItemSpacing=\\\"8\\\"></GridItemsLayout> </CollectionView.ItemsLayout> <CollectionView.ItemTemplate> <DataTemplate x:DataType=\\\"model:Menu\\\"> <controls:MenuButtonControl ImageSource=\\\"{Binding ImageSource}\\\" StartPointColor=\\\"{Binding StartPointColor}\\\" EndPointColor=\\\"{Binding EndPointColor}\\\" Text=\\\"{Binding Name}\\\"> </controls:MenuButtonControl> </DataTemplate> </CollectionView.ItemTemplate> </CollectionView> </VerticalStackLayout> </Border> </DataTemplate> </BindableLayout.ItemTemplate> </VerticalStackLayout> </Border> </ContentPage> \",\"相关信息\",\"CollectionView.ItemsSource 将每个分组下的菜单项List作为数据源绑定\",\"CollectionView.ItemsLayout 定义子数据的布局\",\"CollectionView.ItemTemplate 定义子数据外观模板\",\"效果：\",\"自定义菜单项\"]},{\"header\":\"标题栏\",\"slug\":\"标题栏\",\"contents\":[\"标题栏的结构布局经常是统一的，但文字及颜色可能又会随页面发生改变，所以我们可以将顶部标题栏也封装为一个自定义控件供多个页面使用。\"]},{\"header\":\"创建自定义标题栏控件\",\"slug\":\"创建自定义标题栏控件\",\"contents\":[\"新建 ContentView 文件\"]},{\"header\":\"引入自定义标题栏\",\"slug\":\"引入自定义标题栏\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" xmlns:model=\\\"clr-namespace:Mediinfo_MAUI_Demo.Models\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" x:DataType=\\\"viewmodel:MainPageViewModel\\\"> <Shell.BackgroundColor> <Color>#e6f6ff</Color> </Shell.BackgroundColor> <Shell.TitleView> <controls:MainPageTitleView Title=\\\"病区首页\\\" Text=\\\"消化内科病区\\\"/> </Shell.TitleView> <!--其他代码--> </ContentPage> \",\"效果：\",\"自定义标题栏\"]},{\"header\":\"状态栏\",\"slug\":\"状态栏\",\"contents\":[\"借助 CommunityToolkit.Maui 社区工具包，我们可以对应用中每个页面的状态栏样式进行单独设置。\"]},{\"header\":\"安装社区工具包\",\"slug\":\"安装社区工具包\",\"contents\":[\"在项目中安装 CommunityToolkit.Maui 最新版NuGet包\"]},{\"header\":\"使用社区工具包修改状态栏颜色\",\"slug\":\"使用社区工具包修改状态栏颜色\",\"contents\":[\"以上三种方式效果一致：\",\"状态栏颜色设置\"]},{\"header\":\"动态切换状态栏颜色\",\"slug\":\"动态切换状态栏颜色\",\"contents\":[\"有些需求要求我们的状态栏为不同的页面适配不同的颜色从而保持全局风格的统一，我们可以通过 .NET MAUI Shell 生命周期来实现这个功能。\",\"Shell 应用遵循 .NET MAUI 生命周期，并在页面即将在屏幕上显示时触发事件，当 Disappearing 页面即将从屏幕上消失时触发 Appearing 事件。 这些事件会传播到页面，可以通过重写页面上的 OnAppearing 或 OnDisappearing 方法进行处理。\",\"这里我们可以通过在不同页面重写 OnAppearing 方法的方式去设置状态栏的颜色\"]},{\"header\":\"页面导航\",\"slug\":\"页面导航\",\"contents\":[]},{\"header\":\"创建目标内容页\",\"slug\":\"创建目标内容页\",\"contents\":[\"创建摆药核对的ContentPage页面：BaiYaoHDView.xaml\"]},{\"header\":\"注册路由\",\"slug\":\"注册路由\",\"contents\":[\"在 AppShell.xaml.cs 中注册摆药核对页面的路由\",\"using Mediinfo_MAUI_Demo.Views; namespace Mediinfo_MAUI_Demo; public partial class AppShell : Shell { public AppShell() { InitializeComponent(); Routing.RegisterRoute(nameof(BaiYaoHDView), typeof(BaiYaoHDView)); } } \"]},{\"header\":\"页面跳转\",\"slug\":\"页面跳转\",\"contents\":[]},{\"header\":\"定义跳转事件\",\"slug\":\"定义跳转事件\",\"contents\":[\"using CommunityToolkit.Mvvm.ComponentModel; using Mediinfo.Vela.YiDongHL.App.Models; using System; using System.Collections.Generic; using CommunityToolkit.Mvvm; using CommunityToolkit.Mvvm.Input; namespace Mediinfo.Vela.YiDongHL.App.ViewModels { public partial class MainPageViewModel : ViewModelBase { //其他代码 [RelayCommand] private async Task Tab(Menu menu) { await Shell.Current.GoToAsync(menu.Path); } } } \",\"Shell.Current.GoToAsync() 为MAUI提供的页面跳转方法，入参数为目标页面的路由地址(与注册路由时的地址保持一致)\"]},{\"header\":\"绑定跳转事件\",\"slug\":\"绑定跳转事件\",\"contents\":[\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:controls=\\\"clr-namespace:Mediinfo_MAUI_Demo.Controls\\\" xmlns:model=\\\"clr-namespace:Mediinfo_MAUI_Demo.Models\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.MainPage\\\" x:DataType=\\\"viewmodel:MainPageViewModel\\\" x:Name=\\\"this\\\"> <Shell.BackgroundColor> <Color>#e6f6ff</Color> </Shell.BackgroundColor> <Shell.TitleView> <controls:MainPageTitleView Title=\\\"病区首页\\\" Text=\\\"消化内科病区\\\"/> </Shell.TitleView> <Border StrokeThickness=\\\"-1\\\"> <Border.Background> <LinearGradientBrush> <GradientStop Color=\\\"#e6f6ff\\\" Offset=\\\"0.1\\\" /> <GradientStop Color=\\\"Transparent\\\" Offset=\\\"1.0\\\" /> </LinearGradientBrush> </Border.Background> <VerticalStackLayout BindableLayout.ItemsSource=\\\"{Binding MenuGroups}\\\" Spacing=\\\"8\\\" Padding=\\\"8\\\"> <BindableLayout.ItemTemplate> <DataTemplate x:DataType=\\\"model:MenuGroupModel\\\"> <Border Padding=\\\"8\\\" StrokeThickness=\\\"0\\\"> <Border.StrokeShape> <RoundRectangle CornerRadius=\\\"10,10,10,10\\\"/> </Border.StrokeShape> <VerticalStackLayout> <Label HorizontalOptions=\\\"Start\\\" Text=\\\"{Binding Name}\\\" FontSize=\\\"16\\\" HeightRequest=\\\"22\\\" TextColor=\\\"#ff222222\\\" Margin=\\\"4,0,0,0\\\"/> <CollectionView ItemsSource=\\\"{Binding Menus}\\\" Margin=\\\"0,8,0,0\\\"> <CollectionView.ItemsLayout> <GridItemsLayout Orientation=\\\"Vertical\\\" Span=\\\"4\\\" VerticalItemSpacing=\\\"8\\\"></GridItemsLayout> </CollectionView.ItemsLayout> <CollectionView.ItemTemplate> <DataTemplate x:DataType=\\\"model:Menu\\\"> <controls:MenuButtonControl ImageSource=\\\"{Binding ImageSource}\\\" StartPointColor=\\\"{Binding StartPointColor}\\\" EndPointColor=\\\"{Binding EndPointColor}\\\" Text=\\\"{Binding Name}\\\"> <controls:MenuButtonControl.GestureRecognizers> <TapGestureRecognizer Command=\\\"{Binding Source={x:Reference this},Path=BindingContext.GotoCommand}\\\" CommandParameter=\\\"{Binding}\\\"/> </controls:MenuButtonControl.GestureRecognizers> </controls:MenuButtonControl> </DataTemplate> </CollectionView.ItemTemplate> </CollectionView> </VerticalStackLayout> </Border> </DataTemplate> </BindableLayout.ItemTemplate> </VerticalStackLayout> </Border> </ContentPage> \",\"controls:MenuButtonControl.GestureRecognizers 提供一个手势识别的集合器\",\"controls:MenuButtonControl.GestureRecognizers.TapGestureRecognizer 可以设置该控件的点击行为，这里我们通过 Command 属性为点击行为绑定了一个事件，通过 CommandParameter 属性为该事件传递了一个参数\",\"至此 我们已经实现了页面的跳转：\"]},{\"header\":\"路由传参\",\"slug\":\"路由传参\",\"contents\":[\"前面提到了 Shell.Current.GoToAsync() 是 MAUI 提供的页面跳转方法，该方法提供了重载可用于在页面间传递参数：\",\"using CommunityToolkit.Mvvm.ComponentModel; using Mediinfo.Vela.YiDongHL.App.Models; using System; using System.Collections.Generic; using CommunityToolkit.Mvvm; using CommunityToolkit.Mvvm.Input; namespace Mediinfo.Vela.YiDongHL.App.ViewModels { public partial class MainPageViewModel : ViewModelBase { //其他代码 [RelayCommand] private async Task Tab(Menu menu) { await Shell.Current.GoToAsync(menu.Path, new Dictionary<string, object> { {menu.Path, menu} }); } } } \",\"第二个参数为需要传递到目标页面的对象，必须为字典类型。\"]},{\"header\":\"读取参数\",\"slug\":\"读取参数\",\"contents\":[\"首先为我们的目标页创建 ViewModel\",\"using CommunityToolkit.Mvvm.ComponentModel; using Mediinfo_MAUI_Demo.Models; namespace Mediinfo_MAUI_Demo.ViewModels; public partial class BaiYaoHDViewModel : ObservableObject, IQueryAttributable { [ObservableProperty] Menu menuData; public void ApplyQueryAttributes(IDictionary<string, object> query) { MenuData = query[\\\"BaiYaoHDView\\\"] as Menu; } } \",\"要读取路由中的参数其中一个方法是实现 IQueryAttributable 接口中的 ApplyQueryAttributes 方法， 该方法的入参是一个字典，Key 即为我们上一步 Shell.Current.GoToAsync() 中第二个参数定义的 Key，值即为我们传递的对象，此处需要转换为我们定义的 Menu 对象，并赋值给监听属性 menuData。\",\"页面数据绑定：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.Views.BaiYaoHDView\\\" x:DataType=\\\"viewmodel:BaiYaoHDViewModel\\\" Title=\\\"BaiYaoHDView\\\"> <ContentPage.BindingContext> <viewmodel:BaiYaoHDViewModel/> </ContentPage.BindingContext> <VerticalStackLayout> <Label Text=\\\"{Binding MenuData.Name, StringFormat='参数1 = {0}'}\\\" VerticalOptions=\\\"Center\\\" HorizontalOptions=\\\"Center\\\" /> <Label Text=\\\"{Binding MenuData.Path, StringFormat='参数2 = {0}'}\\\" VerticalOptions=\\\"Center\\\" HorizontalOptions=\\\"Center\\\" /> </VerticalStackLayout> </ContentPage> \",\"此处使用我们前面讲解过的数据绑定将数据展示在页面上。\",\"效果：\",\"参数读取\"]}]},\"/articles/maui/xaml-jichu.html\":{\"title\":\"XAML重点基础知识\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"XAML重点基础知识\"]},{\"header\":\"基本语法\",\"slug\":\"基本语法\",\"contents\":[]},{\"header\":\"标记扩展\",\"slug\":\"标记扩展\",\"contents\":[]},{\"header\":\"基本用法\",\"slug\":\"基本用法\",\"contents\":[\"在单个页面中，如果有多个属性相同的控件，而你不想在修改时去更改每一个控件，可使用 共享资源 来避免重复定义属性。\",\"例：\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" x:Class=\\\"XamlSamples.SharedResourcesPage\\\" Title=\\\"Shared Resources Page\\\"> <StackLayout> <Button Text=\\\"Do this!\\\" HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" BorderWidth=\\\"3\\\" Rotation=\\\"-15\\\" TextColor=\\\"Red\\\" FontSize=\\\"24\\\" /> <Button Text=\\\"Do that!\\\" HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" BorderWidth=\\\"3\\\" Rotation=\\\"-15\\\" TextColor=\\\"Red\\\" FontSize=\\\"24\\\" /> <Button Text=\\\"Do the other thing!\\\" HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" BorderWidth=\\\"3\\\" Rotation=\\\"-15\\\" TextColor=\\\"Red\\\" FontSize=\\\"24\\\" /> </StackLayout> </ContentPage> \",\"你可以用如下方式在该页面中定义 资源字典：\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" x:Class=\\\"XamlSamples.SharedResourcesPage\\\" Title=\\\"Shared Resources Page\\\"> <ContentPage.Resources> <LayoutOptions x:Key=\\\"horzOptions\\\" Alignment=\\\"Center\\\" /> <LayoutOptions x:Key=\\\"vertOptions\\\" Alignment=\\\"Center\\\" /> </ContentPage.Resources> <!--其他代码--> </ContentPage> \",\"上述代码定义了两个值作为当前页面的资源，分别是 horzOptions 和 vertOptions\",\"资源字典使用方法：\",\"<Button Text=\\\"Do this!\\\" HorizontalOptions=\\\"{StaticResource horzOptions}\\\" VerticalOptions=\\\"{StaticResource vertOptions}\\\" BorderWidth=\\\"3\\\" Rotation=\\\"-15\\\" TextColor=\\\"Red\\\" FontSize=\\\"24\\\" /> \"]},{\"header\":\"x:Static 标记扩展\",\"slug\":\"x-static-标记扩展\",\"contents\":[\"x:Static 标记扩展的主要用途是引用自己代码中的静态字段或属性\",\"下面的代码展示了其基本用法：\",\"还可以 XAML 文件中引用系统命名空间中的对象。\",\"例：\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:sys=\\\"clr-namespace:System;assembly=netstandard\\\" x:Class=\\\"Mediinfo_MAUI_Demo.Views.DemoPage1\\\" Title=\\\"DemoPage1\\\"> <VerticalStackLayout BindingContext=\\\"{x:Static sys:DateTime.Now}\\\" Spacing=\\\"25\\\" Padding=\\\"30,0\\\" VerticalOptions=\\\"Center\\\" HorizontalOptions=\\\"Center\\\"> <Label Text=\\\"{Binding Year, StringFormat='The year is {0}'}\\\" /> <Label Text=\\\"{Binding Month, StringFormat='The month is {0}'}\\\" /> <Label Text=\\\"{Binding Day, StringFormat='The day is {0}'}\\\" /> <Label Text=\\\"{Binding StringFormat='The time is {0:T}'}\\\" /> </VerticalStackLayout> </ContentPage> \",\"本段代码中，System 系统命名空间位于 netstandard 程序集中，所以需要用 assembly 指定程序集名称。\"]},{\"header\":\"数据绑定\",\"slug\":\"数据绑定\",\"contents\":[\"数据绑定用来连接两个对象的属性，这两个属性称为 源 和 目标\",\"源和目标一般通过如下两个标记指定：\",\"BindingContext 为目标对象指定数据源对象\",\"Binding 为目标属性绑定源对象中的属性\",\"在 XAML 中定义数据绑定时，也可以通过 StaticResource 或 x:Static 标记扩展设置 BindingContext 目标对象。\"]},{\"header\":\"View-View 绑定\",\"slug\":\"view-view-绑定\",\"contents\":[\"可以定义数据绑定以关联同一页面上两个控件的属性。\",\"例：\",\"<ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" x:Class=\\\"XamlSamples.SliderBindingsPage\\\" Title=\\\"Slider Bindings Page\\\"> <StackLayout> <Label Text=\\\"ROTATION\\\" BindingContext=\\\"{x:Reference slider}\\\" Rotation=\\\"{Binding Path=Value}\\\" FontAttributes=\\\"Bold\\\" FontSize=\\\"18\\\" HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" /> <Slider x:Name=\\\"slider\\\" Maximum=\\\"360\\\" Value=\\\"10\\\" VerticalOptions=\\\"Center\\\" /> <Label BindingContext=\\\"{x:Reference slider}\\\" Text=\\\"{Binding Value, StringFormat='The angle is {0:F0} degrees'}\\\" FontAttributes=\\\"Bold\\\" FontSize=\\\"18\\\" HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" /> </StackLayout> </ContentPage> \",\"相关信息\",\"x:Name 用来为被引用元素指定一个别名\",\"BindingContext 用来设置元素当前要绑定的数据源对象\",\"Bingding Path 用来绑定当前对象中的某个属性，若绑定的属性只有一个，则可以省略 Path\",\"在本段代码中，第一个 Label 的 Rotation 属性和第二个 Label 的 Text 属性都和 Slider.Value 的值进行了绑定\",\"在 .NET MAUI 中，绑定不执行任何隐式类型转换，如果需要将非字符串对象显示为字符串，则必须提供类型转换器或使用 StringFormat。\"]},{\"header\":\"MVVM\",\"slug\":\"mvvm\",\"contents\":[]},{\"header\":\"什么是MVVM？\",\"slug\":\"什么是mvvm\",\"contents\":[\"MVVM 架构是微软官方推荐用于 MAUI 应用开发的架构，常用于基于基础数据模型的交互式视图的双向数据绑定。\",\"MVVM是一种设计思想，他是 Model-View-ViewMode 的缩写。\",\"Model 模型，指后端传递的数据\",\"View 视图，指所看到的页面\",\"ViewModel 视图模型，是 mvvm 模式的核心，是连接 view 和 model 的桥梁。它主要有两个作用：\",\"将模型（Model）转化成视图 (View)，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定 将视图 (View) 转化成模型 (Model)，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件 监听。 这两个方向都实现的，我们称之为数据的双向绑定\"]},{\"header\":\"简单MVVM\",\"slug\":\"简单mvvm\",\"contents\":[\"在 x:Static 标记扩展章节，我们介绍了如何使用 x:Static 标记扩展从命名空间中的 System 静态 DateTime.Now 属性获取当前日期和时间：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:sys=\\\"clr-namespace:System;assembly=netstandard\\\" x:Class=\\\"Mediinfo_MAUI_Demo.Views.DemoPage1\\\" Title=\\\"DemoPage1\\\"> <VerticalStackLayout BindingContext=\\\"{x:Static sys:DateTime.Now}\\\" Spacing=\\\"25\\\" Padding=\\\"30,0\\\" VerticalOptions=\\\"Center\\\" HorizontalOptions=\\\"Center\\\"> <Label Text=\\\"{Binding Year, StringFormat='The year is {0}'}\\\" /> <Label Text=\\\"{Binding Month, StringFormat='The month is {0}'}\\\" /> <Label Text=\\\"{Binding Day, StringFormat='The day is {0}'}\\\" /> <Label Text=\\\"{Binding StringFormat='The time is {0:T}'}\\\" /> </VerticalStackLayout> </ContentPage> \",\"x:Static 标记扩展的简单使用\",\"这种写法在构造和初始化页面时只会设置日期和时间一次，并且永远不会更改。\",\"若想实现页面上的时间自动更新，则需要为该页面创建一个ViewModel。\",\"例：\",\"using System.ComponentModel; namespace Mediinfo_MAUI_Demo.ViewModels; public class DemoPage1ViewModel : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; private DateTime _dateTime; private Timer _timer; public DateTime DateTime { get => _dateTime; set { if (_dateTime != value) { _dateTime = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(DateTime))); // 通知属性变更 } } } public DemoPage1ViewModel() { this.DateTime = DateTime.Now; // 每秒更新时间 _timer = new Timer(new TimerCallback((s) => this.DateTime = DateTime.Now), null, TimeSpan.Zero, TimeSpan.FromSeconds(1)); } ~DemoPage1ViewModel() => _timer.Dispose(); } \",\"相关信息\",\".NET MAUI 中的数据绑定机制将处理程序附加到此 PropertyChanged 事件，以便在属性更改时通知它，并将目标更新为新的值，所以 Viewmodel 需要实现 INotifyPropertyChanged 接口来获取 PropertyChanged 事件。\",\"我们定义了一个私有的计时器 _timer 和一个私有字段 _dataTime，然后分别在构造函数中初始化计时器，并且每秒钟都会通过公共属性 DateTime 对私有字段 _dataTime 更新，同时通知属性变化。\",\"ViewModel创建完毕后还需要跟视图做绑定，一般有如下两种绑定方式：\",\"在页面中绑定时间：\",\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\" ?> <ContentPage xmlns=\\\"http://schemas.microsoft.com/dotnet/2021/maui\\\" xmlns:x=\\\"http://schemas.microsoft.com/winfx/2009/xaml\\\" xmlns:sys=\\\"clr-namespace:System;assembly=netstandard\\\" xmlns:viewmodel=\\\"clr-namespace:Mediinfo_MAUI_Demo.ViewModels\\\" x:Class=\\\"Mediinfo_MAUI_Demo.Views.DemoPage1\\\" Title=\\\"DemoPage1\\\"> <ContentPage.BindingContext> <viewmodel:DemoPage1ViewModel/> </ContentPage.BindingContext> <Label Text=\\\"{Binding DateTime, StringFormat='{0:T}'}\\\" FontSize=\\\"18\\\" HorizontalOptions=\\\"Center\\\" VerticalOptions=\\\"Center\\\" /> </ContentPage> \",\"显示时间\"]},{\"header\":\"交互式MVVM\",\"slug\":\"交互式mvvm\",\"contents\":[\"很多时候，我们需要在页面上实时修改一个值，并在页面上呈现修改后的内容。\",\"下面是一个简单的例子：\",\"如此我们便实现了拖动控件，并实时显示当前数值的效果。\",\"1671069843710\"]},{\"header\":\"命令\",\"slug\":\"命令\",\"contents\":[\"在应用当中，我们常常会需要通过 点击 的形式去触发一些操作，比如 Button 按钮的点击事件，在 .NET MAUI 中我们还能用另一种方式去处理事件，即 命令。\",\"例：\",\"效果：\",\"点击按钮前\",\"点击按钮后\"]},{\"header\":\"MVVM社区工具包\",\"slug\":\"mvvm社区工具包\",\"contents\":[\"在 .NET MAUI 的 MVVM 最常用到的就是双向绑定和命令，但原生的使用方式不够方便和简洁，会大大降低我们的开发效率。 CommunityToolkit.Mvvm 社区工具包为我们提供了一个现代、快速和模块化的 MVVM 库。 使用 CommunityToolkit.Mvvm 定义属性和命令：\",\"using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace Mediinfo_MAUI_Demo.ViewModels; public class DemoPage2ViewModel : ObservableObject { private string _text; public string Text { get => _text; set => SetProperty(ref _text, value); } private RelayCommand? newCommand; public IRelayCommand NewCommand => newCommand ??= new RelayCommand(() => Text += \\\"哈哈\\\"); } \",\"使用 CommunityToolkit.Mvvm 工具包中的库需继承 ObservableObject 类\",\"借助 CommunityToolkit.Mvvm 工具包中的代码生成器，我们还可以进一步简化上述代码：\",\"using CommunityToolkit.Mvvm.ComponentModel; using CommunityToolkit.Mvvm.Input; namespace Mediinfo_MAUI_Demo.ViewModels; public partial class DemoPage2ViewModel : ObservableObject { [ObservableProperty] private string? _text; [RelayCommand] private void New() { Text += \\\"哈哈\\\"; } } \",\"使用 CommunityToolkit.Mvvm 中的代码生成器时，必须要在类上加上 partial 修饰符\"]}]},\"/articles/micro-service/\":{\"title\":\"微服务系列\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"本系列主要记录微服务相关的技术，学习为主。\"]}]},\"/articles/micro-service/jian-yi-wei-fu-wu-da-jian.html\":{\"title\":\"基于Docker+Consul+Ocelot+Nginx搭建微服务架构\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"基于Docker、Nginx、Consul、Ocelot等，从零开始搭建一套具有动态伸缩、限流、熔断功能的简易微服务架构。\"]},{\"header\":\"目标\",\"slug\":\"目标\",\"contents\":[\"简易微服务架构\"]},{\"header\":\"环境说明\",\"slug\":\"环境说明\",\"contents\":[\"本文适合有一定linux基础，并对容器、集群、负载均衡、服务注册与发现、网关等概念有一定了解的同学。\",\"本文中默认各服务集群部署在不同的Linux服务器(下文用Linux1...2...3...代指)，环境所需的多台服务器可用虚拟机代替。\",\"由于在该架构中，服务端在启动时会想Consul注册中心发起注册，所以我们需要先进行Consul集群的搭建。\"]},{\"header\":\"1 Consul注册中心集群搭建(Linux1)\",\"slug\":\"_1-consul注册中心集群搭建-linux1\",\"contents\":[]},{\"header\":\"1.1 拉取Consul镜像\",\"slug\":\"_1-1-拉取consul镜像\",\"contents\":[\"docker pull consul \"]},{\"header\":\"1.2 配置第一个Consul\",\"slug\":\"_1-2-配置第一个consul\",\"contents\":[\"docker run -d --name consul1 --restart=always \\\\ -e 'CONSUL_LOCAL_CONFIG={\\\"skip_leave_on_interrupt\\\":true}' \\\\ -p 8500:8500 -p 8300:8300 -p 8301:8301/udp -p 8302:8302/udp -p 8600:8600 \\\\ consul agent -server -bootstrap-expect=2 -ui -bind=0.0.0.0 -client 0.0.0.0 \\\\ -data-dir=/consul/data-dir \\\\ -node=nodes1 \",\"参数说明：\",\"8500 http 端口，用于 http 接口和 Web ui\",\"8300 server rpc 端口，同一数据中心 consul server 之间通过该端口通信\",\"8301 serf lan 端口，同一数据中心 consul client 通过该端口通信\",\"8302 serf wan 端口，不同数据中心 consul server 通过该端口通信\",\"8600 dns 端口，用于服务发现\",\"-server 以server模式启动，默认为client模式启动\",\"-bootstrap-expect 2：集群至少两台服务器，才能选举集群 leader，数目一达到，它就会被激活\",\"-ui：运行 Web 控制台\",\"-bind：监听网口，0.0.0.0 表示所有网口，如果不指定默认未 127.0.0.1，则无法和容器通信\",\"-client：限制某些网口可以访问\",\"-node：节点名称，节点中必须是唯一的\",\"默认Consule面板地址：[服务器IP]:8500\",\"查看node1情况 (正常输出：Consul agent running!)\",\"docker logs -f consul1 \",\"获取 Consul Server 1 的 ip 地址 (默认：172.17.0.2)\",\"docker exec consul1 consul members \"]},{\"header\":\"1.3 启动第二个Consul服务\",\"slug\":\"_1-3-启动第二个consul服务\",\"contents\":[\"docker run -d --name consul2 --restart=always \\\\ -e 'CONSUL_LOCAL_CONFIG={\\\"skip_leave_on_interrupt\\\":true}' \\\\ -p 8501:8500 \\\\ consul agent -server -bootstrap-expect=2 -ui -bind=0.0.0.0 -client 0.0.0.0 \\\\ -data-dir=/consul/data-dir \\\\ -node=nodes2 \\\\ -join 172.17.0.2 \",\"参数说明：\",\"-join join其他Consul服务的ip可组成集群\"]},{\"header\":\"1.4 启动其余4个Consul服务\",\"slug\":\"_1-4-启动其余4个consul服务\",\"contents\":[\"docker run -d --name consul3 --restart=always \\\\ -e 'CONSUL_LOCAL_CONFIG={\\\"skip_leave_on_interrupt\\\":true}' \\\\ -p 8502:8500 \\\\ consul agent -server -bootstrap-expect=2 -ui -bind=0.0.0.0 -client 0.0.0.0 \\\\ -data-dir=/consul/data-dir \\\\ -node=nodes3 \\\\ -join 172.17.0.2 \",\"docker run -d --name=consul4 --restart=always \\\\ -e 'CONSUL_LOCAL_CONFIG={\\\"skip_leave_on_interrupt\\\":true}' \\\\ -p 8503:8500 \\\\ consul agent -ui -bind=0.0.0.0 -client 0.0.0.0 \\\\ -node=nodec1 \\\\ -retry-join=172.17.0.2 \",\"docker run -d --name=consul5 --restart=always \\\\ -e 'CONSUL_LOCAL_CONFIG={\\\"skip_leave_on_interrupt\\\":true}' \\\\ -p 8504:8500 \\\\ consul agent -ui -bind=0.0.0.0 -client 0.0.0.0 \\\\ -node=nodec2 \\\\ -retry-join=172.17.0.2 \",\"docker run -d --name=consul6 --restart=always \\\\ -e 'CONSUL_LOCAL_CONFIG={\\\"skip_leave_on_interrupt\\\":true}' \\\\ -p 8505:8500 \\\\ consul agent -ui -bind=0.0.0.0 -client 0.0.0.0 \\\\ -node=nodec3 \\\\ -retry-join=172.17.0.2 \",\"此时Consul 集群已完成部署，可以浏览器访问：http://ip:8500 | 8501 | 8502 查看状态（\\\"|\\\"=或者）\",\"查看节点\",\"docker exec -t consul1 consul members \",\"查看主从信息\",\"docker exec -t consul1 consul operator raft list-peers \"]},{\"header\":\"2 为Consul集群配置Nginx负载均衡(Linux2)\",\"slug\":\"_2-为consul集群配置nginx负载均衡-linux2\",\"contents\":[]},{\"header\":\"2.1 拉取镜像\",\"slug\":\"_2-1-拉取镜像\",\"contents\":[\"docker pull nginx \"]},{\"header\":\"2.2 启动Nginx服务\",\"slug\":\"_2-2-启动nginx服务\",\"contents\":[\"docker run --name nginx -p 80:80 -d --restart=always nginx \"]},{\"header\":\"2.3 修改配置文件\",\"slug\":\"_2-3-修改配置文件\",\"contents\":[\"进入容器：\",\"docker exec -it nginx bash \",\"配置文件地址：/etc/nginx/nginx.conf\",\"vi /etc/nginx/nginx.conf \",\"若vi或者vim命令无法使用，则需先执行以下命令：\",\"apt-get update apt-get install vim -y \",\"在默认配置文件http节点下加入以下代码并保存：\",\"#upstream 轮询模式 consul 名称，可自定义 #server 后为consul地址 upstream consul{ server IP:8500; server IP:8501; server IP:8502; server IP:8503; server IP:8504; server IP:8505; } #该服务器接受到端口80的所有流量并将其传递给上游upstream 。 #请注意，upstream名称和proxy_pass需要匹配。 server { listen 80; server_name localhost; location / { proxy_pass http://consul; } } 注释掉 默认配置文件中的 /include /etc/nginx/conf.d/*.conf 不然会导致配置不生效 \"]},{\"header\":\"2.4 重启Nginx服务\",\"slug\":\"_2-4-重启nginx服务\",\"contents\":[\"退出镜像\",\"exit \",\"重启Nginx服务\",\"docker restart nginx \"]},{\"header\":\"3 API服务端搭建(Linux3)\",\"slug\":\"_3-api服务端搭建-linux3\",\"contents\":[]},{\"header\":\"3.1准备.Net Core Web Api 作为测试服务端\",\"slug\":\"_3-1准备-net-core-web-api-作为测试服务端\",\"contents\":[\"相相关代码可参考我已经写好的测试项目：ServerTest\"]},{\"header\":\"3.2 上传项目至Linux3\",\"slug\":\"_3-2-上传项目至linux3\",\"contents\":[\"将WebApi项目上传至linux的test/weifuwu目录下\",\"进入项目根目录：\",\"cd /test/weifuwu/ServerTest \",\"构建镜像：\",\"docker build -t dotnet -f Dockerfile . \",\"查看镜像：\",\"docker images \",\"以此镜像为模板启动多个容器：\",\"docker run --restart=always -idt -p 2300:80 dotnet --ip=*.*.*.26 --port=2300 --name=ServerA docker run --restart=always -idt -p 2301:80 dotnet --ip=*.*.*.26 --port=2301 --name=ServerA docker run --restart=always -idt -p 2302:80 dotnet --ip=*.*.*.26 --port=2302 --name=ServerA docker run --restart=always -idt -p 2303:80 dotnet --ip=*.*.*.26 --port=2303 --name=ServerB docker run --restart=always -idt -p 2304:80 dotnet --ip=*.*.*.26 --port=2304 --name=ServerB docker run --restart=always -idt -p 2305:80 dotnet --ip=*.*.*.26 --port=2305 --name=ServerB docker run --restart=always -idt -p 2306:80 dotnet --ip=*.*.*.26 --port=2306 --name=ServerC docker run --restart=always -idt -p 2307:80 dotnet --ip=*.*.*.26 --port=2307 --name=ServerC docker run --restart=always -idt -p 2308:80 dotnet --ip=*.*.*.26 --port=2308 --name=ServerC \"]},{\"header\":\"4 Ocelot网关集群搭建(Linux4)\",\"slug\":\"_4-ocelot网关集群搭建-linux4\",\"contents\":[]},{\"header\":\"4.1 准备 .Net Core Web Api 测试项目\",\"slug\":\"_4-1-准备-net-core-web-api-测试项目\",\"contents\":[\"相相关代码可参考我已经写好的测试项目：OcelotTest\"]},{\"header\":\"4.2 上传项目至Linux服务器\",\"slug\":\"_4-2-上传项目至linux服务器\",\"contents\":[\"将WebApi项目上传至linux的test/weifuwu目录下\",\"进入项目根目录：\",\"cd /test/weifuwu/OcelotTest \",\"构建镜像：\",\"docker build -t ocelot -f Dockerfile . \",\"查看镜像：\",\"docker images \",\"以此镜像为模板启动多个容器：\",\"docker run --restart=always -idt -p 801:80 ocelot docker run --restart=always -idt -p 802:80 ocelot docker run --restart=always -idt -p 803:80 ocelot \"]},{\"header\":\"5 为Ocelot集群配置Nginx负载均衡(Linux4)\",\"slug\":\"_5-为ocelot集群配置nginx负载均衡-linux4\",\"contents\":[]},{\"header\":\"5.1 拉取镜像\",\"slug\":\"_5-1-拉取镜像\",\"contents\":[\"docker pull nginx \"]},{\"header\":\"5.2 启动Nginx服务\",\"slug\":\"_5-2-启动nginx服务\",\"contents\":[\"docker run --name nginx -p 80:80 -d --restart=always nginx \"]},{\"header\":\"5.3 修改配置文件\",\"slug\":\"_5-3-修改配置文件\",\"contents\":[\"进入容器：\",\"docker exec -it nginx bash \",\"配置文件地址：/etc/nginx/nginx.conf\",\"vi /etc/nginx/nginx.conf \",\"若vi或者vim命令无法使用，则需先执行以下命令：\",\"apt-get update apt-get install vim -y \",\"在默认配置文件http节点下加入以下代码并保存：\",\"#upstream 轮询模式 ocelot 名称，可自定义 #server 后为ocelot地址 upstream ocelot{ server *.*.*.26:801; server *.*.*.26:802; server *.*.*.26:803; } #该服务器接受到端口80的所有流量并将其传递给上游upstream 。 #请注意，upstream名称和proxy_pass需要匹配。 server { listen 80; server_name localhost; location / { proxy_pass http://ocelot; } } #注释掉 默认配置文件中的 /include /etc/nginx/conf.d/*.conf #不然会导致配置不生效 \"]},{\"header\":\"5.4 重启Nginx服务\",\"slug\":\"_5-4-重启nginx服务\",\"contents\":[\"退出镜像\",\"exit \",\"重启Nginx服务\",\"docker restart nginx \"]},{\"header\":\"6 Web客户端搭建(Linux6)\",\"slug\":\"_6-web客户端搭建-linux6\",\"contents\":[]},{\"header\":\"6.1 准备 .Net Core Web(MVC) 测试项目\",\"slug\":\"_6-1-准备-net-core-web-mvc-测试项目\",\"contents\":[\"相相关代码可参考我已经写好的测试项目：WebTest\"]},{\"header\":\"6.2 上传项目至Linux6\",\"slug\":\"_6-2-上传项目至linux6\",\"contents\":[\"将WebApi项目上传至linux的test/weifuwu目录下\",\"进入项目根目录：\",\"cd /test/weifuwu/WebTest \",\"构建镜像：\",\"docker build -t web -f Dockerfile . \",\"查看镜像：\",\"docker images \",\"以此镜像为模板启动容器：\",\"docker run --restart=always -idt -p 80:80 web \"]},{\"header\":\"大功告成\",\"slug\":\"大功告成\",\"contents\":[\"效果：\",\"刷新页面，客户端调用的服务端IP会变化\",\"当关闭/新增一个服务端的时候，服务注册发现生效，客户端并不会报错\",\"多次刷新页面会出发限流效果，提示请稍后\"]}]},\"/articles/others/\":{\"title\":\"其他\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"这里主要记录一些零碎的技术内容，仅供本人学习。\"]}]},\"/articles/others/domain-name-add-ssl-certificate.html\":{\"title\":\"为域名添加免费的SSL证书\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"如何为域名添加免费的SSL证书\"]},{\"header\":\"申请SSL证书\",\"slug\":\"申请ssl证书\",\"contents\":[\"登录站长之家，在首页用SEO综合查询搜索自己的域名，点击下方的'免费申请'\",\"站长之家\",\"选择品牌及证书型号，填写信息并提交\",\"选择证书\",\"填写完信息后，点击下一步\",\"站长之家\",\"选择手动DNS验证，点击确认申请\",\"站长之家\",\"按照操作指引，在自己的服务器控制台添加一条DNS解析记录，记录类型为TXT，记录值为如图所示的一串代码\",\"站长之家\",\"DNS解析配置完成后店家提交验证，此步骤比较慢，可以耐心等待或者多尝试几次。 验证成功后即可在左侧'SSL证书管理'中查看证书信息。\",\"站长之家\"]},{\"header\":\"下载证书\",\"slug\":\"下载证书\",\"contents\":[\"点击证书列表右侧的下载，将弹出如下窗口，下载类型选择PEM_Nginx\",\"img\",\"证书下载解压后，将得到两个文件名以自己域名开头的两个证书文件\",\"img\"]},{\"header\":\"利用Nginx安装SSL证书\",\"slug\":\"利用nginx安装ssl证书\",\"contents\":[\"在Linux上安装Nginx并设置开机启动\",\"将上一步下载的两个证书文件上传至Nginx的配置文件nginx.conft同级的根目录下\",\"修改Nginx配置文件，并在http节点中添加如下代码\",\"# 编辑Nginx配置文件 vi /etc/nginx/nginx.conft \",\"# 此处为正常部署网站的代理配置 server{ listen 80; listen [::]:80; server_name localhost; rewrite ^(.*) https://$host$1 permanent; # 需增加这一句，将80端口的所有请求都转为https location / { root html; index index.html index.htm; } } # 此处为ssl证书配置 server{ server_name goodsxx.cn;# 填写绑定证书的域名 listen 443 ssl; ssl_certificate goodsxx.cn.crt;# 后缀为.crt的证书文件名 ssl_certificate_key goodsxx.cn.key;# 后缀为.key的证书文件名 ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; # 按照这个套件配置 ssl_prefer_server_ciphers on; location / { root html;# 站点目录 index index.html index.htm; proxy_pass http://goodsxx.cn:8000; # 此代理表示 访问https://goodsxx.cn将会指向http://goodsxx.cn:8000 } } \",\"保存退出，重启Nginx即可使用https访问自己的域名\"]}]},\"/articles/qianduan/\":{\"title\":\"前端相关\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"这里主要记录一些前端相关的的技术内容，仅供本人学习。\"]}]},\"/articles/qianduan/swagger-typescript-api.html\":{\"title\":\"Swagger-TypeScript-API\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"通过Swagger自动生成ts格式的API模块\"]},{\"header\":\"开源组件地址\",\"slug\":\"开源组件地址\",\"contents\":[\"Swagger-TypeScript-API\"]},{\"header\":\"使用说明\",\"slug\":\"使用说明\",\"contents\":[\"用法： sta [选项] swagger-typescript-api [选项] swagger-typescript-api generate-templates [选项] 选项： -v, --version 输出当前版本 -p, --path <string> Swagger架构的路径/网址 -o, --output <string> TypeScript API文件的输出路径（默认值：“./”） -n, --name <string> 输出TypeScript API文件的名称（默认值：“Api.ts”） -t, --templates <string> 包含模板的文件夹的路径 -d, --default-as-success 将“默认(default)”响应状态代码也用作成功响应类型。某些Swagger架构默认将“默认(default)”响应状态代码用作成功响应类型。（默认值：false） -r, --responses 生成有关请求响应的附加信息，同时为错误响应添加类型定义（默认值：false） --union-enums 将所有“枚举(enum)”类型生成为联合类型(T1 | T2 | TN)（默认值：false） --add-readonly 生成只读属性 (默认值：false) --route-types 为API路由生成类型定义（默认值：false） --no-client 不生成API类 --enum-names-as-values 在枚举中使用“x-enumNames”的值作为枚举值（不仅仅是键）(默认值：false) --extract-request-params 提取请求参数到数据契约（还将路径参数和查询参数组合成一个对象）(默认值：false) --extract-request-body 提取请求正文类型到数据契约（默认值：false） --extract-response-body 提取响应正文类型到数据契约 (默认值：false) --extract-response-error 提取响应错误类型到数据契约 (默认值：false) --modular 为HTTP客户端、数据契约和路由生成单独的文件 (默认值：false) --js 生成具有声明文件的JS API模块 (默认值：false) --module-name-index <number> 确定应使用哪个路径索引来分离路由 (例如：GET:/fruites/getFruit -> index:0 -> moduleName -> fruites) (默认值：0) --module-name-first-tag 基于第一个标记拆分路由 (默认值：false) --disableStrictSSL 禁用严格的SSL (默认值：false) --disableProxy 禁用代理 (默认值：false) --axios 生成axios HTTP客户端 (默认值：false) --unwrap-response-data 从响应中取消包装数据项 (默认值：false) --disable-throw-on-error 当response.ok不为true时不抛出错误 (默认值：false) --single-http-client 能够将HttpClient实例发送到Api构造函数 (默认值：false) --silent 仅将错误输出到控制台 (默认值：false) --default-response <type> 空响应模式的默认类型 (默认值：“void”) --type-prefix <string> 数据契约名称前缀 (默认值：“\\\") --type-suffix <string> 数据契约名称后缀 (默认值：“\\\") --clean-output 在生成API之前清空输出文件夹。 警告：可能会导致数据丢失 (默认值：false) --api-class-name <string> API类的名称 (默认值：“Api”) --patch 修复Swagger源定义中的小错误 (默认值：false) --debug 关于此工具内部过程的附加信息 (默认值：false) --another-array-type 将数组类型生成为Array<Type>（默认为Type[]）(默认值：false) --sort-types 对字段和类型进行排序 (默认值：false) --extract-enums 从内联接口/类型内容中提取所有枚举到typescript枚举构造函数中 (默认值：false) -h, --help 显示帮助命令 命令： generate-templates 生成生成API所需的“.ejs”模板 -o, --output <string> 生成模板的输出路径 -m, --modular 生成分离HTTP客户端、数据契约和路由所需的模板 (默认值：false) --http-client <string> HTTP客户端类型（可能的值：\\\"fetch\\\"，\\\"axios\\\"）(默认值：\\\"fetch\\\") -c, --clean-output 在生成模板之前清空输出文件夹。 警告：可能会导致数据丢失 (默认值：false) -r, --rewrite 重写现有模板中的内容 (默认值：false) --silent 仅将错误输出到控制台 (默认值：false) -h, --help 显示帮助命令 \"]}]},\"/articles/tools/\":{\"title\":\"工具\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"分享一写好用的开发工具\"]}]},\"/articles/tools/vs-translate.html\":{\"title\":\"VS代码提示翻译工具\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"使用DotNetCoreZhHans翻译本地语言包，实现VS的中文代码提示\"]},{\"header\":\"下载DotNetCoreZhHans\",\"slug\":\"下载dotnetcorezhhans\",\"contents\":[]},{\"header\":\"最新版本： DotNetCoreZhHans.exe\",\"slug\":\"最新版本-dotnetcorezhhans-exe\",\"contents\":[]},{\"header\":\"备用地址： DotNetCoreZhHans.exe 提取码: uo59\",\"slug\":\"备用地址-dotnetcorezhhans-exe-提取码-uo59\",\"contents\":[]},{\"header\":\"Gitee地址： dot-net-core-zh-hans-open\",\"slug\":\"gitee地址-dot-net-core-zh-hans-open\",\"contents\":[]},{\"header\":\"安装/启动 DotNetCoreZhHans\",\"slug\":\"安装-启动-dotnetcorezhhans\",\"contents\":[\"1656401146159\"]},{\"header\":\"配置翻译API\",\"slug\":\"配置翻译api\",\"contents\":[]},{\"header\":\"1. 点击齿轮图标\",\"slug\":\"_1-点击齿轮图标\",\"contents\":[\"1656401273699\"]},{\"header\":\"2. 启动百度API，点击编辑图标，填写APPID及密钥\",\"slug\":\"_2-启动百度api-点击编辑图标-填写appid及密钥\",\"contents\":[\"1656401348291\",\"1656401388247\",\"SecretId和SecretKey为百度翻译开放平台中的APP ID和密钥(需注册)\"]},{\"header\":\"启动程序，进行本地语言包翻译\",\"slug\":\"启动程序-进行本地语言包翻译\",\"contents\":[\"1656401614390\",\"1656401636718\",\"翻译后弹出的异常可以忽略\"]},{\"header\":\"重启VS即可实现中文代码提示\",\"slug\":\"重启vs即可实现中文代码提示\",\"contents\":[\"1656401816101\"]}]},\"/articles/distributed-middleware/authorization_authentication/\":{\"title\":\"授权与认证\",\"contents\":[]},\"/articles/distributed-middleware/authorization_authentication/oauth2.0_openid_connect.html\":{\"title\":\"OAuth 2.0 和 OpenID Connect\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"本文是一篇关于 OAuth 2.0 与 OpenID Connect 协议的完整指南，这两个协议是用于授权和认证的使用最广泛的的协议。OAuth 2.0 用于授权，OpenID Connect 用于认证。有两种 OAuth 2.0 授权流程最为常见：服务端应用程序的授权码流程和基于浏览器的应用程序的隐式流程。OpenID Connect 是 OAuth 2.0 协议之上的标识层，以使 OAuth 适用于认证的用例。\"]},{\"header\":\"为什么需要 OAuth？\",\"slug\":\"为什么需要-oauth\",\"contents\":[\"为了更好地理解 OAuth 诞生的理由，我们需要理解一个术语：代理授权。\"]},{\"header\":\"代理授权\",\"slug\":\"代理授权\",\"contents\":[\"代理授权是一种允许第三方应用访问用户数据的方法。\"]},{\"header\":\"两种代理授权的方式\",\"slug\":\"两种代理授权的方式\",\"contents\":[\"有两种代理授权的方式：一是你将账号密码提供给第三方应用，以便它们可以代表你来登陆账号并且访问数据；二是你通过 OAuth 授权第三方应用访问你的数据，而无需提供密码。（我相信我们都不会选择交出我们的密码！）\",\"现在，我们知道了 OAuth 的必要性和重要性，让我们更深入地研究这个协议。\"]},{\"header\":\"OAuth 2.0\",\"slug\":\"oauth-2-0\",\"contents\":[]},{\"header\":\"什么是 OAuth？\",\"slug\":\"什么是-oauth\",\"contents\":[\"OAuth（Open Authorization，即开放授权）是一个用于代理授权的标准协议。它允许应用程序在不提供用户密码的情况下访问该用户的数据。\"]},{\"header\":\"OAuth 2.0 术语表\",\"slug\":\"oauth-2-0-术语表\",\"contents\":[\"为理解这个协议，我们需要理解以下术语：\",\"资源所有者（Resource Owner）：拥有客户端应用程序想要访问的数据的用户。\",\"客户端（Client）：想要访问用户数据的的应用程序\",\"授权服务端（Authorization Server）：通过用户许可，授权客户端访问用户数据的授权服务端。\",\"资源服务端（Resource Server）：存储客户端要访问的数据的系统。在某些情况下，资源服务端和授权服务端是同一个服务端。\",\"访问令牌：访问令牌是客户端可用于访问资源服务端上用户授权的数据的唯一密钥。\",\"以下是 OAuth 2.0 抽象流程图，让我们一起看看上述术语在图中的应用\",\"OAuth2.0 抽象流程图\",\"授权密钥（Authorization Key）或者权限（Grant）可以是授权码或者令牌的类型。下文我们将会提到不同的权限和授权密钥。现在，让我们先详细解释授权的流程。\",\"用户通过点击按钮启动整个授权流程。这个按钮通常类似于“谷歌登陆“、”Facebook 登陆“或者通过其他的应用登陆。\",\"然后客户端将用户重定向到授权服务端。在重定向的过程中，客户端将类似客户 ID、重定向 URI 的信息发送给授权服务端。\",\"授权服务端处理用户认证，并显示授权许可窗口，然后从用户方获得授权许可。如果你通过谷歌登陆，你必须向谷歌，而不是客户端，提供登陆证书——例如向 accounts.google.com 提供登陆证书。\",\"如果用户授权许可，则授权服务端将用户重定向到客户端，同时发送授权密钥（授权码或令牌）。\",\"客户端向资源服务端发送包含授权密钥的请求，要求资源服务端返回用户数据。\",\"资源服务端验证授权密钥，并向客户端返回它所请求的数据。\",\"这就是用户在不提供密码的情况下，允许第三方应用访问用户数据的过程。但与此同时，有一些问题出现了：\",\"我们如何限制客户端只访问资源服务端上的部分数据？\",\"如果我们只希望客户端读取数据，而没有权限写入数据呢？\",\"这些问题将我们引导至 OAuth 技术术语中另一部分很重要的概念：授权范围（Scope）。\"]},{\"header\":\"OAuth 中的授权范围（Scope）\",\"slug\":\"oauth-中的授权范围-scope\",\"contents\":[\"在 OAuth 2.0 中，授权范围用于限制应用程序访问某用户的数据。这是通过发布仅限于用户授权范围的权限来实现的。\",\"当客户端向授权服务端发起权限请求时，它同时随之发送一个授权范围列表。授权客户端根据这个列表生成一个授权许可窗口，并通过用户授权许可。如果用户同意了其授权告知，授权客户端将发布一个令牌或者授权码，该令牌或授权码仅限于用户授权的范围。\",\"举个例子，如果我授权了某客户端应用访问我的谷歌通讯录，则授权服务端向该客户端发布的令牌不能用于删除我的联系人，或者查看我的谷歌日历事件——因为它仅限于读取谷歌通讯录的范围。\"]},{\"header\":\"OAuth 2.0 的设置\",\"slug\":\"oauth-2-0-的设置\",\"contents\":[\"在讨论 OAuth 流程之前，最好先了解一些 OAuth 的配置。当发起授权权限的请求时，客户端将一些配置数据作为查询参数发送给授权服务端。这些基本的查询参数包括：\",\"响应类型（response_type）：我们希望从授权服务端获得的响应类型\",\"授权范围（scope）：客户端希望访问的授权范围列表。授权服务端将使用这个列表为用户产生同意授权许可窗口。\",\"用户 ID（client_id）：由授权服务在为 OAuth 设置客户端时提供。此 ID 可帮助授权服务端确定正在发送 OAuth 流程的客户端。\",\"重定向通用资源标识符（redirect_uri）：用于告知授权服务器当 OAuth 流程完成后重定向的地址\",\"客户密码（client_secret）：由授权服务提供，根据 OAuth 流程，这个参数可能需要也可能不需要。我们将在授权码流程中会了解到它的重要性。\"]},{\"header\":\"了解不同的 OAuth 流程\",\"slug\":\"了解不同的-oauth-流程\",\"contents\":[\"两种最常用的 OAuth2.0 流程是：基于服务器的应用程序所使用的授权码流程，以及纯 JavaScript 单页应用所使用的隐式流程。\",\"为了解释 OAuth 的各类流程，接下来我将用谷歌作为 OAuth 服务提供者。\"]},{\"header\":\"授权码流程\",\"slug\":\"授权码流程\",\"contents\":[\"授权码流程，或者说授权码权限，是理想的 OAuth 流程。它被认为是非常安全的，因为它同时使用前端途径（浏览器）和后端途径（服务器）来实现 OAuth2.0 机制。\",\"OAuth2.0 授权码流程\",\"客户端通过将用户重定向到授权服务端来发起一个授权流程，其中，response_type需被设置成code。这告知了授权服务端用授权码来响应。该流程的 URI 如下所示：\",\"https://accounts.google.com/o/oauth2/v2/auth? response_type=code& client_id=your_client_id& scope=profile%20contacts& redirect_uri=https%3A//oauth2.example.com/code \",\"在上述请求中，客户端请求能够访问该用户公共主页和联系人的用户许可，这是在scope请求参数中设置的。这个请求的结果是授权码，客户端可以使用该授权码来交换访问令牌。一个授权码如下所示：\",\"4/W7q7P51a-iMsCeLvIaQc6bYrgtp9 \"]},{\"header\":\"为什么用授权码来交换令牌？\",\"slug\":\"为什么用授权码来交换令牌\",\"contents\":[\"访问令牌是唯一能用于访问资源服务端上的数据的东西，而不是授权码。所以为什么在客户端实际需要访问令牌的情况下，将response_type设置成授权码呢？这是因为这样做能使 OAuth 流程非常安全。\",\"OAuth2.0 授权码流程\",\"问题：访问令牌是我们不希望任何人能访问的秘密信息。如果客户端直接请求访问令牌，并将其存储在浏览器里，它可能会被盗，因为浏览器并不是完全安全的。任何人都能看见网页的代码，或者使用开发工具来获取访问令牌。\",\"解决方案：未了避免将访问令牌暴露在浏览器中，客户端的前端从授权服务端获得授权码，然后发送这个授权码到客户端的后端。现在，为了用授权码交换访问令牌，我们需要一个叫做客户密码（client_secret）的东西。这个客户密码只有客户端的后端知道，然后后端向授权服务端发送一个 POST 请求，其中包含了授权码和客户密码。这个请求可能如下所示：\",\"POST /token HTTP/1.1 Host: oauth2.googleapis.com Content-Type: application/x-www-form-urlencoded code=4/W7q7P51a-iMsCeLvIaQc6bYrgtp9& client_id=your_client_id& client_secret=your_client_secret_only_known_by_server& redirect_uri=https%3A//oauth2.example.com/code \"]},{\"header\":\"隐式流程\",\"slug\":\"隐式流程\",\"contents\":[\"当你没有后端程序，并且你的网站是一个仅使用浏览器的静态网站时，应该使用 OAuth2.0 隐式流程。在这种情况下，当你用授权码交换访问令牌时，你跳过发生在后端程序的最后一步。在隐式流程中，授权服务端直接返回访问令牌。\",\"OAuth2.0 授权码流程\",\"客户端将浏览器重定向到授权服务端 URI，并将response_type设置成token，以启动授权流程。授权服务端处理用户的登录和授权许可。请求的返回结果是访问令牌，客户端可以通过这个令牌访问资源服务端。\",\"隐式流程被认为不那么安全，因为浏览器负责管理访问令牌，因此令牌有可能被盗。尽管如此，它仍然被单页应用广泛使用。\"]},{\"header\":\"认证与授权\",\"slug\":\"认证与授权\",\"contents\":[\"正如我们所知，OAuth 解决了代理授权的问题，但是它没有提供一个认证用户身份的标准方法。你可以这样认为：\",\"OAuth2.0 用于授权\",\"OpenID Connect 用于认证\",\"如果你无法区分这些术语，则以下是它们之间的区别：\",\"认证（Authentication）是确保通信实体是其所声称的实体。\",\"授权（Authorization）是验证通信实体是否有权访问资源的过程。\",\"换言之，认证关注的是你是谁，授权关注的是你有什么权限。\"]},{\"header\":\"OpenID Connect\",\"slug\":\"openid-connect\",\"contents\":[\"OpenID Connect 是在 OAuth2.0 协议之上的标识层。它拓展了 OAuth2.0，使得认证方式标准化。\",\"OAuth 不会立即提供用户身份，而是会提供用于授权的访问令牌。 OpenID Connect 使客户端能够通过认证来识别用户，其中，认证在授权服务端执行。它是这样实现的：在向授权服务端发起用户登录和授权告知的请求时，定义一个名叫openid的授权范围。在告知授权服务器需要使用 OpenID Connect 时，openid是必须存在的范围。\",\"客户端发起的用于 OpenID Connect 认证请求 URI 会是如下的形式：\",\"https://accounts.google.com/o/oauth2/v2/auth? response_type=code& client_id=your_client_id& scope=openid%20contacts& redirect_uri=https%3A//oauth2.example.com/code \",\"该请求的返回结果是客户端可以用来交换访问令牌和 ID 令牌的授权码。如果 OAuth 流程是隐式的，那么授权服务端将直接返回访问令牌和 ID 令牌。\",\"ID 令牌是 JWT，或者又称 JSON Web Token。JWT 是一个编码令牌，它由三部分组成：头部，有效负载和签名。在获得了 ID 令牌后，客户端可以将其解码，并且得到被编码在有效负载中的用户信息，如以下例子所示：\",\"{ \\\"iss\\\": \\\"https://accounts.google.com\\\", \\\"sub\\\": \\\"10965150351106250715113082368\\\", \\\"email\\\": \\\"johndoe@example.com\\\", \\\"iat\\\": 1516239022, \\\"exp\\\": 1516242922 } \"]},{\"header\":\"声明（Claim）\",\"slug\":\"声明-claim\",\"contents\":[\"ID 令牌的有效负载包括了一些被称作声明的域。基本的声明有：\",\"iss：令牌发布者\",\"sub：用户的唯一标识符\",\"email：用户的邮箱\",\"iat：用 Unix 时间表示的令牌发布时间\",\"exp：Unix 时间表示的令牌到期时间\",\"然而，声明不仅限于上述这些域。由授权服务器对声明进行编码。客户端可以用这些信息来认证用户。\",\"如果客户端需要更多的用户信息，客户端可以指定标准的 OpenID Connect 范围，来告知授权服务端将所需信息包括在 ID 令牌的有效负载中。这些范围包括个人主页（profile）、邮箱（email）、地址（address）和电话（phone）。\",\"英文原文：\",\"The Complete Guide to OAuth 2.0 and OpenID Connect Protocols\"]}]},\"/articles/distributed-middleware/authorization_authentication/openiddict.html\":{\"title\":\"OpenIddict 中文文档\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"OpenIddict 是一个开源且通用的框架，用于在任何 ASP.NET Core 2.1（及更高版本）和传统的 ASP.NET 4.6.1（及更高版本）应用程序中构建符合标准的 OAuth 2.0 / OpenID Connect 服务器。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[]},{\"header\":\"什么是 OpenIddict？\",\"slug\":\"什么是-openiddict\",\"contents\":[\"OpenIddict 是一个开源且通用的框架，用于在任何 ASP.NET Core 2.1（及更高版本）和传统的 ASP.NET 4.6.1（及更高版本）应用程序中构建符合标准的 OAuth 2.0 / OpenID Connect 服务器。\",\"OpenIddict 诞生于2015年末，最初基于 AspNet.Security.OpenIdConnect.Server（代号 ASOS），这是一个低级别的 OpenID Connect 服务器中间件，受到 Microsoft 为 OWIN 项目开发的 OAuth 2.0 授权服务器中间件以及 ASP.NET Core 首个 OpenID Connect 服务器的启发。\",\"2020年，ASOS 被合并到 OpenIddict 3.0 中，形成了一个统一的堆栈，在“降级模式”的帮助下仍能为新用户提供易于使用的方法和为高级用户提供低级别的体验，而不需要支持数据库。\",\"作为这个过程的一部分，OpenIddict 3.0 添加了对 ASP.NET 4.6.1（及更高版本）的原生支持，使其成为替换 Microsoft.OwinOAuthAuthorizationServerMiddleware 和 OAuthBearerAuthenticationMiddleware 的绝佳选择，无需迁移到 ASP.NET Core。\"]},{\"header\":\"核心概念\",\"slug\":\"核心概念\",\"contents\":[]},{\"header\":\"用户身份验证\",\"slug\":\"用户身份验证\",\"contents\":[\"与其他解决方案不同，OpenIddict 专注于授权过程的 OAuth 2.0 / OpenID Connect 协议方面，并将用户身份验证交给实现者：OpenIddict 可与任何形式的用户身份验证（如密码、令牌、联合身份验证或集成 Windows 认证）原生配合使用。虽然方便，但不需要使用类似于 ASP.NET Core Identity 的成员资格堆栈。\"]},{\"header\":\"通行模式\",\"slug\":\"通行模式\",\"contents\":[\"与 OAuthAuthorizationServerMiddleware 类似，OpenIddict 允许在自定义控制器操作或任何其他能够钩入 ASP.NET Core 或 OWIN 请求处理管道的中间件中处理授权、注销和令牌请求。在这种情况下，OpenIddict 将始终首先验证传入请求（例如，通过确保强制参数存在且有效），然后允许调用其余的管道：如果发生任何验证错误，则 OpenIddict 会在到达用户定义的控制器操作或自定义中间件之前自动拒绝请求。\",\"builder.Services.AddOpenIddict() .AddServer(options => { // 启用授权和令牌终结点。 options.SetAuthorizationEndpointUris(\\\"/authorize\\\") .SetTokenEndpointUris(\\\"/token\\\"); // 启用授权代码流。 options.AllowAuthorizationCodeFlow(); // 注册签名和加密凭据。 options.AddDevelopmentEncryptionCertificate() .AddDevelopmentSigningCertificate(); // 注册ASP.NET Core主机并配置授权终结点 // 允许/authorify最小API处理程序处理授权请求 // 经过内置的OpenIddict服务器事件处理程序验证后。 // // 令牌请求将由OpenIddict自己通过重用标识来处理 // 由/authorify处理程序创建并存储在授权代码中。 options.UseAspNetCore() .EnableAuthorizationEndpointPassthrough(); }); \",\"app.MapGet(\\\"/authorize\\\", async (HttpContext context) => { // 解决存储在Steam身份验证舞蹈后创建的主体中的声明。 // 如果找不到主体，则触发一个新的挑战，将用户重定向到Steam。 var principal = (await context.AuthenticateAsync(SteamAuthenticationDefaults.AuthenticationScheme))?.Principal; if (principal is null) { return Results.Challenge(properties: null, new[] { SteamAuthenticationDefaults.AuthenticationScheme }); } var identifier = principal.FindFirst(ClaimTypes.NameIdentifier)!.Value; // 创建一个新身份并从Steam主体导入一些精选声明。 var identity = new ClaimsIdentity(TokenValidationParameters.DefaultAuthenticationType); identity.AddClaim(new Claim(Claims.Subject, identifier)); identity.AddClaim(new Claim(Claims.Name, identifier).SetDestinations(Destinations.AccessToken)); return Results.SignIn(new ClaimsPrincipal(identity), properties: null, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme); }); \"]},{\"header\":\"事件模式\",\"slug\":\"事件模式\",\"contents\":[\"OpenIddict 为其服务器和验证堆栈实现了一个强大的基于事件的模型：每个请求处理逻辑部分都实现为一个事件处理程序，可以将其移除、移动到管道中的不同位置或替换为自定义处理程序，以覆盖 OpenIddict 使用的默认逻辑。\",\"/// <summary> /// 包含负责拒绝未指定有效提示参数的授权请求的逻辑。 /// </summary> public class ValidatePromptParameter : IOpenIddictServerHandler<ValidateAuthorizationRequestContext> { /// <summary> /// 获取分配给此处理程序的默认描述符定义。 /// </summary> public static OpenIddictServerHandlerDescriptor Descriptor { get; } = OpenIddictServerHandlerDescriptor.CreateBuilder<ValidateAuthorizationRequestContext>() .UseSingletonHandler<ValidatePromptParameter>() .SetOrder(ValidateNonceParameter.Descriptor.Order + 1_000) .SetType(OpenIddictServerHandlerType.BuiltIn) .Build(); /// <inheritdoc/> public ValueTask HandleAsync(ValidateAuthorizationRequestContext context) { if (context is null) { throw new ArgumentNullException(nameof(context)); } // 通过同意/登录或选择帐户拒绝指定prompt=none的请求。 if (context.Request.HasPrompt(Prompts.None) && (context.Request.HasPrompt(Prompts.Consent) || context.Request.HasPrompt(Prompts.Login) || context.Request.HasPrompt(Prompts.SelectAccount))) { context.Logger.LogInformation(SR.GetResourceString(SR.ID6040)); context.Reject( error: Errors.InvalidRequest, description: SR.FormatID2052(Parameters.Prompt), uri: SR.FormatID8000(SR.ID2052)); return default; } return default; } } \",\"在 OpenIddict 中，事件处理程序通常定义为专用类，但也可以使用委托进行注册。\",\"services.AddOpenIddict() .AddServer(options => { options.AddEventHandler<HandleConfigurationRequestContext>(builder => builder.UseInlineHandler(context => { // 将自定义元数据附加到配置文档。 context.Metadata[\\\"custom_metadata\\\"] = 42; return default; })); }); \"]},{\"header\":\"入门指南\",\"slug\":\"入门指南\",\"contents\":[\"使用 OpenIddict 实现自定义 OpenID Connect 服务器的最简单选项是克隆 openiddict-samples 存储库中的官方示例之一。\",\"如果您不想从推荐的示例之一开始，您需要：\",\"安装 .NET Core 3.1（或更高版本）工具。\",\"有一个现有项目或创建一个新项目：在使用 Visual Studio 的默认 ASP.NET Core 模板创建新项目时，强烈建议使用单独的用户帐户身份验证，因为它会自动包括基于 Razor Pages 的默认 ASP.NET Core Identity UI。\",\"更新 .csproj 文件以引用最新的包：OpenIddict。\",\"<PackageReference Include=\\\"OpenIddict.AspNetCore\\\" Version=\\\"4.2.0\\\" /> <PackageReference Include=\\\"OpenIddict.EntityFrameworkCore\\\" Version=\\\"4.2.0\\\" /> \",\"在 Startup.ConfigureServices 中配置 OpenIddict 核心、服务器和验证服务。这是用于机器对机器场景中的客户端凭据授权的示例：\",\"public void ConfigureServices(IServiceCollection services) { services.AddControllersWithViews(); services.AddDbContext<ApplicationDbContext>(options => { // 将实体框架核心配置为使用Microsoft SQL Server。 options.UseSqlServer(Configuration.GetConnectionString(\\\"DefaultConnection\\\")); // 注册OpenIddict所需的实体集。 // 注意：如果需要替换默认的OpenIddict实体，请使用泛型重载。 options.UseOpenIddict(); }); services.AddOpenIddict() // 注册OpenIddict核心组件。 .AddCore(options => { // 配置OpenIddict以使用实体框架核心存储和模型。 // 注意：调用ReplaceDefaultEntities()来替换默认实体。 options.UseEntityFrameworkCore() .UseDbContext<ApplicationDbContext>(); }) // 注册OpenIddict服务器组件。 .AddServer(options => { // 启用令牌终结点。 options.SetTokenEndpointUris(\\\"connect/token\\\"); // 启用客户端凭据流。 options.AllowClientCredentialsFlow(); // 注册签名和加密凭据。 options.AddDevelopmentEncryptionCertificate() .AddDevelopmentSigningCertificate(); // 注册ASP.NET Core主机并配置ASP.NET Core选项。 options.UseAspNetCore() .EnableTokenEndpointPassthrough(); }) // 注册OpenIddict验证组件。 .AddValidation(options => { // 从本地OpenIddict服务器实例导入配置。 options.UseLocalServer(); // 注册ASP.NET Core主机。 options.UseAspNetCore(); }); // 向示例客户端注册负责数据库种子设定的工作人员。 // 注意：在实际应用程序中，此步骤应该是设置脚本的一部分。 services.AddHostedService<Worker>(); } \",\"确保 ASP.NET Core 身份验证中间件在正确的位置正确注册：\",\"public void Configure(IApplicationBuilder app) { app.UseDeveloperExceptionPage(); app.UseRouting(); app.UseAuthentication(); app.UseAuthorization(); app.UseEndpoints(options => { options.MapControllers(); options.MapDefaultControllerRoute(); }); } \",\"更新您的 Entity Framework Core 上下文注册以注册 OpenIddict 实体：\",\"services.AddDbContext<ApplicationDbContext>(options => { // 将实体框架核心配置为使用Microsoft SQL Server。 options.UseSqlServer(Configuration.GetConnectionString(\\\"DefaultConnection\\\")); // 注册OpenIddict所需的实体集。 // 注意：如果需要替换默认的OpenIddict实体，请使用泛型重载。 options.UseOpenIddict(); }); \",\"相关信息\",\"默认情况下，OpenIddict Entity Framework Core 集成使用 string 作为主键的默认类型。如果要使用其他类型，请阅读 Entity Framework Core 集成：使用自定义主键类型。\",\"创建自己的授权控制器：实现自定义授权控制器是必须的，以允许 OpenIddict 根据您提供的标识和声明创建令牌。这是用于机器对机器场景中的客户端凭据授权的示例：\",\"public class AuthorizationController : Controller { private readonly IOpenIddictApplicationManager _applicationManager; public AuthorizationController(IOpenIddictApplicationManager applicationManager) => _applicationManager = applicationManager; [HttpPost(\\\"~/connect/token\\\"), Produces(\\\"application/json\\\")] public async Task<IActionResult> Exchange() { var request = HttpContext.GetOpenIddictServerRequest(); if (!request.IsClientCredentialsGrantType()) { throw new NotImplementedException(\\\"The specified grant is not implemented.\\\"); } // 注意：客户端凭据由OpenIddict自动验证： // 如果client_id或clientsecret无效，则不会调用此操作。 var application = await _applicationManager.FindByClientIdAsync(request.ClientId) ?? throw new InvalidOperationException(\\\"The application cannot be found.\\\"); // 创建一个新的ClaimsIdentity，其中包含 // 将用于创建一个id_token、一个令牌或一个代码。 var identity = new ClaimsIdentity(TokenValidationParameters.DefaultAuthenticationType, Claims.Name, Claims.Role); // 使用client_id作为主题标识符。 identity.SetClaim(Claims.Subject, await _applicationManager.GetClientIdAsync(application)); identity.SetClaim(Claims.Name, await _applicationManager.GetDisplayNameAsync(application)); identity.SetDestinations(static claim => claim.Type switch { // 允许将“名称”声明存储在访问令牌和身份令牌中 // 授予“profile”作用域时（通过调用principle.SSetScope（…））。 Claims.Name when claim.Subject.HasScope(Scopes.Profile) => new[] { Destinations.AccessToken, Destinations.IdentityToken }, // 否则，只将声明存储在访问令牌中。 _ => new[] { Destinations.AccessToken } }); return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme); } } \",\"注册您的客户端应用程序（例如，从 IHostedService 实现）：\",\"public class Worker : IHostedService { private readonly IServiceProvider _serviceProvider; public Worker(IServiceProvider serviceProvider) => _serviceProvider = serviceProvider; public async Task StartAsync(CancellationToken cancellationToken) { using var scope = _serviceProvider.CreateScope(); var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>(); await context.Database.EnsureCreatedAsync(); var manager = scope.ServiceProvider.GetRequiredService<IOpenIddictApplicationManager>(); if (await manager.FindByClientIdAsync(\\\"console\\\") is null) { await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"console\\\", ClientSecret = \\\"388D45FA-B36B-4988-BA59-B187D329C207\\\", DisplayName = \\\"My client application\\\", Permissions = { Permissions.Endpoints.Token, Permissions.GrantTypes.ClientCredentials } }); } } public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask; } \",\"在运行应用程序之前，请确保通过运行 Add-Migration 和 Update-Database 更新数据库中的 OpenIddict 表。\"]},{\"header\":\"选择正确的流程\",\"slug\":\"选择正确的流程\",\"contents\":[\"OpenIddict 内置支持 OAuth 2.0 和 OpenID Connect 核心规范定义的所有标准流程：授权码流程、隐式流程、混合流程（基本上是前两个流程的混合）、资源拥有者密码凭据授权和客户端凭证授权。\",\"虽然这不是针对 OpenIddict 的特定内容，但在实现自己的授权服务器时选择最佳流程是一个重要的先决条件；因此，这里简要介绍一下不同的 OAuth 2.0 / OpenID Connect 流程。\"]},{\"header\":\"非交互式流程\",\"slug\":\"非交互式流程\",\"contents\":[]},{\"header\":\"资源拥有者密码凭据授权（不建议用于新的应用程序）\",\"slug\":\"资源拥有者密码凭据授权-不建议用于新的应用程序\",\"contents\":[\"受基本身份验证直接启发，资源拥有者密码凭据授权（缩写为ROPC）在概念上是最简单的OAuth 2.0流程：客户端应用程序要求用户输入其用户名/密码，使用用户凭据（根据授权服务器定义的客户端身份验证策略，可能还需要包括自己的客户端凭据）向授权服务器发送令牌请求，并获得可用于检索用户资源的访问令牌。\",\"源拥有者密码凭据授权流程\",\"POST /connect/token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=password&username=johndoe&password=A3ddj3w \",\"HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \\\"access_token\\\":\\\"2YotnFZFEjr1zCsicMWpAA\\\", \\\"token_type\\\":\\\"bearer\\\", \\\"expires_in\\\":3600 } \",\"警告\",\"此流程不被 OAuth 2.0 规范推荐，因为它是唯一一种将用户密码直接暴露给客户端应用程序的授权类型，这违反了最小特权原则，并使其不适合于无法被授权服务器完全信任的第三方客户端应用程序。\",\"尽管这种授权方式很受欢迎且容易实现（因为它不涉及任何重定向或同意表单，并且与交互式流程不同，不需要实现跨站点请求伪造（XSRF）对策以防止会话固定攻击），但不建议在新应用程序中使用。相反，鼓励用户使用授权码流程，该流程不会将密码暴露给客户端应用程序，并且不限于密码身份验证。\"]},{\"header\":\"客户端凭证授权（建议用于机器对机器通信）\",\"slug\":\"客户端凭证授权-建议用于机器对机器通信\",\"contents\":[\"客户端凭证授权与资源拥有者密码凭据授权几乎相同，只是它专门为客户端到服务器场景设计（此流程不涉及用户）：客户端应用程序发送包含其凭据的令牌请求，并获得可用于查询其自己资源的访问令牌。\",\"客户端凭证授权流程\",\"POST /connect/token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=client_credentials&client_id=s6BhdRkqt3&client_secret=gX1fBat3bV \",\"HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \\\"access_token\\\":\\\"2YotnFZFEjr1zCsicMWpAA\\\", \\\"token_type\\\":\\\"bearer\\\", \\\"expires_in\\\":3600 } \",\"相关信息\",\"与资源拥有者密码凭据授权不同，当使用客户端凭证授权时，客户端身份验证不是可选的，OpenIddict 将始终拒绝未经身份验证的令牌请求，这是 OAuth 2.0 规范所要求的。\",\"这意味着您不能将客户端凭证授权用于像浏览器、移动应用程序或桌面应用程序这样的公共应用程序，因为它们无法保持其凭据的机密性。\"]},{\"header\":\"交互式流程\",\"slug\":\"交互式流程\",\"contents\":[]},{\"header\":\"授权码流程（建议用于新应用程序）\",\"slug\":\"授权码流程-建议用于新应用程序\",\"contents\":[\"虽然授权码流程可能是最复杂的流程（因为它涉及到用户代理重定向和反向通信），但对于涉及终端用户的任何场景，无论他们是使用密码、PIN、智能卡甚至外部提供者登录，都建议使用该流程。作为回报，当在服务器端应用程序中使用此流程时，该流程具有很大优势：无法通过用户代理拦截访问令牌。\",\"授权码流程基本上有两个步骤：授权请求/响应 和 令牌请求/响应。\",\"授权码流程\",\"步骤1：授权请求\",\"在此流程中，客户端应用程序始终通过生成包括必填参数、其 response_type=code、其 client_id、其 redirect_uri 以及可选地包括一个 scope 和一个参数以允许传递自定义数据并帮助减轻 XSRF 攻击的 state 的授权请求来启动身份验证过程。\",\"相关信息\",\"在大多数情况下，客户端应用程序将只返回一个带有头部的 302 响应以重定向用户代理到授权终结点，但根据您正在使用的 OpenID Connect 客户端，可能还支持 POST 请求以允许您发送大型授权请求。通常，此功能是使用自动提交的 HTML 表单实现的。\",\"HTTP/1.1 302 Found Location: https://server.example.com/authorize?response_type=code&client_id=s6BhdRkqt3&state=af0ifjsldkj&redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb \",\"GET /connect/authorize?response_type=code&client_id=s6BhdRkqt3&state=af0ifjsldkj&redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1 Host: server.example.com \",\"身份提供者处理授权请求的方式因实现而异，但在大多数情况下，会显示一个同意表单询问用户是否同意与客户端应用程序共享他/她的个人数据。\",\"当授权被给予时，用户代理将被重定向回客户端应用程序，并返回一个名为授权码的唯一且生命周期短暂的令牌，客户端将能够通过发送令牌请求来交换它以获取访问令牌。\",\"HTTP/1.1 302 Found Location: https://client.example.org/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=af0ifjsldkj \",\"注意\",\"为了防止 XSRF/会话固定攻击，客户端应用程序必须确保身份提供者返回的 state 参数与原始状态相对应，并在两个值不匹配时停止处理授权响应。通常，这是通过生成不可猜测的字符串和相应的相关 cookie 来完成的。\",\"步骤2：令牌请求\",\"当客户端应用程序收到授权码后，必须立即通过发送令牌请求来兑换它以获取访问令牌。grant_type=authorization_code\",\"相关信息\",\"为了帮助身份提供者减轻伪造客户端攻击，还必须发送原始 redirect_uri。 如果客户端应用程序是保密应用程序（即已分配客户端凭据的应用程序），则需要进行身份验证。\",\"POST /connect/token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb&client_id=s6BhdRkqt3&client_secret=gX1fBat3bV&scope=openid \",\"HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \\\"access_token\\\":\\\"2YotnFZFEjr1zCsicMWpAA\\\", \\\"token_type\\\":\\\"bearer\\\", \\\"expires_in\\\":3600 } \",\"相关信息\",\"为了增加安全性，可以指定其他参数，例如 code_challenge 和 code_challenge_method，以将授权终结点返回的授权码绑定到原始授权请求。这种机制称为 Proof Key for Code Exchange，OpenIddict 完全支持它。\"]},{\"header\":\"隐式流程（不建议用于新应用程序）\",\"slug\":\"隐式流程-不建议用于新应用程序\",\"contents\":[\"隐式流程类似于授权码流程，但没有令牌请求/响应步骤：访问令牌直接作为授权响应的 URI 片段（或在使用 response_mode=form_post 时作为请求表单的一部分）返回给客户端应用程序。\",\"隐式流程\",\"GET /connect/authorize?response_type=token&client_id=s6BhdRkqt3&redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb&scope=openid&state=af0ifjsldkj&nonce=n-0S6_WzA2Mj HTTP/1.1 Host: server.example.com \",\"HTTP/1.1 302 Found Location: https://client.example.org/cb#access_token=SlAV32hkKG&token_type=bearer&expires_in=3600&state=af0ifjsldkj \",\"警告\",\"隐式流程最初是为浏览器应用程序设计的，它本质上比授权码流程不太安全，并且不支持 Proof Key for Code Exchange。因此，在新应用程序中使用它是不推荐的。\",\"注意\",\"为了防止 XSRF/会话固定攻击，客户端应用程序必须确保身份提供者返回的 state 参数与原始状态相对应，并在两个值不匹配时停止处理授权响应。通常，这是通过生成不可猜测的字符串和相应的值存储在本地存储中来完成的。\",\"当使用隐式流程时，客户端应用程序还必须确保访问令牌没有发给另一个应用程序，以防止混淆委托攻击。使用 OpenID Connect 时，可以通过使用并检查 JWT 身份令牌的声明来完成此操作，该声明必须对应或包含客户端应用程序的 aud（受众）声明。 response_type=id_token token&aud&client_id。\"]},{\"header\":\"配置\",\"slug\":\"配置\",\"contents\":[]},{\"header\":\"介绍\",\"slug\":\"介绍-1\",\"contents\":[\"OpenIddict 3.0 提供了合理的默认值，但是根据情况，可以修改默认设置以更改 OpenIddict 对请求的响应方式。\"]},{\"header\":\"应用程序权限\",\"slug\":\"应用程序权限\",\"contents\":[\"OpenIddict 包含一个内置功能，称为“应用程序权限”，允许控制和限制每个注册的客户端应用程序能够使用的 OAuth 2.0/OpenID Connect 功能。\",\"当前支持 4 种权限类别：\",\"端点权限。\",\"授予类型权限。\",\"范围权限。\",\"响应类型权限（在 OpenIddict 3.0 中引入）。\"]},{\"header\":\"端点权限\",\"slug\":\"端点权限\",\"contents\":[]},{\"header\":\"定义\",\"slug\":\"定义\",\"contents\":[\"端点权限限制客户端应用程序可以使用的端点。\"]},{\"header\":\"支持的权限\",\"slug\":\"支持的权限\",\"contents\":[\"端点\",\"常量\",\"Authorization(授权)\",\"OpenIddictConstants.Permissions.Endpoints.Authorization\",\"Introspection(验证)\",\"OpenIddictConstants.Permissions.Endpoints.Introspection\",\"Logout/end session(注销/结束会话)\",\"OpenIddictConstants.Permissions.Endpoints.Logout\",\"Revocation(撤销)\",\"OpenIddictConstants.Permissions.Endpoints.Revocation\",\"Token(令牌)\",\"OpenIddictConstants.Permissions.Endpoints.Token\"]},{\"header\":\"示例\",\"slug\":\"示例\",\"contents\":[\"在下面的示例中，允许应用程序使用授权、注销和令牌端点，但在尝试发送验证或撤销请求时会出错：mvc\",\"if (await manager.FindByClientIdAsync(\\\"mvc\\\") is null) { await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"mvc\\\", ClientSecret = \\\"901564A5-E7FE-42CB-B10D-61EF6A8F3654\\\", DisplayName = \\\"MVC client application\\\", PostLogoutRedirectUris = { new Uri(\\\"http://localhost:53507/signout-callback-oidc\\\") }, RedirectUris = { new Uri(\\\"http://localhost:53507/signin-oidc\\\") }, Permissions = { OpenIddictConstants.Permissions.Endpoints.Authorization, OpenIddictConstants.Permissions.Endpoints.Logout, OpenIddictConstants.Permissions.Endpoints.Token } }); } \"]},{\"header\":\"禁用端点权限\",\"slug\":\"禁用端点权限\",\"contents\":[\"如果您不想使用端点权限，请调用 options.IgnoreEndpointPermissions() 来忽略它们。\",\"services.AddOpenIddict() .AddServer(options => { options.IgnoreEndpointPermissions(); }); \"]},{\"header\":\"授权类型权限\",\"slug\":\"授权类型权限\",\"contents\":[]},{\"header\":\"定义\",\"slug\":\"定义-1\",\"contents\":[\"授权类型权限限制客户端应用程序可以使用的授权类型。\"]},{\"header\":\"支持的权限\",\"slug\":\"支持的权限-1\",\"contents\":[\"授权类型\",\"常量\",\"Authorization code(授权码)\",\"OpenIddictConstants.Permissions.GrantTypes.AuthorizationCode\",\"Client credentials(客户端凭据)\",\"OpenIddictConstants.Permissions.GrantTypes.ClientCredentials\",\"Implicit(隐式授权)\",\"OpenIddictConstants.Permissions.GrantTypes.Implicit\",\"Password(密码授权)\",\"OpenIddictConstants.Permissions.GrantTypes.Password\",\"Refresh token(刷新令牌)\",\"OpenIddictConstants.Permissions.GrantTypes.RefreshToken\",\"要添加自定义授权类型权限，可以使用以下模式：\",\"OpenIddictConstants.Permissions.Prefixes.GrantType + \\\"custom_flow_name\\\" \"]},{\"header\":\"示例\",\"slug\":\"示例-1\",\"contents\":[\"在下面的示例中，应用程序只能使用授权码授权，而密码授权和刷新令牌授权受到限制：postman, console, password, refresh_token\",\"if (await manager.FindByClientIdAsync(\\\"postman\\\") is null) { await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"postman\\\", DisplayName = \\\"Postman\\\", RedirectUris = { new Uri(\\\"https://www.getpostman.com/oauth2/callback\\\") }, Permissions = { OpenIddictConstants.Permissions.Endpoints.Authorization, OpenIddictConstants.Permissions.Endpoints.Token, OpenIddictConstants.Permissions.GrantTypes.AuthorizationCode } }); } if (await manager.FindByClientIdAsync(\\\"console\\\") is null) { await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"console\\\", DisplayName = \\\"Console\\\", Permissions = { OpenIddictConstants.Permissions.Endpoints.Token, OpenIddictConstants.Permissions.GrantTypes.Password, OpenIddictConstants.Permissions.GrantTypes.RefreshToken } }); } \"]},{\"header\":\"禁用授权类型权限\",\"slug\":\"禁用授权类型权限\",\"contents\":[\"如果您不想使用授权类型权限，请调用 options.IgnoreGrantTypePermissions() 来忽略它们。\",\"services.AddOpenIddict() .AddServer(options => { options.IgnoreGrantTypePermissions(); }); \"]},{\"header\":\"范围权限\",\"slug\":\"范围权限\",\"contents\":[]},{\"header\":\"定义\",\"slug\":\"定义-2\",\"contents\":[\"范围权限限制客户端应用程序可以使用的范围（标准或自定义）。\",\"相关信息\",\"openid 和 offline_access 范围由 OpenIddict 特殊处理，不需要显式授权。\"]},{\"header\":\"支持的权限\",\"slug\":\"支持的权限-2\",\"contents\":[\"范围\",\"常量\",\"address(地址)\",\"OpenIddictConstants.Permissions.Scopes.Address\",\"email(电子邮件)\",\"OpenIddictConstants.Permissions.Scopes.Email\",\"phone(电话)\",\"OpenIddictConstants.Permissions.Scopes.Phone\",\"profile(个人资料)\",\"OpenIddictConstants.Permissions.Scopes.Profile\",\"roles(角色)\",\"OpenIddictConstants.Permissions.Scopes.Roles\",\"要添加自定义范围权限，可以使用以下模式：\",\"OpenIddictConstants.Permissions.Prefixes.Scope + \\\"custom_scope_name\\\" \"]},{\"header\":\"示例\",\"slug\":\"示例-2\",\"contents\":[\"在下面的示例中，客户端允许请求 openid、address、profile 和 marketing_api 范围，而请求其他范围将导致返回错误：angular, address, profile, marketing_api\",\"if (await manager.FindByClientIdAsync(\\\"angular\\\") is null) { await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"angular\\\", DisplayName = \\\"Angular\\\", RedirectUris = { new Uri(\\\"https://localhost:34422/callback\\\") }, Permissions = { OpenIddictConstants.Permissions.Endpoints.Authorization, OpenIddictConstants.Permissions.GrantTypes.Implicit, OpenIddictConstants.Permissions.Scopes.Address, OpenIddictConstants.Permissions.Scopes.Profile, OpenIddictConstants.Permissions.Prefixes.Scope + \\\"marketing_api\\\" } }); } \"]},{\"header\":\"禁用范围权限\",\"slug\":\"禁用范围权限\",\"contents\":[\"如果您不想使用范围权限，请调用 options.IgnoreScopePermissions() 来忽略它们。\"]},{\"header\":\"响应类型权限\",\"slug\":\"响应类型权限\",\"contents\":[\"相关信息\",\"响应类型权限是在 OpenIddict 3.0 中引入的。\"]},{\"header\":\"定义\",\"slug\":\"定义-3\",\"contents\":[\"响应类型权限限制客户端应用程序在实现诸如授权码、隐式或混合等交互式流程时可以使用的响应类型。\"]},{\"header\":\"支持的权限\",\"slug\":\"支持的权限-3\",\"contents\":[\"响应类型\",\"常量\",\"code\",\"OpenIddictConstants.Permissions.ResponseTypes.Code\",\"code Id_Token\",\"OpenIddictConstants.Permissions.ResponseTypes.CodeIdToken\",\"code Id_Token Token\",\"OpenIddictConstants.Permissions.ResponseTypes.CodeIdTokenToken\",\"code Token\",\"OpenIddictConstants.Permissions.ResponseTypes.CodeToken\",\"id_token\",\"OpenIddictConstants.Permissions.ResponseTypes.IdToken\",\"id_token Token\",\"OpenIddictConstants.Permissions.ResponseTypes.IdTokenToken\",\"none\",\"OpenIddictConstants.Permissions.ResponseTypes.None\",\"token\",\"OpenIddictConstants.Permissions.ResponseTypes.Token\"]},{\"header\":\"示例\",\"slug\":\"示例-3\",\"contents\":[\"在下面的示例中，应用程序只能使用响应类型 postman, code id_token\",\"if (await manager.FindByClientIdAsync(\\\"postman\\\") is null) { await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"postman\\\", DisplayName = \\\"Postman\\\", RedirectUris = { new Uri(\\\"https://www.getpostman.com/oauth2/callback\\\") }, Permissions = { OpenIddictConstants.Permissions.Endpoints.Authorization, OpenIddictConstants.Permissions.Endpoints.Token, OpenIddictConstants.Permissions.GrantTypes.AuthorizationCode, OpenIddictConstants.Permissions.ResponseTypes.CodeIdToken } }); } \"]},{\"header\":\"禁用响应类型权限\",\"slug\":\"禁用响应类型权限\",\"contents\":[\"如果您不想使用响应类型权限，请调用 options.IgnoreResponseTypePermissions() 来忽略它们。\",\"services.AddOpenIddict() .AddServer(options => { options.IgnoreResponseTypePermissions(); }); \"]},{\"header\":\"授权存储\",\"slug\":\"授权存储\",\"contents\":[\"为了跟踪令牌和用户同意的逻辑链路，OpenIddict 支持在数据库中存储授权（有些 OpenID Connect 实现中也称之为“grants(授权)”）。\"]},{\"header\":\"授权类型\",\"slug\":\"授权类型\",\"contents\":[\"授权可以是两种类型：永久性和即席性。\"]},{\"header\":\"永久性授权\",\"slug\":\"永久性授权\",\"contents\":[\"永久性授权是使用 API 创建的开发人员定义的授权，并使用 OpenIddict 特定的扩展方法显式附加到 IOpenIddictAuthorizationManager.CreateAsync() 和 ClaimsPrincipalprincipal.SetAuthorizationId() 上。\",\"此类授权通常用于记住用户同意并避免为每个授权请求显示同意视图。为此，可以为每个应用程序定义一个“同意类型”，如下例所示：\",\"// 从数据库中检索应用程序详细信息。 var application = await _applicationManager.FindByClientIdAsync(request.ClientId) ?? throw new InvalidOperationException(\\\"The application cannot be found.\\\"); // 检索与用户和应用程序关联的永久授权。 var authorizations = await _authorizationManager.FindAsync( subject: await _userManager.GetUserIdAsync(user), // 获取用户ID client : await _applicationManager.GetIdAsync(application), // 获取应用程序ID status : Statuses.Valid, // 授权状态：有效 type : AuthorizationTypes.Permanent, // 授权类型：永久 scopes : request.GetScopes()) // 获取请求的作用域 .ToListAsync(); // 转换为List switch (await _applicationManager.GetConsentTypeAsync(application)) // 获取同意类型 { // 如果同意是外部的（例如，当系统管理员授予授权时）， // 如果在数据库中找不到授权，则立即返回错误。 case ConsentTypes.External when !authorizations.Any(): // 当同意类型为External且没有找到授权时 return Forbid( authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme, properties: new AuthenticationProperties(new Dictionary<string, string> { [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.ConsentRequired, // 错误类型：ConsentRequired [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = \\\"The logged in user is not allowed to access this client application.\\\" // 错误描述 })); // 如果同意是隐含的或者如果发现授权， // 在不显示同意书的情况下返回授权响应。 case ConsentTypes.Implicit: // 当同意类型为Implicit时 case ConsentTypes.External when authorizations.Any(): // 当同意类型为External且找到授权时 case ConsentTypes.Explicit when authorizations.Any() && !request.HasPrompt(Prompts.Consent): // 当同意类型为Explicit，有授权，并且请求不要求明确同意时 // 创建OpenIddict将用于生成令牌的基于声明的标识。 var identity = new ClaimsIdentity( authenticationType: TokenValidationParameters.DefaultAuthenticationType, // 认证类型 nameType: Claims.Name, // 名称类型 roleType: Claims.Role); // 角色类型 // 添加将在令牌中持久化的声明。 identity.SetClaim(Claims.Subject, await _userManager.GetUserIdAsync(user)) // 用户主题ID .SetClaim(Claims.Email, await _userManager.GetEmailAsync(user)) // 用户电子邮件 .SetClaim(Claims.Name, await _userManager.GetUserNameAsync(user)) // 用户名称 .SetClaims(Claims.Role, (await _userManager.GetRolesAsync(user)).ToImmutableArray()); // 用户角色 // 注意：在此示例中，授予的作用域与请求的作用域匹配 // 但是您可能希望允许用户取消选中特定的作用域。 // 为此，只需在调用SetScope之前限制作用域列表即可。 identity.SetScopes(request.GetScopes()); // 设置标识的作用域 identity.SetResources(await _scopeManager.ListResourcesAsync(identity.GetScopes()).ToListAsync()); // 设置标识关联的资源 // 自动创建永久授权以避免需要明确同意 // 用于将来包含相同作用域的授权或令牌请求。 var authorization = authorizations.LastOrDefault(); // 获取最近的授权，如果没有则为null authorization ??= await _authorizationManager.CreateAsync( identity: identity, subject : await _userManager.GetUserIdAsync(user), // 授权主题：用户ID client : await _applicationManager.GetIdAsync(application), // 授权客户端：应用程序ID type : AuthorizationTypes.Permanent, // 授权类型：永久 scopes : identity.GetScopes()); // 授权作用域：标识的作用域 identity.SetAuthorizationId(await _authorizationManager.GetIdAsync(authorization)); // 设置标识关联的授权ID identity.SetDestinations(static claim => claim.Type switch // 设置标识关联的目的地 { // 如果授予了“概要文件”范围，则允许“名称”声明 // 添加到从主体派生的访问令牌和身份令牌中。 Claims.Name when claim.Subject.HasScope(Scopes.Profile) => new[] { OpenIddictConstants.Destinations.AccessToken, OpenIddictConstants.Destinations.IdentityToken }, // 永远不要将“secret_value”声明添加到访问或身份令牌中。 // 在这种情况下，它将仅被添加到授权代码中， // 刷新令牌和用户/设备代码，它们总是被加密的。 \\\"secret_value\\\" => Array.Empty<string>(), // 否则，只将声明添加到访问令牌中。 _ => new[] { OpenIddictConstants.Destinations.AccessToken } }); return SignIn(new ClaimsPrincipal(identity), OpenIddictServerAspNetCoreDefaults.AuthenticationScheme); // 返回包含标识的登录响应 // 此时，在数据库中未找到授权，必须返回错误 // 如果客户端应用程序在授权请求中指定了prompt＝none。 case ConsentTypes.Explicit when request.HasPrompt(Prompts.None): // 当同意类型为Explicit且请求指定了prompt=none时 case ConsentTypes.Systematic when request.HasPrompt(Prompts.None): // 当同意类型为Systematic且请求指定了prompt=none时 return Forbid( authenticationSchemes: OpenIddictServerAspNetCoreDefaults.AuthenticationScheme, properties: new AuthenticationProperties(new Dictionary<string, string> { [OpenIddictServerAspNetCoreConstants.Properties.Error] = Errors.ConsentRequired, // 错误类型：ConsentRequired [OpenIddictServerAspNetCoreConstants.Properties.ErrorDescription] = \\\"Interactive user consent is required.\\\" // 错误描述 })); // 在其他情况下，提交同意书。 default: return View(new AuthorizeViewModel // 显示授权视图 { ApplicationName = await _applicationManager.GetLocalizedDisplayNameAsync(application), // 获取应用程序显示名称 Scope = request.Scope // 获取请求的作用域 }); } \"]},{\"header\":\"临时授权\",\"slug\":\"临时授权\",\"contents\":[\"当出于安全原因需要跟踪令牌链，但开发人员没有将显式的永久性授权附加到用于登录操作的 ClaimsPrincipal 时，OpenIddict 会自动创建临时授权。\",\"此类授权通常在授权码流程中创建，以连接与原始授权代码关联的所有令牌，以便在授权代码被多次兑换（这可能表示令牌泄漏）时可以自动撤销它们。同样，当使用资源所有者密码凭据授权请求返回刷新令牌时，也会创建临时授权。\",\"相关信息\",\"使用 OpenIddict.Quartz 集成时，临时授权将在短时间内（默认为14天）自动从数据库中删除。与临时授权不同，永久性授权永远不会从数据库中删除。\"]},{\"header\":\"在 API 级别启用授权条目验证\",\"slug\":\"在-api-级别启用授权条目验证\",\"contents\":[\"出于性能考虑，默认情况下，当收到 API 请求时，OpenIddict 3.0 不会检查授权条目的状态：即使附加的授权已被撤销，访问令牌也被视为有效。对于需要立即撤销授权的场景，可以配置 OpenIddict 验证处理程序以强制执行每个 API 请求的授权条目验证：\",\"相关信息\",\"启用授权条目验证要求 OpenIddict 验证处理程序能够直接访问服务器数据库，其中包含授权。这使得它更适用于位于授权服务器相同应用程序中的 API。对于外部应用程序，请考虑使用内省而不是本地验证。\",\"在两种情况下，都需要额外的延迟——由于额外的 DB 请求和内省的 HTTP 调用而引起。\",\"services.AddOpenIddict() .AddValidation(options => { options.EnableAuthorizationEntryValidation(); }); \"]},{\"header\":\"禁用授权存储\",\"slug\":\"禁用授权存储\",\"contents\":[\"虽然强烈不建议这样做，但可以在服务器选项中禁用授权存储：\",\"services.AddOpenIddict() .AddServer(options => { options.DisableAuthorizationStorage(); }); \"]},{\"header\":\"声明目标\",\"slug\":\"声明目标\",\"contents\":[\"在生成授权码、刷新令牌和设备/用户代码时，OpenIddict 会自动将指定登录操作期间的所有声明复制到生成的代码/令牌中。这是安全的操作，因为这些令牌始终加密，并且除了 OpenIddict 本身之外，没有人可以读取它们（用户或请求它们的客户端应用程序无法读取其内容）。\",\"对于访问令牌和身份令牌，则有所不同，因为这些令牌旨在由不同的方使用：\",\"客户端应用程序完全可以访问包含在其接收到的身份令牌中的声明。\",\"预期资源服务器可以读取用于 API 调用中的访问令牌中包含的声明。\",\"对于桌面、移动或基于浏览器的应用程序，通常很容易让用户访问身份令牌（例如，通过使用 Fiddler 拦截 HTTP 响应、使用开发工具或转储客户端进程的内存）。\",\"如果明确禁用了访问令牌加密，则客户端应用程序或用户本身可以访问访问令牌的内容（例如，通过复制令牌有效负载并使用像 https：//jwt.io/ 这样的工具）。\",\"出于这些原因，OpenIddict 不会自动将附加到 ClaimsPrincipal 的声明复制到访问或身份令牌中（除了 claim，这是 OpenIddict 中唯一强制性的声明）。为了允许 OpenIddict 将特定声明持久化到访问或身份令牌中，必须向每个要公开的实例添加称为“声明目标”的标志。\",\"相关信息\",\"要附加一个或多个目标到一个声明，请使用在 . 中定义的扩展。在典型情况下，授予的范围可以用于确定允许将哪些声明复制到访问和身份令牌中，如下面的示例所示：principal.SetDestinations(),OpenIddict.Abstractions\",\"var principal = await _signInManager.CreateUserPrincipalAsync(user); // 注意：在此示例中，授予的作用域与请求的作用域匹配 // 但是您可能希望允许用户取消选中特定的作用域。 // 为此，只需在调用SetScope（）之前限制作用域列表即可。 principal.SetScopes(request.GetScopes()); principal.SetResources(await _scopeManager.ListResourcesAsync(principal.GetScopes()).ToListAsync()); principal.SetDestinations(static claim => claim.Type switch { // 如果授予了“概要文件”范围，则允许“名称”声明 // 添加到从主体派生的访问令牌和身份令牌中。 Claims.Name when claim.Subject.HasScope(Scopes.Profile) => new[] { OpenIddictConstants.Destinations.AccessToken, OpenIddictConstants.Destinations.IdentityToken }, // 永远不要将“secret_value”声明添加到访问或身份令牌中。 // 在这种情况下，它将仅被添加到授权代码中， // 刷新令牌和用户/设备代码，它们总是被加密的。 \\\"secret_value\\\" => Array.Empty<string>(), // 否则，只将声明添加到访问令牌中。 _ => new[] { OpenIddictConstants.Destinations.AccessToken } }); return SignIn(principal, OpenIddictServerAspNetCoreDefaults.AuthenticationScheme); \"]},{\"header\":\"加密和签名凭据\",\"slug\":\"加密和签名凭据\",\"contents\":[\"为了保护其发行的令牌，OpenIddict 使用两种类型的凭据：\",\"签名凭据用于防止篡改。它们可以是非对称的（例如 RSA 或 ECDSA 密钥）或对称的。\",\"加密凭据用于确保令牌内容无法被恶意方读取。它们可以是非对称的（例如 RSA 密钥）或对称的。\",\"相关信息\",\"使用选择加入的 ASP.NET Core 数据保护集成生成的令牌依赖于其自己的密钥环，与本文档中讨论的凭据不同。\",\"有关数据保护的更多信息，请访问 ASP.NET Core 数据保护。\"]},{\"header\":\"在授权服务器选项中注册凭据\",\"slug\":\"在授权服务器选项中注册凭据\",\"contents\":[\"OpenIddict 允许注册一个或多个键（原始键或嵌入 X.509 证书中的键）。\",\"当注册多个键/证书时（这可能有助于实现密钥轮换），OpenIddict 根据以下算法选择最合适的键：\",\"相关信息\",\"首先始终选择对称键，除了只能使用非对称键签名的身份令牌。 嵌入 X.509 证书的非对称键根据 NotAfter 和 NotBefore 日期进行排序（未生效的证书不会被 OpenIddict 使用，并且到期日期最远的证书始终优先使用）。 X.509 证书总是优先于原始 RSA/ECDSA 键。\"]},{\"header\":\"注册临时密钥\",\"slug\":\"注册临时密钥\",\"contents\":[\"为了开发目的，可以使用一种临时密钥（不持久化或跨实例共享），用于签署或加密令牌：\",\"services.AddOpenIddict() .AddServer(options => { options.AddEphemeralEncryptionKey() .AddEphemeralSigningKey(); }); \",\"相关信息\",\"options.AddEphemeralEncryptionKey() 生成非对称 RSA 密钥，该密钥不直接用于加密令牌，而是用于使用 AES 加密令牌内容的每个令牌对称密钥的加密。\",\"有关此机制的更多信息，请参阅使用 RSAES OAEP 进行密钥加密。\"]},{\"header\":\"注册开发证书\",\"slug\":\"注册开发证书\",\"contents\":[\"为了开发目的，可以由 OpenIddict 生成并存储证书在运行 OpenIddict 服务器功能的用户帐户的证书存储区中。与临时密钥不同，开发证书是持久的（但不跨实例共享），并且在重新启动应用程序主机时将被重复使用。\",\"services.AddOpenIddict() .AddServer(options => { options.AddDevelopmentEncryptionCertificate() .AddDevelopmentSigningCertificate(); }); \",\"注意\",\"此功能在 .NET Framework 4.6.1 上不可用：调用 options.AddDevelopmentEncryptionCertificate() 或 options.AddDevelopmentSigningCertificate() 将在运行时引发 PlatformNotSupportedException，如果找不到有效的开发证书并且必须生成一个新证书，则会抛出异常。\",\"警告\",\"无法在部署在 IIS 或 Azure App Service 上的应用程序中使用它们：尝试在 IIS 或 Azure App Service 上使用它们将在运行时引发异常（除非应用程序池配置为加载用户配置文件）。为避免这种情况，请考虑创建自签名证书并将其存储在主机机器的 X.509 证书存储区中。\"]},{\"header\":\"注册密钥\",\"slug\":\"注册密钥\",\"contents\":[\"要注册签名或加密密钥，可以提供 - 通常是 SecurityKeySymmetricSecurityKeyRsaSecurityKey 的实例 - 给 options.AddSigningKey() / options.AddEncryptionKey() 方法：\",\"services.AddOpenIddict() .AddServer(options => { options.AddEncryptionKey(new SymmetricSecurityKey( Convert.FromBase64String(\\\"DRjd/GnduI3Efzen9V9BvbNUfc/VKgXltV7Kbk9sMkY=\\\"))); }); \",\"相关信息\",\"虽然签名密钥可以是对称的或非对称的，但 OpenIddict 要求注册至少一个非对称密钥以签署身份令牌。如果注册了非对称和对称签名密钥，则在保护访问令牌、授权码或刷新令牌时始终优先选择对称密钥，而在签署旨在公开验证的身份令牌时使用非对称密钥。\"]},{\"header\":\"注册证书（建议用于生产准备环境）\",\"slug\":\"注册证书-建议用于生产准备环境\",\"contents\":[\"要注册签名或加密证书，可以使用 X509Certificate2 的实例调用 options.AddSigningCertificate() / options.AddEncryptionCertificate() 方法。另外，也可以提供唯一标识操作系统机器或用户证书存储区中证书的指纹。\",\"在生产环境中，建议使用两个 RSA 证书，与用于 HTTPS 的证书不同：一个用于加密，一个用于签名。可以使用 .NET Core API 在本地生成和自签名证书：CertificateRequest\",\"using var algorithm = RSA.Create(keySizeInBits: 2048); var subject = new X500DistinguishedName(\\\"CN=Fabrikam Encryption Certificate\\\"); var request = new CertificateRequest(subject, algorithm, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.KeyEncipherment, critical: true)); var certificate = request.CreateSelfSigned(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddYears(2)); File.WriteAllBytes(\\\"encryption-certificate.pfx\\\", certificate.Export(X509ContentType.Pfx, string.Empty)); \",\"using var algorithm = RSA.Create(keySizeInBits: 2048); var subject = new X500DistinguishedName(\\\"CN=Fabrikam Signing Certificate\\\"); var request = new CertificateRequest(subject, algorithm, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); request.CertificateExtensions.Add(new X509KeyUsageExtension(X509KeyUsageFlags.DigitalSignature, critical: true)); var certificate = request.CreateSelfSigned(DateTimeOffset.UtcNow, DateTimeOffset.UtcNow.AddYears(2)); File.WriteAllBytes(\\\"signing-certificate.pfx\\\", certificate.Export(X509ContentType.Pfx, string.Empty)); \",\"最佳的证书存储位置取决于您的托管环境：\",\"对于 IIS 应用程序，将证书存储在机器存储区中是推荐的选项。\",\"在 Azure 上，可以使用特殊标志上传和公开证书以供 Azure App Service 应用程序使用。有关更多信息，请访问 在 Azure App Service 中的代码中使用 TLS/SSL 证书 页面。\"]},{\"header\":\"在API/资源验证选项中导入凭据。\",\"slug\":\"在api-资源验证选项中导入凭据。\",\"contents\":[]},{\"header\":\"使用集成选项 options.UseLocalServer()\",\"slug\":\"使用集成选项-options-uselocalserver\",\"contents\":[\"当 API 和授权服务器属于同一项目时，可以通过调用 options.UseLocalServer() 轻松导入签名和加密凭据\",\"services.AddOpenIddict() .AddValidation(options => { options.UseLocalServer(); }); \"]},{\"header\":\"使用 OpenID Connect 常规发现（仅限非对称签名密钥）\",\"slug\":\"使用-openid-connect-常规发现-仅限非对称签名密钥\",\"contents\":[\"当 API 和授权服务器托管在不同的应用程序中时，可以使用标准 OpenID Connect 发现来自动导入非对称签名密钥：\",\"services.AddOpenIddict() .AddValidation(options => { options.SetIssuer(\\\"https://localhost:44319/\\\"); options.UseSystemNetHttp(); }); \"]},{\"header\":\"在令牌验证参数中注册对称签名密钥\",\"slug\":\"在令牌验证参数中注册对称签名密钥\",\"contents\":[\"与非对称签名密钥不同，使用基于 HMAC 的算法（如 HS256）的对称密钥不能通过 OpenID Connect 发现端点安全地公开。因此，OpenIddict 验证处理程序无法自动导入它们。对于需要使用对称签名密钥的应用程序，可以使用高级配置 API 将其注册到令牌验证选项中：\",\"services.AddOpenIddict() .AddValidation(options => { options.Configure(options => options.TokenValidationParameters.IssuerSigningKey = new SymmetricSecurityKey( Convert.FromBase64String(\\\"DRjd/GnduI3Efzen9V9BvbNUfc/VKgXltV7Kbk9sMkY=\\\"))); }); \"]},{\"header\":\"注册加密密钥或证书\",\"slug\":\"注册加密密钥或证书\",\"contents\":[\"要导入加密密钥/证书，可以使用与 OpenIddict 服务器功能公开的相同重载：\",\"services.AddOpenIddict() .AddValidation(options => { options.AddEncryptionCertificate(\\\"b82f36609cdaff9a95de60e8d5ac774b2e496c4b\\\"); }); \"]},{\"header\":\"用于代码交换的验证密钥(Proof Key for Code Exchange)\",\"slug\":\"用于代码交换的验证密钥-proof-key-for-code-exchange\",\"contents\":[\"最初，Proof Key for Code Exchange（PKCE）机制被设计为一种保护移动应用程序免受恶意应用程序在同一设备上安装后看到其回调 URI 被劫持的方法。现已将此机制扩展到机密客户端，以帮助减轻授权代码泄漏。该机制被所有版本的 OpenIddict 完全支持，并可全局或按客户端进行强制执行，以阻止未发送 PKCE 参数的授权请求。\"]},{\"header\":\"在全局级别启用 PKCE 执行\",\"slug\":\"在全局级别启用-pkce-执行\",\"contents\":[\"可以通过在服务器选项中调用 options.RequireProofKeyForCodeExchange() 来全局强制执行 Proof Key for Code Exchange。\",\"services.AddOpenIddict() .AddServer(options => { options.RequireProofKeyForCodeExchange(); }); \"]},{\"header\":\"按客户端启用 PKCE 强制执行\",\"slug\":\"按客户端启用-pkce-强制执行\",\"contents\":[\"可以通过将其添加到附加到客户端的要求列表中，按客户端强制执行 Proof Key for Code Exchange。\",\"await manager.CreateAsync(new OpenIddictApplicationDescriptor { ClientId = \\\"mvc\\\", ClientSecret = \\\"901564A5-E7FE-42CB-B10D-61EF6A8F3654\\\", ConsentType = ConsentTypes.Explicit, PostLogoutRedirectUris = { new Uri(\\\"https://localhost:44381/signout-callback-oidc\\\") }, RedirectUris = { new Uri(\\\"https://localhost:44381/signin-oidc\\\") }, Permissions = { Permissions.Endpoints.Authorization, Permissions.Endpoints.Logout, Permissions.Endpoints.Token, Permissions.GrantTypes.AuthorizationCode, Permissions.GrantTypes.RefreshToken, Permissions.ResponseTypes.Code, Permissions.Scopes.Email, Permissions.Scopes.Profile, Permissions.Scopes.Roles, Permissions.Prefixes.Scope + \\\"demo_api\\\" }, Requirements = { Requirements.Features.ProofKeyForCodeExchange } }); \"]},{\"header\":\"启用支持 code_challenge_method=plain\",\"slug\":\"启用支持-code-challenge-method-plain\",\"contents\":[\"默认情况下，OpenIddict 仅支持 code_challenge_method=S256，这是最安全的代码挑战方法，并且是 PKCE 规范所要求的唯一方法。虽然不建议使用，但是可以通过将其添加到 OpenIddictServerOptions.CodeChallengeMethods 中来手动启用该方法：code_challenge_method=S256、code_challenge_method=plain\",\"services.AddOpenIddict() .AddServer(options => { options.Configure(options => options.CodeChallengeMethods.Add(CodeChallengeMethods.Plain)); }); \"]},{\"header\":\"令牌格式\",\"slug\":\"令牌格式\",\"contents\":[\"相关信息\",\"在 OpenIddict 3.0 中，撤销令牌的能力与令牌格式无关，并且不需要启用引用令牌：只要未在服务器选项中显式禁用令牌存储，就可以撤销常规 JWT 或 ASP.NET Core 数据保护 令牌。\",\"有关引用令牌的更多信息，请阅读令牌存储。\"]},{\"header\":\"JSON Web Token\",\"slug\":\"json-web-token\",\"contents\":[\"OpenIddict 3.0 实现了 JSON Web Token、JSON Web Signature 和 JSON Web Encryption 标准，并依赖于由 Microsoft 开发和维护的 Azure Active Directory IdentityModel Extensions for .NET 库，使用在服务器选项中注册的凭据生成已签名和加密的令牌。\"]},{\"header\":\"JWT 令牌类型\",\"slug\":\"jwt-令牌类型\",\"contents\":[\"为了防止令牌替换和混淆代理攻击，OpenIddict 3.0 使用标准 JWT 标头 typ 来传递实际的令牌类型。该机制替换了先前版本的 OpenIddict 中用于相同目的的私有声明 token_usage。\",\"按照 OAuth 2.0 访问令牌的 JSON Web Token（JWT）配置文件规范的要求，由 OpenIddict 3.0 生成的访问令牌始终带有 “typ”: “at+jwt” 标头，而身份令牌仍然使用以保持向后兼容性。其他类型的令牌 - 仅被 OpenIddict 自己的端点接受 - 使用以 \\\"typ\\\": \\\"JWT\\\"oi_ 为前缀的私有令牌类型。\"]},{\"header\":\"禁用 JWT 访问令牌加密\",\"slug\":\"禁用-jwt-访问令牌加密\",\"contents\":[\"默认情况下，OpenIddict 强制执行其支持的所有令牌类型的加密。出于安全原因，虽然无法为授权代码、刷新令牌和设备代码禁用此强制执行，但是当需要与第三方 API/资源服务器集成时，可以放宽对访问令牌的加密要求。如果接收访问令牌的资源服务器不完全支持 JSON Web Encryption，则还可以禁用访问令牌加密。\",\"services.AddOpenIddict() .AddServer(options => { options.DisableAccessTokenEncryption(); }); \"]},{\"header\":\"ASP.NET Core 数据保护\",\"slug\":\"asp-net-core-数据保护\",\"contents\":[\"OpenIddict 3.0 还可以配置为使用 ASP.NET Core 数据保护 创建数据保护令牌，而不是 JWT 令牌。ASP.NET Core 数据保护 使用自己的密钥环来加密和保护令牌免受篡改，并支持所有类型的令牌，除了始终为 JWT 令牌的身份令牌。\",\"与 JWT 不同，ASP.NET Core 数据保护 令牌仅支持对称加密，并依赖于由 ASP.NET 团队开发的二进制格式，而不是像 JWT 那样依赖于标准。虽然这防止了在需要互操作性的场景中使用此类令牌，但选择 ASP.NET Core 数据保护 而不是 JWT 具有以下优点：\",\"ASP.NET Core 数据保护 令牌不使用 JSON 表示形式，因此通常比较短。\",\"ASP.NET Core 数据保护 已经被设计为实现高吞吐量，因为它是 ASP.NET Core 用于身份验证 cookie、防伪令牌和会话 cookie 的本地工具。\",\"注意\",\"尽管它的名称是 ASP.NET Core 数据保护，但它并不局限于 ASP.NET Core，并且可以在任何 .NET Standard 2.0 兼容的应用程序中使用，包括使用 Microsoft.Owin 的旧版 ASP.NET 4.6.1（及更高版本）应用程序。\",\"要在 OpenIddict OWIN 服务器和验证主机中启用 ASP.NET Core 数据保护 支持，需要手动引用 OpenIddict.Server.DataProtection 和 OpenIddict.Validation.DataProtection 包。\"]},{\"header\":\"切换到 Data Protection 令牌\",\"slug\":\"切换到-data-protection-令牌\",\"contents\":[\"ASP.NET Core 数据保护 支持由 OpenIddict.Server.DataProtection 和 OpenIddict.Validation.DataProtection 包提供。这些包由 OpenIddict.AspNetCore 元包引用，因此无需显式引用。\",\"要启用 ASP.NET Core 数据保护 支持，请在服务器选项和验证选项中调用 options.UseDataProtection()。\",\"services.AddOpenIddict() .AddServer(options => { options.UseDataProtection(); }) .AddValidation(options => { options.UseDataProtection(); }); \",\"相关信息\",\"切换到 ASP.NET Core 数据保护 令牌并不会阻止在启用 Data Protection 支持之前发行的 JWT 令牌被验证：现有的令牌仍然可以与新发行的 ASP.NET Core 数据保护 令牌一起使用，直到它们过期。当发送包含 JWT 刷新令牌的刷新令牌请求时，应用程序将收到一个 ASP.NET Core 数据保护 刷新令牌，并且之前的令牌将自动标记为已兑换。\",\"默认情况下，启用 ASP.NET Core 数据保护 支持将自动将所有类型的令牌格式从 JWT 切换到 Data Protection，除了 JWT 令牌。可以配置 OpenIddict/Data Protection 集成，以在创建新令牌时首选 JWT，这在仅针对特定令牌类型（例如授权代码和刷新令牌，但不是访问令牌）使用 ASP.NET Core 数据保护 格式时非常有用。\",\"services.AddOpenIddict() .AddServer(options => { options.UseDataProtection() .PreferDefaultAccessTokenFormat() .PreferDefaultAuthorizationCodeFormat() .PreferDefaultDeviceCodeFormat() .PreferDefaultRefreshTokenFormat() .PreferDefaultUserCodeFormat(); }); \",\"注意\",\"当授权服务器和 API/资源服务器不是同一应用程序的一部分时，必须配置 ASP.NET Core 数据保护 使用相同的应用程序名称并共享相同的密钥环，以允许 OpenIddict 验证处理程序读取由位于另一个项目中的授权服务器生成的 ASP.NET Core 数据保护 令牌。\",\"有关更多信息，请阅读 配置 ASP.NET Core 数据保护。\"]},{\"header\":\"令牌存储\",\"slug\":\"令牌存储\",\"contents\":[\"为了跟踪其服务器服务生成的所有令牌，OpenIddict 3.0 会为每个生成的令牌在数据库中创建一个令牌条目。令牌条目包含元数据，如令牌的主题、发放给哪个应用程序的客户端标识符或其创建和过期日期。\",\"默认情况下，使用 Azure Active Directory IdentityModel Extensions for .NET 库生成 JWT 令牌或使用 ASP.NET Core Data Protection 生成 Data Protection 令牌时，令牌负载（token payload）通常不会存储在数据库中，除了授权码（authorization codes，生命周期短暂）、设备码和用户码（仅在设备代码流程中使用）。\",\"这样的令牌称为引用令牌（reference tokens），它们不会直接返回给调用者：相反，它们的负载存储在数据库条目中，并返回一个加密安全的随机 256 位标识符 – 称为引用标识符（reference identifier），作为客户端应用程序与 OpenIddict 终结点或资源服务器通信时使用的“最终”令牌（如果在服务器选项中启用了引用访问令牌）。\",\"相关信息\",\"在 OpenIddict 3.0 中，撤销令牌的能力不与令牌格式绑定，并且不需要启用引用令牌：只要在服务器选项中没有明确禁用令牌存储，就可以撤销常规 JWT 或 ASP.NET Core Data Protection 令牌。\"]},{\"header\":\"启用引用访问和/或刷新令牌\",\"slug\":\"启用引用访问和-或刷新令牌\",\"contents\":[\"对于偏好返回较短的访问和/或刷新令牌或需要处理限制以防止在网络上传输大型令牌的开发人员，可以在服务器选项中手动启用引用访问和/或刷新令牌。\",\"警告\",\"在启用引用访问和/或刷新令牌支持时，强烈建议执行以下操作之一：\",\"对于访问和刷新令牌，使用 ASP.NET Core Data Protection 格式，因为它们受益于额外的安全措施，如果它们被从数据库中窃取，可以防止以原始形式发送。有关如何启用 ASP.NET Core Data Protection 的更多信息，请阅读令牌格式。\",\"启用列加密/数据静态加密，以保护令牌条目的 Payload 列。\",\"services.AddOpenIddict() .AddServer(options => { options.UseReferenceAccessTokens() .UseReferenceRefreshTokens(); }); \"]},{\"header\":\"启用 API 级别的令牌条目验证\",\"slug\":\"启用-api-级别的令牌条目验证\",\"contents\":[\"出于性能考虑，OpenIddict 3.0 默认情况下不会在收到 API 请求时检查令牌条目的状态：访问令牌被视为有效，直到它们过期。对于需要立即撤销访问令牌的情况，可以配置 OpenIddict 验证处理程序以强制执行每个 API 请求的令牌条目验证：\",\"相关信息\",\"启用令牌条目验证要求 OpenIddict 验证处理程序直接访问存储令牌的服务器数据库，这使得它更适合于位于授权服务器相同应用程序中的 API。对于外部应用程序，请考虑使用 introspection 而不是本地验证。\",\"在两种情况下，都会产生额外的延迟 - 由于额外的 DB 请求和 introspection 的 HTTP 调用而引起。\",\"services.AddOpenIddict() .AddValidation(options => { options.EnableTokenEntryValidation(); }); \"]},{\"header\":\"禁用令牌存储\",\"slug\":\"禁用令牌存储\",\"contents\":[\"虽然强烈不建议，但可以在服务器选项中禁用令牌存储\",\"services.AddOpenIddict() .AddServer(options => { options.DisableTokenStorage(); }); \",\"注意\",\"禁用令牌存储会阻止启用引用访问或刷新令牌支持，因为这需要将令牌存储在数据库中。\"]},{\"header\":\"集成\",\"slug\":\"集成\",\"contents\":[]},{\"header\":\"Entity Framework Core 集成\",\"slug\":\"entity-framework-core-集成\",\"contents\":[]},{\"header\":\"基本配置\",\"slug\":\"基本配置\",\"contents\":[\"要将 OpenIddict 配置为使用 Entity Framework Core 作为应用程序、授权、范围和令牌的数据库，请执行以下操作：\",\"引用 OpenIddict.EntityFrameworkCore 包：\",\"<PackageReference Include=\\\"OpenIddict.EntityFrameworkCore\\\" Version=\\\"3.1.1\\\" /> \",\"创建从 DbContext（或在使用 ASP.NET Core Identity 时为 IdentityDbContext）派生的数据库上下文：\",\"public class ApplicationDbContext : DbContext { public ApplicationDbContext(DbContextOptions options) : base(options) { } } \",\"配置 OpenIddict 使用 Entity Framework Core 存储：\",\"services.AddOpenIddict() .AddCore(options => { options.UseEntityFrameworkCore() .UseDbContext<ApplicationDbContext>(); }); \",\"配置 Entity Framework Core，将 OpenIddict 实体注册到模型中：\",\"services.AddDbContext<ApplicationDbContext>(options => { // 将实体框架核心配置为使用Microsoft SQL Server。 options.UseSqlServer(Configuration.GetConnectionString(\\\"DefaultConnection\\\")); // 注册OpenIddict所需的实体集。 options.UseOpenIddict(); }); \",\"使用迁移或重新创建数据库以添加 OpenIddict 实体。有关更多信息，请阅读迁移概述。\"]},{\"header\":\"高级配置\",\"slug\":\"高级配置\",\"contents\":[]},{\"header\":\"使用自定义主键类型\",\"slug\":\"使用自定义主键类型\",\"contents\":[\"默认情况下，Entity Framework Core 集成使用字符串主键，该主键类型与 ASP.NET Core Identity 使用的默认键类型匹配。\",\"如果要使用不同的键类型（例如 int、long 或 Guid）：\",\"调用泛型 ReplaceDefaultEntities<TKey>() 方法，强制 OpenIddict 使用指定键类型的默认实体：\",\"services.AddOpenIddict() .AddCore(options => { // 将OpenIddict配置为使用具有自定义密钥类型的默认实体。 options.UseEntityFrameworkCore() .UseDbContext<ApplicationDbContext>() .ReplaceDefaultEntities<Guid>(); }); \",\"配置 Entity Framework Core，将具有选定键类型的默认实体包含在模型中：\",\"services.AddDbContext<ApplicationDbContext>(options => { // 将实体框架核心配置为使用Microsoft SQL Server。 options.UseSqlServer(Configuration.GetConnectionString(\\\"DefaultConnection\\\")); // 注册OpenIddict所需的实体集，但使用自定义密钥类型。 options.UseOpenIddict<Guid>(); }); \"]},{\"header\":\"使用自定义实体\",\"slug\":\"使用自定义实体\",\"contents\":[\"对于需要在 OpenIddict 使用的属性之外存储附加数据的应用程序，可以使用自定义实体。为此，您需要执行以下操作：\",\"创建自定义实体：\",\"public class CustomApplication : OpenIddictEntityFrameworkCoreApplication<long, CustomAuthorization, CustomToken> { public string CustomProperty { get; set; } } public class CustomAuthorization : OpenIddictEntityFrameworkCoreAuthorization<long, CustomApplication, CustomToken> { public string CustomProperty { get; set; } } public class CustomScope : OpenIddictEntityFrameworkCoreScope<long> { public string CustomProperty { get; set; } } public class CustomToken : OpenIddictEntityFrameworkCoreToken<long, CustomApplication, CustomAuthorization> { public string CustomProperty { get; set; } } \",\"调用泛型 ReplaceDefaultEntities<TApplication, TAuthorization, TScope, TToken, TKey>() 方法，强制 OpenIddict 使用自定义实体：\",\"services.AddOpenIddict() .AddCore(options => { // 配置OpenIddict以使用自定义实体。 options.UseEntityFrameworkCore() .UseDbContext<ApplicationDbContext>() .ReplaceDefaultEntities<CustomApplication, CustomAuthorization, CustomScope, CustomToken, long>(); }); \",\"配置 Entity Framework Core，将自定义实体包含在模型中：\",\"services.AddDbContext<ApplicationDbContext>(options => { // Configure Entity Framework Core to use Microsoft SQL Server. options.UseSqlServer(Configuration.GetConnectionString(\\\"DefaultConnection\\\")); // Register the entity sets needed by OpenIddict but use the specified entities instead of the default ones. options.UseOpenIddict<CustomApplication, CustomAuthorization, CustomScope, CustomToken, long>(); }); \"]}]},\"/articles/distributed-middleware/cicd/\":{\"title\":\"CI/CD\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"CI/CD是指持续集成（Continuous Integration）和持续交付/部署（Continuous Delivery/Deployment）。它们是软件开发中自动化流程的核心，并且可以在整个软件开发生命周期中帮助团队更快、更稳定地交付高质量的软件。\",\"持续集成是一种实践，将代码频繁地集成到共享存储库中，然后自动构建和测试应用程序以确保其质量。通过尽早发现和解决问题，持续集成可以减少集成延迟和错误。\",\"持续交付/部署是在持续集成的基础上构建的。它是将代码自动化部署到生产环境的过程，以确保更快速、更高效的交付价值。这可以通过自动化构建、测试和部署管道来实现，以便在每次代码更改时自动运行。\"]}]},\"/articles/distributed-middleware/cicd/jenkins.html\":{\"title\":\"Jenkins + Gitee 持续集成交付\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"Jenkins是一个开源的自动化服务器，可以帮助软件开发人员自动化构建、测试和部署他们的项目。它支持多种编程语言和工具，并且可以与许多其他工具和服务集成，如Git、Docker、AWS、Slack等。Jenkins还提供了一个易于使用的Web界面，可以方便地配置和管理自动化流程。\"]},{\"header\":\"安装 Jenkins\",\"slug\":\"安装-jenkins\",\"contents\":[\"部署环境： ConterOS 7 + Docker Compose\"]},{\"header\":\"新建 jenkins.yml 文件，输入以下内容：\",\"slug\":\"新建-jenkins-yml-文件-输入以下内容\",\"contents\":[\"version: '3' services: jenkins: image: jenkins/jenkins:jdk11 ports: - \\\"8100:8080\\\" - \\\"50000:50000\\\" volumes: - \\\"/var/jenkins_home:/var/jenkins_home\\\" - \\\"/var/run/docker.sock:/var/run/docker.sock\\\" - \\\"/usr/bin/docker:/usr/bin/docker\\\" # 这三个目录需要执行 chmod 777 授权 restart: always \"]},{\"header\":\"为相应文件授权\",\"slug\":\"为相应文件授权\",\"contents\":[\"权限不足可能造成之后 Jenkins 流水线失败\",\"chmod 777 /var/jenkins_home chmod 777 /var/run/docker.sock chmod 777 usr/bin/docker \"]},{\"header\":\"运行 jenkins.yml 脚本创建容器\",\"slug\":\"运行-jenkins-yml-脚本创建容器\",\"contents\":[\"docker-compose -f jenkins.yml up -d \",\"访问：[ip]:8100 会看到如下 Jenkins 页面：\",\"根据提示访问对应文件路径即可拿到管理员密码。\"]},{\"header\":\"安装插件\",\"slug\":\"安装插件\",\"contents\":[\"输入管理员密码后点击 继续，将会进入插件安装界面：\",\"安装推荐的插件即可。\",\"等待安装插件\",\"等待插件安装完成。\",\"若安装插件的过程中出现多个插件安装失败(版本不兼容)的情况，可参考常见问题\"]},{\"header\":\"创建用户\",\"slug\":\"创建用户\",\"contents\":[\"创建用户\",\"根据提示输入即可。\"]},{\"header\":\"实例配置\",\"slug\":\"实例配置\",\"contents\":[\"实例配置\",\"直接下一步。\"]},{\"header\":\"安装完成\",\"slug\":\"安装完成\",\"contents\":[\"完成\"]},{\"header\":\"创建测试Web应用\",\"slug\":\"创建测试web应用\",\"contents\":[\"创建 .Net Core Web 应用程序\",\"为项目添加 DockerFile 支持\",\"将项目代码上传至 gitee 仓库\"]},{\"header\":\"创建 Jenkins 任务\",\"slug\":\"创建-jenkins-任务\",\"contents\":[\"首页点击 新建任务\",\"新建任务\",\"输入 任务名称\",\"输入任务名称\",\"选择 自由风格 的任务，进入下一步\",\"自由风格\",\"随便输入描述\",\"描述\",\"源码管理\",\"按照如下配置：\",\"源码管理配置\",\"其中，Repository URL 为仓库地址。\",\"格式为：https://[gitee账号]:[gitee密码]@gitee.com/[空间名称]/[仓库名称].git\",\"构建环境\",\"构建环境\",\"Build Steps\",\"选择 执行 Shell，填入下面的 Shell 脚本：\",\" #!/bin/bash # 加载环境变量 source /etc/profile echo ----------获取短版本号---------- SHORT_VERSION=`git rev-parse --short HEAD` echo $SHORT_VERSION echo ----------移动Dockerfile文件到当前文件夹---------- cp src/[Web项目文件夹]/Dockerfile . echo ----------打包镜像---------- docker build -t identity.image:$SHORT_VERSION . echo ----------标记最新版本---------- docker tag identity.image:$SHORT_VERSION identity.image:latest echo ----------如果容器存在，则停止并删除旧的容器---------- CID=$(docker ps | grep \\\"identity\\\" | awk '{print $1}') echo $CID if [ \\\"$CID\\\" != \\\"\\\" ]; then echo ----------停止当前运行的容器---------- docker stop $CID echo ----------删除当前运行的容器---------- docker rm $CID fi echo ----------重新创建容器---------- docker run -d --name identity -p 6100:80 -p 443:443 identity.image:latest --restart=always echo ----------删除所有none的镜像---------- docker rmi `docker images | grep \\\"<none>\\\" | awk '{print $3}'` \",\"配置完成后保存即可。\"]},{\"header\":\"手动执行 Jenkins 任务\",\"slug\":\"手动执行-jenkins-任务\",\"contents\":[]},{\"header\":\"立即构建\",\"slug\":\"立即构建\",\"contents\":[\"在任务页面点击 立即构建 执行任务\",\"立即构建\"]},{\"header\":\"查看控制台输出\",\"slug\":\"查看控制台输出\",\"contents\":[\"点击 任务序号\",\"点击 控制台输出\",\"显示如下内容说明构建成功：\",\"构建成功\",\"此时即可访问 [ip]:6100 查看部署的 Web 页面\"]},{\"header\":\"配置 Gitee WebHooks\",\"slug\":\"配置-gitee-webhooks\",\"contents\":[]},{\"header\":\"安装 Gitee 插件\",\"slug\":\"安装-gitee-插件\",\"contents\":[\"进入 Jenkins 插件管理页面\",\"插件管理\",\"搜索 gitee 插件并安装\",\"安装 gitee 插件\"]},{\"header\":\"配置 Gitee 触发器\",\"slug\":\"配置-gitee-触发器\",\"contents\":[\"打开之前创建的 jenkins 任务的配置页面，按照如下内容配置触发器：\",\"Gitee 触发器\",\"这里的 Gitee WebHook 地址等下要用。\",\"Gitee 触发器\",\"生成 Gitee WebHook 密码\"]},{\"header\":\"配置 Gitee WebHooks\",\"slug\":\"配置-gitee-webhooks-1\",\"contents\":[\"打开 web 应用程序的 gitee 仓库的 WebHooks 管理页面，将上一步中的 Gitee WebHook 地址和密码填入对应位置，勾选触发事件，保存即可。\",\"Gitee WebHooks\"]},{\"header\":\"完成\",\"slug\":\"完成\",\"contents\":[]},{\"header\":\"常见问题\",\"slug\":\"常见问题\",\"contents\":[]},{\"header\":\"插件安装失败\",\"slug\":\"插件安装失败\",\"contents\":[]},{\"header\":\"更新 docker 为最新版本\",\"slug\":\"更新-docker-为最新版本\",\"contents\":[]},{\"header\":\"更新 jenkins 为最新版本\",\"slug\":\"更新-jenkins-为最新版本\",\"contents\":[\"从官网下载最新的 jenkins.war 包并上传至部署 Jenkins 的服务器\",\"删除容器中旧的 jenkins.war 包\",\"# 进入容器 docker exec -it -u root [container_id] /bin/bash # 删除旧的 jenkins.war 包 rm /usr/share/jenkins/jenkins.war \",\"将下载的 jenkins.war 包复制进容器中\",\"docker cp jenkins.war [container_id]:/usr/share/jenkins \",\"重启容器\",\"sudo docker restart [container_id] \"]}]},\"/articles/distributed-middleware/elasticsearch/\":{\"title\":\"Elasticsearch\",\"contents\":[]},\"/articles/distributed-middleware/rabbitmq/\":{\"title\":\"RabbitMQ\",\"contents\":[{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"RabbitMQ 是一种消息代理，它接受并转发消息。你可以将其看作一个邮局：当你把信件放进邮箱时，你可以确信邮递员最终会将信件送到收件人手中。在这个比喻中，RabbitMQ 就像是一个邮箱、一个邮局和一个邮递员。\",\"RabbitMQ 与邮局的主要区别在于，它不处理纸质文件，而是接受、存储和转发二进制数据块——即消息。\",\"RabbitMQ 以及消息传递通常使用一些术语。\",\"Producing 意味着发送。发送消息的程序被称为生产者（producer）：\",\"producer\",\"在 RabbitMQ 中，队列是指邮箱的名称。尽管消息流经 RabbitMQ 和你的应用程序，但它们只能存储在一个队列内。队列只受主机内存和磁盘限制的约束，实际上是一个大型消息缓冲区。多个生产者可以向一个队列发送消息，许多消费者也可以尝试从一个队列接收数据。以下是队列（queue）的表示方式：\",\"queue\",\"Consuming 和 receiving 有类似的含义。消费者（consumer）是一个主要等待接收消息的程序：\",\"consumer\",\"请注意，生产者、消费者和代理不必驻留在同一主机上；实际上，在大多数应用程序中它们都不在同一主机上。一个应用程序也可以既是生产者又是消费者。\",\"注意\",\"本系列中的代码示例均由 C#/.NET 实现\",\"RabbitDemo地址\"]}]},\"/articles/distributed-middleware/rabbitmq/dead-letter-queue.html\":{\"title\":\"死信队列\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"死信队列（Dead-Letter Queue，DLQ）是一个特殊的消息队列，用于存储无法被消费者正确处理的“死信”消息。当消息被发送到队列时，如果这条消息无法被消费者成功处理或超过了 TTL 时间限制，那么就会被发送到死信队列中。\",\"使用死信队列的主要目的是防止消息丢失或者被忽略，同时也方便进行消息重试、错误分析和监控等操作。\",\"在 RabbitMQ 中，可以通过以下步骤来创建和配置死信队列：\",\"创建一个普通的消息队列，并将该队列与一个交换机绑定。\",\"为该队列设置 DLX 属性，指定该队列的死信消息应该发送到哪个交换机中。\",\"创建一个专门用于存储死信消息的队列，并将该队列与上一步所指定的交换机绑定。\",\"配置队列的 TTL 和其他属性，以便在特定条件下将消息发送到死信队列中。\",\"以下是一个示例代码，展示了如何使用 .NET 6 创建一个带有死信队列的 RabbitMQ 消息队列：\",\"// 创建连接和通道对象 var factory = new ConnectionFactory() { HostName = \\\"localhost\\\" }; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) { // 创建一个普通的消息队列 var queueName = \\\"test_queue\\\"; channel.QueueDeclare(queue: queueName, durable: true, exclusive: false, autoDelete: false, arguments: null); // 设置队列的 TTL 和 DLX 属性 var arguments = new Dictionary<string, object> { { \\\"x-message-ttl\\\", 30000 }, // 设置队列中消息的 TTL 为 30 秒 { \\\"x-dead-letter-exchange\\\", \\\"dlx_exchange\\\" } // 设置该队列的死信交换机为 dlx_exchange }; // 将队列与交换机绑定，并设置队列属性 channel.QueueBind(queue: queueName, exchange: \\\"test_exchange\\\", routingKey: \\\"\\\", arguments); // 创建一个专门用于存储死信消息的队列 var dlxQueueName = \\\"test_dlx_queue\\\"; channel.QueueDeclare(queue: dlxQueueName, durable: true, exclusive: false, autoDelete: false, arguments: null); // 将死信队列与指定的交换机绑定 channel.ExchangeDeclare(exchange: \\\"dlx_exchange\\\", type: ExchangeType.Fanout); channel.QueueBind(queue: dlxQueueName, exchange: \\\"dlx_exchange\\\", routingKey: \\\"\\\"); // 启动消费者，接收消息并输出 var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) => { var message = Encoding.UTF8.GetString(ea.Body.ToArray()); Console.WriteLine($\\\"Received message: {message}\\\"); }; channel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer); Console.WriteLine(\\\"Press [enter] to exit.\\\"); Console.ReadLine(); } \",\"在上述示例中，我们首先创建了一个普通的消息队列，并将该队列与交换机进行了绑定。然后，我们通过 QueueDeclare 方法为该队列设置了 TTL 和 DLX 属性，以及其他相关属性。\",\"接下来，我们创建了一个专门用于存储死信消息的队列，将该队列与指定的 DLX 交换机进行了绑定，并使用 ExchangeDeclare 方法声明了该交换机的类型为 Fanout。\",\"最后，我们启动了一个消费者，循环接收并输出队列中的消息。在运行时，如果某条消息无法被正确处理或者超过了 TTL 时间限制，那么它就会被自动发送到死信队列中，从而保证消息不会丢失或者被忽略。\"]}]},\"/articles/distributed-middleware/rabbitmq/publish-subscribe-mode.html\":{\"title\":\"发布订阅模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"发布/订阅模式（Publish-Subscribe Model）是 RabbitMQ 中常见的消息模式之一，它允许多个消费者接收同一个消息，每个消费者都会获得该消息的副本。在这种模式下，生产者只需将消息发送到交换机，由交换机将消息传递给所有订阅了该交换机的队列。因此，这种模式也被称为广播模式。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"发布/订阅模式（Publish-Subscribe Model）是 RabbitMQ 中常见的消息模式之一，它允许多个消费者接收同一个消息，每个消费者都会获得该消息的副本。在这种模式下，生产者只需将消息发送到交换机，由交换机将消息传递给所有订阅了该交换机的队列。因此，这种模式也被称为广播模式。\",\"发布订阅\"]},{\"header\":\"交换机\",\"slug\":\"交换机\",\"contents\":[\"交换机是 RabbitMQ 中一个非常重要的概念，它负责接收从生产者发来的消息，并将消息路由到相应的队列中。RabbitMQ 定义了多种类型的交换机，如下所示：\",\"Direct Exchange：直连式交换机，根据消息的 Routing Key 直接匹配到相应的队列。\",\"Fanout Exchange：扇形交换机，将消息广播到绑定到这个交换机上的所有队列。\",\"Topic Exchange：主题交换机，根据消息的 Routing Key 进行匹配，可以支持通配符。\",\"Headers Exchange：头交换机，使用消息头部的键值对进行匹配。\",\"在发布/订阅模式中，我们通常会使用 Fanout Exchange 进行消息的广播。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"发布/订阅模式适用于需要将消息广播给多个消费者的场景，例如新闻订阅、日志记录等。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"分别启动消费者及生产者客户端，得到如下输出：\",\"从输出结果中我们可以看到，生产者发出的消息被所有订阅者收到。\"]}]},\"/articles/distributed-middleware/rabbitmq/publisher-confirms-model%20copy.html\":{\"title\":\"发布者确认模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"发布者确认模式是一种确保消息传递成功的机制，在 RabbitMQ 中，可以通过开启 Publisher Confirms 功能来实现。当开启 Publisher Confirms 后，生产者发送消息时，RabbitMQ 会对消息进行确认，以确保消息已被正确接收和处理。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"发布者确认模式是一种确保消息传递成功的机制，在 RabbitMQ 中，可以通过开启 Publisher Confirms 功能来实现。当开启 Publisher Confirms 后，生产者发送消息时，RabbitMQ 会对消息进行确认，以确保消息已被正确接收和处理。\",\"发布者确认模式有三种策略：\",\"逐个发布消息\",\"批量发布消息\",\"异步处理发布者确认\"]},{\"header\":\"逐个发布消息\",\"slug\":\"逐个发布消息\",\"contents\":[]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"逐个发布消息适用于需要在确保每条消息可靠传输的情况下发送消息的场景，例如在需要向多个消费者发送不同的消息时，可以使用 Publisher Confirms 来确保每个消息都能被准确地传递。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点：逐个发布消息可以确保每条消息都能够可靠地传输。\",\"缺点：由于每个消息都要等待确认结果后才能进行后续操作，可能会增加处理时间和网络负载。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[]},{\"header\":\"批量发布消息\",\"slug\":\"批量发布消息\",\"contents\":[]},{\"header\":\"使用场景\",\"slug\":\"使用场景-1\",\"contents\":[\"批量发布消息适用于需要同时发送多条消息的场景，例如在向多个消费者广播同一消息时，可以使用 Publisher Confirms 来提高消息发送效率。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点-1\",\"contents\":[\"优点：批量发布消息可以提高消息发送效率，减少网络负载和处理时间。\",\"缺点：由于需要等待所有消息被确认后才能进行后续操作，可能会增加处理时间和网络负载。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例-1\",\"contents\":[]},{\"header\":\"异步处理发布者确认\",\"slug\":\"异步处理发布者确认\",\"contents\":[]},{\"header\":\"使用场景\",\"slug\":\"使用场景-2\",\"contents\":[\"批量发布消息适用于需要同时发送多条消息的场景，例如在向多个消费者广播同一消息时，可以使用 Publisher Confirms 来提高消息发送效率。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点-2\",\"contents\":[\"优点：异步处理发布者确认可以减少生产者线程的阻塞时间，提高生产者的并发能力。\",\"缺点：由于需要额外的事件处理程序来处理确认结果，可能会增加代码复杂度。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例-2\",\"contents\":[\"Publisher Confirms 是 RabbitMQ 中一种确保消息传递成功的机制，能够提高消息传递可靠性和效率。通过设置 Publisher Confirms 功能和处理异步确认事件，生产者可以在确保每条消息被正确接收和处理的同时，避免阻塞线程和提高并发能力。同时，消费者可以通过创建事件基本消费者并监听指定队列，实现对消息的接收和处理。\"]}]},\"/articles/distributed-middleware/rabbitmq/rabbitmq-kuozhan.html\":{\"title\":\"扩展内容\",\"contents\":[{\"header\":\"懒惰队列\",\"slug\":\"懒惰队列\",\"contents\":[\"懒惰队列是一种延迟加载消息的队列，在 RabbitMQ 中可以通过设置队列的 x-queue-mode 参数为 lazy 来开启懒惰队列模式。在使用懒惰队列时，RabbitMQ 会将消息存储到磁盘上，并在需要消费时才将其加载到内存中进行处理，以减少内存消耗并提高性能。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"懒惰队列适用于以下场景：\",\"需要存储大量消息的队列。\",\"需要长时间保存消息的队列，例如日志记录。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点\",\"contents\":[\"优点：懒惰队列可以减少内存消耗，并提高消息存储和传递效率。\",\"缺点：由于需要将消息从磁盘加载到内存中进行处理，可能会增加消息传递的延迟，并且需要考虑磁盘性能对消息处理的影响。\"]},{\"header\":\"仲裁队列\",\"slug\":\"仲裁队列\",\"contents\":[\"仲裁队列是 RabbitMQ 中用于解决网络分区问题的一种机制，它会在发生网络分区时，将受影响的节点切换至脱机状态，以避免数据损坏和不一致性。在 RabbitMQ 中，可以通过设置队列的 x-queue-type 参数为 quorum 来创建仲裁队列。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景-1\",\"contents\":[\"仲裁队列适用于以下场景：\",\"在具有多个节点的 RabbitMQ 集群中使用。\",\"希望确保消息传递的可靠性和一致性。\"]},{\"header\":\"优缺点\",\"slug\":\"优缺点-1\",\"contents\":[\"优点：仲裁队列可以提高消息传递的可靠性和一致性，并在发生网络分区时保障数据安全。\",\"缺点：由于需要额外的资源来维护节点状态，可能会增加系统开销和复杂度。\",\"总体而言，懒惰队列和仲裁队列都是 RabbitMQ 中重要的特性，能够提高消息传递的效率和可靠性。但是在使用时需要根据场景和需求权衡其优缺点，选择合适的模式来应用。\"]}]},\"/articles/distributed-middleware/rabbitmq/routing-mode.html\":{\"title\":\"路由模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"在 RabbitMQ 中，路由模式（Routing Model）是一种消息传递方式，它允许发布者将消息发送到指定的队列中，并且只有符合特定条件的消费者才能接收到该消息。这种方式通常被用于需要将消息根据不同的路由键进行过滤和分类的场景。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"在 RabbitMQ 中，路由模式（Routing）是一种消息传递方式，它允许发布者将消息发送到指定的队列中，并且只有符合特定条件的消费者才能接收到该消息。这种方式通常被用于需要将消息根据不同的路由键进行过滤和分类的场景。\",\"在路由模式中，通常需要使用到交换机和多个队列。发布者向交换机发送一条带有路由键的消息，该消息会被转发到匹配的队列中，然后被对应的消费者接收和处理。\",\"直接交换机（Direct Exchange）是 RabbitMQ 中最简单的一种交换机类型，它是根据消息携带的 Routing Key 和队列绑定时设定的 Binding Key 进行精确匹配的，在直接交换机中，可以为多个队列绑定相同的 Binding Key，也可以为同一个队列绑定多个 Binding Key。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"实现一个如下图所示的路由模式示例：\",\"路由模式\",\"分别启动消费者及生产者客户端，得到如下输出：\",\"根据输出结果我们可以看到，orange 消息被路由到了 Q1 队列，black 和 green 消息被路由到了 Q2 队列。\",\"在直接交换机中，可以为多个队列绑定相同的 Binding Key，也可以为同一个队列绑定多个 Binding Key，适用于需要将消息分发给多个队列的场景。\"]}]},\"/articles/distributed-middleware/rabbitmq/rpc-mode.html\":{\"title\":\"RPC模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"RPC（Remote Procedure Call）模式是一种实现远程过程调用的消息模式，在 RabbitMQ 中通过将请求和响应封装到消息中，实现了客户端和服务端之间的通信。在 RPC 模式中，客户端发送一个带有回调队列地址的请求消息，服务端接收到请求消息后处理请求，并将响应发送到指定的回调队列中。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"RPC（Remote Procedure Call）模式是一种实现远程过程调用的消息模式，在 RabbitMQ 中通过将请求和响应封装到消息中，实现了客户端和服务端之间的通信。在 RPC 模式中，客户端发送一个带有回调队列地址的请求消息，服务端接收到请求消息后处理请求，并将响应发送到指定的回调队列中。\",\"RPC模式\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"RPC 模式适用于需要实现远程过程调用的场景，比如在分布式系统中，需要将某个操作委托给远程服务器进行处理并返回结果。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"ConcurrentDictionary 是 .NET Framework 和 .NET Core 中的一个线程安全的哈希表实现，用于存储 key-value 对象。它支持并发读写操作，并且能够在多个线程同时访问时保证数据的一致性和完整性。与传统的 Dictionary 不同，ConcurrentDictionary 中的所有方法都是线程安全的，这意味着我们可以在多个线程中同时添加或删除元素，而不必担心数据冲突或竞争条件等问题。ConcurrentDictionary 提供了许多常见的哈希表操作，例如添加元素、删除元素、更新元素、枚举元素等。由于它是线程安全的，因此可以在高并发场景下使用，例如实现 RPC 系统中客户端和服务器通信过程中的请求-响应映射关系。 ↩︎\",\"TaskCompletionSource 是一个用于创建和管理异步操作的工具类，它允许我们在任何时间手动设置执行结果并通知等待该任务完成的所有线程或任务。具体而言，它提供了以下几个主要的功能：\",\"创建一个新的 Task 对象并返回它；\",\"通过 SetResult、SetException 或 SetCanceled 方法设置 Task 的状态，并将其标记为已完成；\",\"允许异步等待 Task 完成，并等待 SetResult、SetException 或 SetCanceled 方法被调用并将 Task 标记为已完成。\",\"使用 TaskCompletionSource 可以更灵活地控制异步操作的状态和执行过程，例如在异步方法中使用 await 等待开启的任务的结果，或者在异步代码中手动创建任务来表示某些复杂的并发逻辑，从而简化异步程序的实现和维护。\",\"在 RPC 系统中，TaskCompletionSource 常常用于实现客户端与服务器端之间的请求-响应映射关系，即为每个 RPC 请求创建一个唯一的 Task 实例，并在接收到相应的响应消息时，将响应结果传递给对应的 Task 对象，以便客户端程序获取到服务器端的处理结果。 ↩︎\",\"CancellationToken 是 .NET Framework 和 .NET Core 中的一个用于在多个线程之间协调取消操作的机制。它允许我们创建 CancellationToken 对象，并将其传递给异步或长时间运行的操作，以便在需要时随时取消该操作，避免不必要的资源浪费和性能下降。\",\"CancellationToken 的主要特点包括：\",\"它是一个轻量级对象，可以在任何时候创建和传递；\",\"它支持在异步方法中通过 CancellationTokn 取消异步任务的执行；\",\"它支持在长时间运行的任务中周期性地检查 CancellationTokn 是否被取消，并及时停止任务的执行；\",\"它支持取消多个操作，例如同时取消多个 HTTP 请求等。\",\"在 RPC 系统中，CancellationToken 常常用于控制客户端与服务器端之间的通信超时时间，从而避免客户端程序一直阻塞等待服务器端的响应消息而导致性能下降或资源浪费的问题。具体而言，在发起 RPC 请求时，客户端程序可以选择传入一个 CancellationToken 对象以便在需要时随时取消该请求。如果在指定的时间内（通过 CancellationToken 对象的 WithTimeout() 或者 Register() 方法设置）仍未收到服务器端的响应消息，则会自动取消该请求并执行注册的回调函数（即将相关的映射关系从 callbackMapper 字典中移除）。 ↩︎\"]}]},\"/articles/distributed-middleware/rabbitmq/simple-mode.html\":{\"title\":\"简单模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"RabbitMQ 简单模式（Simple Mode）是 RabbitMQ 最基础的一种使用模式，也称为点对点模式。在简单模式中，一个生产者向一个消费者发送消息，消费者从队列中获取并处理该消息。这种模式非常适用于只有一个消费者需要处理任务的场景，如日志处理、计算任务等。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"RabbitMQ 简单模式（Simple Mode）是 RabbitMQ 最基础的一种使用模式，也称为“Hello World”模式，它包括一个生产者将消息发送到队列中，然后一个消费者从该队列接收并处理该消息。\",\"简单模式\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"简单队列模式适用于需要单个消费者处理任务的场景，例如：\",\"异步处理任务：通过将任务放入队列中，让消费者异步处理任务，从而提高系统的吞吐量和性能。\",\"消息传递：通过消息代理传递消息，使得不同的应用程序可以异步地进行解耦合的通信。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"简单队列模式是 RabbitMQ 中最简单的消息模式之一，适用于需要单个消费者处理任务的场景。本文演示了如何使用 RabbitMQ 实现简单队列模式，包括生产者将消息发送到队列中，消费者从队列中接收并处理该消息。\"]}]},\"/articles/distributed-middleware/rabbitmq/topic-mode.html\":{\"title\":\"主题模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"在 RabbitMQ 中，主题模式（Topic Model）是一种比直接交换机更灵活的交换机类型，它可以根据消息携带的 Routing Key 和队列绑定时设定的 Binding Key 进行模糊匹配。主题模式可以使用通配符 * 和 # 对 Routing Key 进行模糊匹配。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"在 RabbitMQ 中，主题模式是一种比直接交换机更灵活的交换机类型，它可以根据消息携带的 Routing Key 和队列绑定时设定的 Binding Key 进行模糊匹配。主题模式可以使用通配符 * 和 # 对 Routing Key 进行模糊匹配。\",\"* 匹配一个单词（单词由点号分隔）\",\"# 匹配零个或多个单词\",\"例如，在一个 Routing Key 为 first.second.third.fourth 的消息中，*.second.*.fourth 可以匹配该消息，但 first.#.fourth 也可以匹配该消息。\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"主题模式适用于需要将消息根据多个条件进行过滤和分类的场景，比如在电商系统中，需要将新订单的消息根据商品类型和区域分别发送到不同的队列中进行处理。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"实现一个如下图所示的主题模式示例：\",\"主题模式\",\"分别启动消费者及生产者客户端，得到如下输出：\",\"在这个例子中，我们将发送描述动物的消息。这些消息将使用由三个单词（两个点）组成的路由键发送。路由键中的第一个单词描述速度，第二个单词描述颜色，第三个单词描述物种：<speed>.<colour>.<species>。\",\"我们创建了三个绑定：Q1 绑定了绑定键 .orange.，而 Q2 绑定了 ..rabbit 和 lazy.#。\",\"这些绑定可以总结为：\",\"Q1 对所有橙色动物感兴趣。 Q2 想听关于兔子和关于懒惰动物的一切。\",\"根据通配符模糊匹配的规则，路由键设置为 quick.orange.rabbit 的消息将被传递到两个队列中。消息 lazy.orange.elephant 也会传递到它们两个。另一方面，quick.orange.fox 只会进入第一个队列，lazy.brown.fox 则只会进入第二个队列。lazy.pink.rabbit 虽然与两个绑定匹配，但仅传递到第二个队列一次。quick.brown.fox、orange 和 quick.orange.new.rabbit 不匹配任何绑定，因此将被丢弃。\",\"lazy.orange.new.rabbit 尽管有四个单词，但将匹配最后一个绑定，并将传递到第二个队列。\"]}]},\"/articles/distributed-middleware/rabbitmq/work-queue-mode.html\":{\"title\":\"工作队列模式\",\"contents\":[{\"header\":\"\",\"slug\":\"\",\"contents\":[\"✨✨✨✨✨\",\"工作队列模式（Work Queue Mode）是一个常见的消息队列应用模式，通常是一个生产者对多个消费者的模型。在该模式下，生产者将待处理的任务放入队列中，由多个消费者从队列中获取任务并进行处理。例如将耗时的任务异步地分配给多个工作者进行处理。在工作队列中，消息生产者将待处理的任务放入队列中，由一组工作者来竞争性地消费这些任务，并将处理结果返回给消息代理或存储到数据仓库中。\"]},{\"header\":\"介绍\",\"slug\":\"介绍\",\"contents\":[\"工作队列模式（Work Queue Mode）是一个常见的消息队列应用模式，通它包括一个或多个生产者将消息发送到队列中，然后一个或多个消费者从该队列接收并处理消息。工作队列模式的特点在于可以在多个消费者之间分配和平衡负载，并且可以确保每个消息只被消费一次。\",\"工作队列模式\"]},{\"header\":\"使用场景\",\"slug\":\"使用场景\",\"contents\":[\"工作队列模式适用于需要处理大量任务的场景，例如：\",\"后台任务处理：通过将任务放入队列中，让多个消费者异步处理任务，从而提高系统的吞吐量和性能。\",\"负载均衡：通过多个消费者共同处理队列中的任务，实现任务的分配和负载均衡。\"]},{\"header\":\"循环调度\",\"slug\":\"循环调度\",\"contents\":[\"在循环调度模式中，RabbitMQ 会尝试将消息平均分配给所有可用的消费者，而不考虑每个消费者的处理能力和负载情况。当消费者数量不变时，每个消费者将在轮换周期内依次接收到消息。\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例\",\"contents\":[\"分别启动消费者及生产者客户端，得到如下输出：\",\"从输出结果中我们可以看到，消费者1和消费者2都处理了5条消息，但是耗时却相差距大，由此我们可以验证，在循环调度模式中，RabbitMQ 将消息平均分配给所有可用的消费者，而不考虑每个消费者的处理能力和负载情况。当消费者数量不变时，每个消费者将在轮换周期内依次接收到消息。\"]},{\"header\":\"公平调度\",\"slug\":\"公平调度\",\"contents\":[\"在公平调度模式中，RabbitMQ 会尝试将消息均匀地分配给所有可用的消费者，并确保每个消费者一次只接收一个消息。这样，即使某个消费者的处理时间较长或负载较重，也不会影响其他消费者的正常处理。\",\"公平调度\"]},{\"header\":\"代码示例\",\"slug\":\"代码示例-1\",\"contents\":[\"生产者代码与循环调度中一致。\",\"分别启动消费者及生产者客户端，得到如下输出：\",\"从输出结果中我们可以看到，消费者1和消费者2因为处理能力的不同，分别处理了不同数量的消息。\",\"所以我们可以在代码中通过 channel.BasicQos(0, 1, false) 设置每个消费者最多只能处理一条消息，避免某些消费者被过度负载而导致其他消费者处于空闲状态。\"]}]}}}");self.onmessage=({data:o})=>{self.postMessage($(o.query,m[o.routeLocale]))};
//# sourceMappingURL=original.js.map
